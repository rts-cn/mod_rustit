/* automatically generated by rust-bindgen 0.69.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const SWITCH_SIZEOF_VOIDP: u32 = 8;
pub const SWITCH_PREFIX_DIR: &[u8; 22] = b"/usr/local/freeswitch\0";
pub const SWITCH_SSIZE_T_FMT: &[u8; 3] = b"ld\0";
pub const SWITCH_SIZE_T_FMT: &[u8; 3] = b"ld\0";
pub const SWITCH_INT64_T_FMT: &[u8; 3] = b"ld\0";
pub const SWITCH_UINT64_T_FMT: &[u8; 3] = b"lu\0";
pub const FREESWITCH_PEN: &[u8; 6] = b"27880\0";
pub const FREESWITCH_OID_PREFIX: &[u8; 19] = b".1.3.6.1.4.1.27880\0";
pub const FREESWITCH_ITAD: &[u8; 4] = b"543\0";
pub const __EXTENSIONS__: u32 = 1;
pub const _XOPEN_SOURCE: u32 = 700;
pub const __BSD_VISIBLE: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __LONG_MAX: u64 = 9223372036854775807;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __USE_TIME_BITS64: u32 = 1;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const FILENAME_MAX: u32 = 4096;
pub const FOPEN_MAX: u32 = 1000;
pub const TMP_MAX: u32 = 10000;
pub const L_tmpnam: u32 = 20;
pub const L_ctermid: u32 = 20;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const L_cuserid: u32 = 20;
pub const O_CREAT: u32 = 64;
pub const O_EXCL: u32 = 128;
pub const O_NOCTTY: u32 = 256;
pub const O_TRUNC: u32 = 512;
pub const O_APPEND: u32 = 1024;
pub const O_NONBLOCK: u32 = 2048;
pub const O_DSYNC: u32 = 4096;
pub const O_SYNC: u32 = 1052672;
pub const O_RSYNC: u32 = 1052672;
pub const O_DIRECTORY: u32 = 16384;
pub const O_NOFOLLOW: u32 = 32768;
pub const O_CLOEXEC: u32 = 524288;
pub const O_ASYNC: u32 = 8192;
pub const O_DIRECT: u32 = 65536;
pub const O_LARGEFILE: u32 = 131072;
pub const O_NOATIME: u32 = 262144;
pub const O_PATH: u32 = 2097152;
pub const O_TMPFILE: u32 = 4210688;
pub const O_NDELAY: u32 = 2048;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const F_GETLK: u32 = 5;
pub const F_SETLK: u32 = 6;
pub const F_SETLKW: u32 = 7;
pub const F_SETOWN: u32 = 8;
pub const F_GETOWN: u32 = 9;
pub const F_SETSIG: u32 = 10;
pub const F_GETSIG: u32 = 11;
pub const F_SETOWN_EX: u32 = 15;
pub const F_GETOWN_EX: u32 = 16;
pub const F_GETOWNER_UIDS: u32 = 17;
pub const O_SEARCH: u32 = 2097152;
pub const O_EXEC: u32 = 2097152;
pub const O_TTY_INIT: u32 = 0;
pub const O_ACCMODE: u32 = 2097155;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const F_OFD_GETLK: u32 = 36;
pub const F_OFD_SETLK: u32 = 37;
pub const F_OFD_SETLKW: u32 = 38;
pub const F_DUPFD_CLOEXEC: u32 = 1030;
pub const F_RDLCK: u32 = 0;
pub const F_WRLCK: u32 = 1;
pub const F_UNLCK: u32 = 2;
pub const FD_CLOEXEC: u32 = 1;
pub const AT_FDCWD: i32 = -100;
pub const AT_SYMLINK_NOFOLLOW: u32 = 256;
pub const AT_REMOVEDIR: u32 = 512;
pub const AT_SYMLINK_FOLLOW: u32 = 1024;
pub const AT_EACCESS: u32 = 512;
pub const POSIX_FADV_NORMAL: u32 = 0;
pub const POSIX_FADV_RANDOM: u32 = 1;
pub const POSIX_FADV_SEQUENTIAL: u32 = 2;
pub const POSIX_FADV_WILLNEED: u32 = 3;
pub const POSIX_FADV_DONTNEED: u32 = 4;
pub const POSIX_FADV_NOREUSE: u32 = 5;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXU: u32 = 448;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXG: u32 = 56;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const S_IRWXO: u32 = 7;
pub const AT_NO_AUTOMOUNT: u32 = 2048;
pub const AT_EMPTY_PATH: u32 = 4096;
pub const AT_STATX_SYNC_TYPE: u32 = 24576;
pub const AT_STATX_SYNC_AS_STAT: u32 = 0;
pub const AT_STATX_FORCE_SYNC: u32 = 8192;
pub const AT_STATX_DONT_SYNC: u32 = 16384;
pub const AT_RECURSIVE: u32 = 32768;
pub const FAPPEND: u32 = 1024;
pub const FFSYNC: u32 = 1052672;
pub const FASYNC: u32 = 8192;
pub const FNONBLOCK: u32 = 2048;
pub const FNDELAY: u32 = 2048;
pub const F_OK: u32 = 0;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const F_SETLEASE: u32 = 1024;
pub const F_GETLEASE: u32 = 1025;
pub const F_NOTIFY: u32 = 1026;
pub const F_CANCELLK: u32 = 1029;
pub const F_SETPIPE_SZ: u32 = 1031;
pub const F_GETPIPE_SZ: u32 = 1032;
pub const F_ADD_SEALS: u32 = 1033;
pub const F_GET_SEALS: u32 = 1034;
pub const F_SEAL_SEAL: u32 = 1;
pub const F_SEAL_SHRINK: u32 = 2;
pub const F_SEAL_GROW: u32 = 4;
pub const F_SEAL_WRITE: u32 = 8;
pub const F_SEAL_FUTURE_WRITE: u32 = 16;
pub const F_GET_RW_HINT: u32 = 1035;
pub const F_SET_RW_HINT: u32 = 1036;
pub const F_GET_FILE_RW_HINT: u32 = 1037;
pub const F_SET_FILE_RW_HINT: u32 = 1038;
pub const RWF_WRITE_LIFE_NOT_SET: u32 = 0;
pub const RWH_WRITE_LIFE_NONE: u32 = 1;
pub const RWH_WRITE_LIFE_SHORT: u32 = 2;
pub const RWH_WRITE_LIFE_MEDIUM: u32 = 3;
pub const RWH_WRITE_LIFE_LONG: u32 = 4;
pub const RWH_WRITE_LIFE_EXTREME: u32 = 5;
pub const DN_ACCESS: u32 = 1;
pub const DN_MODIFY: u32 = 2;
pub const DN_CREATE: u32 = 4;
pub const DN_DELETE: u32 = 8;
pub const DN_RENAME: u32 = 16;
pub const DN_ATTRIB: u32 = 32;
pub const DN_MULTISHOT: u32 = 2147483648;
pub const F_OWNER_TID: u32 = 0;
pub const F_OWNER_PID: u32 = 1;
pub const F_OWNER_PGRP: u32 = 2;
pub const F_OWNER_GID: u32 = 2;
pub const FALLOC_FL_KEEP_SIZE: u32 = 1;
pub const FALLOC_FL_PUNCH_HOLE: u32 = 2;
pub const MAX_HANDLE_SZ: u32 = 128;
pub const SYNC_FILE_RANGE_WAIT_BEFORE: u32 = 1;
pub const SYNC_FILE_RANGE_WRITE: u32 = 2;
pub const SYNC_FILE_RANGE_WAIT_AFTER: u32 = 4;
pub const SPLICE_F_MOVE: u32 = 1;
pub const SPLICE_F_NONBLOCK: u32 = 2;
pub const SPLICE_F_MORE: u32 = 4;
pub const SPLICE_F_GIFT: u32 = 8;
pub const F_GETLK64: u32 = 5;
pub const F_SETLK64: u32 = 6;
pub const F_SETLKW64: u32 = 7;
pub const S_IFMT: u32 = 61440;
pub const S_IFDIR: u32 = 16384;
pub const S_IFCHR: u32 = 8192;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFIFO: u32 = 4096;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const UTIME_NOW: u32 = 1073741823;
pub const UTIME_OMIT: u32 = 1073741822;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const CHAR_MIN: u32 = 0;
pub const CHAR_MAX: u32 = 255;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const ULONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const ULLONG_MAX: i32 = -1;
pub const MB_LEN_MAX: u32 = 4;
pub const PIPE_BUF: u32 = 4096;
pub const FILESIZEBITS: u32 = 64;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const NGROUPS_MAX: u32 = 32;
pub const ARG_MAX: u32 = 131072;
pub const IOV_MAX: u32 = 1024;
pub const SYMLOOP_MAX: u32 = 40;
pub const WORD_BIT: u32 = 32;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const TZNAME_MAX: u32 = 6;
pub const TTY_NAME_MAX: u32 = 32;
pub const HOST_NAME_MAX: u32 = 255;
pub const LONG_BIT: u32 = 64;
pub const PTHREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_STACK_MIN: u32 = 2048;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const SEM_NSEMS_MAX: u32 = 256;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 4096;
pub const RE_DUP_MAX: u32 = 255;
pub const NL_ARGMAX: u32 = 9;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const NZERO: u32 = 20;
pub const NL_LANGMAX: u32 = 32;
pub const NL_NMAX: u32 = 16;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const __PDP_ENDIAN: u32 = 3412;
pub const BIG_ENDIAN: u32 = 4321;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const FD_SETSIZE: u32 = 1024;
pub const CLOCKS_PER_SEC: u32 = 1000000;
pub const TIME_UTC: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_SGI_CYCLE: u32 = 10;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const SIG_BLOCK: u32 = 0;
pub const SIG_UNBLOCK: u32 = 1;
pub const SIG_SETMASK: u32 = 2;
pub const SI_ASYNCNL: i32 = -60;
pub const SI_TKILL: i32 = -6;
pub const SI_SIGIO: i32 = -5;
pub const SI_ASYNCIO: i32 = -4;
pub const SI_MESGQ: i32 = -3;
pub const SI_TIMER: i32 = -2;
pub const SI_QUEUE: i32 = -1;
pub const SI_USER: u32 = 0;
pub const SI_KERNEL: u32 = 128;
pub const MINSIGSTKSZ: u32 = 6144;
pub const SIGSTKSZ: u32 = 12288;
pub const FPSIMD_MAGIC: u32 = 1179680769;
pub const ESR_MAGIC: u32 = 1163088385;
pub const EXTRA_MAGIC: u32 = 1163416577;
pub const SVE_MAGIC: u32 = 1398162689;
pub const SVE_VQ_BYTES: u32 = 16;
pub const SVE_VQ_MIN: u32 = 1;
pub const SVE_VQ_MAX: u32 = 512;
pub const SVE_VL_MIN: u32 = 16;
pub const SVE_VL_MAX: u32 = 8192;
pub const SVE_NUM_ZREGS: u32 = 32;
pub const SVE_NUM_PREGS: u32 = 16;
pub const SA_NOCLDSTOP: u32 = 1;
pub const SA_NOCLDWAIT: u32 = 2;
pub const SA_SIGINFO: u32 = 4;
pub const SA_ONSTACK: u32 = 134217728;
pub const SA_RESTART: u32 = 268435456;
pub const SA_NODEFER: u32 = 1073741824;
pub const SA_RESETHAND: u32 = 2147483648;
pub const SA_RESTORER: u32 = 67108864;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGBUS: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGUSR1: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGUSR2: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGSTKFLT: u32 = 16;
pub const SIGCHLD: u32 = 17;
pub const SIGCONT: u32 = 18;
pub const SIGSTOP: u32 = 19;
pub const SIGTSTP: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGURG: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGIO: u32 = 29;
pub const SIGPOLL: u32 = 29;
pub const SIGPWR: u32 = 30;
pub const SIGSYS: u32 = 31;
pub const SIGUNUSED: u32 = 31;
pub const _NSIG: u32 = 65;
pub const FPE_INTDIV: u32 = 1;
pub const FPE_INTOVF: u32 = 2;
pub const FPE_FLTDIV: u32 = 3;
pub const FPE_FLTOVF: u32 = 4;
pub const FPE_FLTUND: u32 = 5;
pub const FPE_FLTRES: u32 = 6;
pub const FPE_FLTINV: u32 = 7;
pub const FPE_FLTSUB: u32 = 8;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLOPN: u32 = 2;
pub const ILL_ILLADR: u32 = 3;
pub const ILL_ILLTRP: u32 = 4;
pub const ILL_PRVOPC: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const SEGV_BNDERR: u32 = 3;
pub const SEGV_PKUERR: u32 = 4;
pub const SEGV_MTEAERR: u32 = 8;
pub const SEGV_MTESERR: u32 = 9;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const BUS_MCEERR_AR: u32 = 4;
pub const BUS_MCEERR_AO: u32 = 5;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const SA_UNSUPPORTED: u32 = 1024;
pub const SA_EXPOSE_TAGBITS: u32 = 2048;
pub const SIGEV_SIGNAL: u32 = 0;
pub const SIGEV_NONE: u32 = 1;
pub const SIGEV_THREAD: u32 = 2;
pub const SIGEV_THREAD_ID: u32 = 4;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const TRAP_BRANCH: u32 = 3;
pub const TRAP_HWBKPT: u32 = 4;
pub const TRAP_UNK: u32 = 5;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 2;
pub const SS_AUTODISARM: u32 = 2147483648;
pub const SS_FLAG_BITS: u32 = 2147483648;
pub const NSIG: u32 = 65;
pub const SYS_SECCOMP: u32 = 1;
pub const SYS_USER_DISPATCH: u32 = 2;
pub const SA_NOMASK: u32 = 1073741824;
pub const SA_ONESHOT: u32 = 2147483648;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const ENOTSUP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST64_MAX: i32 = -1;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const INT_FAST16_MIN: i32 = -2147483648;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST16_MAX: u32 = 2147483647;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT_FAST16_MAX: u32 = 4294967295;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIZE_MAX: i32 = -1;
pub const __PRI64: &[u8; 2] = b"l\0";
pub const __PRIPTR: &[u8; 2] = b"l\0";
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 3] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2] = b"d\0";
pub const PRIdLEAST16: &[u8; 2] = b"d\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 3] = b"ld\0";
pub const PRIdFAST8: &[u8; 2] = b"d\0";
pub const PRIdFAST16: &[u8; 2] = b"d\0";
pub const PRIdFAST32: &[u8; 2] = b"d\0";
pub const PRIdFAST64: &[u8; 3] = b"ld\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 3] = b"li\0";
pub const PRIiLEAST8: &[u8; 2] = b"i\0";
pub const PRIiLEAST16: &[u8; 2] = b"i\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 3] = b"li\0";
pub const PRIiFAST8: &[u8; 2] = b"i\0";
pub const PRIiFAST16: &[u8; 2] = b"i\0";
pub const PRIiFAST32: &[u8; 2] = b"i\0";
pub const PRIiFAST64: &[u8; 3] = b"li\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 3] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2] = b"o\0";
pub const PRIoLEAST16: &[u8; 2] = b"o\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 3] = b"lo\0";
pub const PRIoFAST8: &[u8; 2] = b"o\0";
pub const PRIoFAST16: &[u8; 2] = b"o\0";
pub const PRIoFAST32: &[u8; 2] = b"o\0";
pub const PRIoFAST64: &[u8; 3] = b"lo\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 3] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2] = b"u\0";
pub const PRIuLEAST16: &[u8; 2] = b"u\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 3] = b"lu\0";
pub const PRIuFAST8: &[u8; 2] = b"u\0";
pub const PRIuFAST16: &[u8; 2] = b"u\0";
pub const PRIuFAST32: &[u8; 2] = b"u\0";
pub const PRIuFAST64: &[u8; 3] = b"lu\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 3] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2] = b"x\0";
pub const PRIxLEAST16: &[u8; 2] = b"x\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 3] = b"lx\0";
pub const PRIxFAST8: &[u8; 2] = b"x\0";
pub const PRIxFAST16: &[u8; 2] = b"x\0";
pub const PRIxFAST32: &[u8; 2] = b"x\0";
pub const PRIxFAST64: &[u8; 3] = b"lx\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 3] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2] = b"X\0";
pub const PRIXLEAST16: &[u8; 2] = b"X\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 3] = b"lX\0";
pub const PRIXFAST8: &[u8; 2] = b"X\0";
pub const PRIXFAST16: &[u8; 2] = b"X\0";
pub const PRIXFAST32: &[u8; 2] = b"X\0";
pub const PRIXFAST64: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"ld\0";
pub const PRIiMAX: &[u8; 3] = b"li\0";
pub const PRIoMAX: &[u8; 3] = b"lo\0";
pub const PRIuMAX: &[u8; 3] = b"lu\0";
pub const PRIxMAX: &[u8; 3] = b"lx\0";
pub const PRIXMAX: &[u8; 3] = b"lX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 3] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 3] = b"ld\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNdFAST16: &[u8; 2] = b"d\0";
pub const SCNdFAST32: &[u8; 2] = b"d\0";
pub const SCNdFAST64: &[u8; 3] = b"ld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 3] = b"li\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 3] = b"li\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNiFAST16: &[u8; 2] = b"i\0";
pub const SCNiFAST32: &[u8; 2] = b"i\0";
pub const SCNiFAST64: &[u8; 3] = b"li\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 3] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 3] = b"lu\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNuFAST16: &[u8; 2] = b"u\0";
pub const SCNuFAST32: &[u8; 2] = b"u\0";
pub const SCNuFAST64: &[u8; 3] = b"lu\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 3] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 3] = b"lo\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNoFAST16: &[u8; 2] = b"o\0";
pub const SCNoFAST32: &[u8; 2] = b"o\0";
pub const SCNoFAST64: &[u8; 3] = b"lo\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 3] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 3] = b"lx\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNxFAST16: &[u8; 2] = b"x\0";
pub const SCNxFAST32: &[u8; 2] = b"x\0";
pub const SCNxFAST64: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"ld\0";
pub const SCNiMAX: &[u8; 3] = b"li\0";
pub const SCNoMAX: &[u8; 3] = b"lo\0";
pub const SCNuMAX: &[u8; 3] = b"lu\0";
pub const SCNxMAX: &[u8; 3] = b"lx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const SEEK_DATA: u32 = 3;
pub const SEEK_HOLE: u32 = 4;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const POSIX_CLOSE_RESTART: u32 = 0;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX_ADVISORY_INFO: u32 = 200809;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 1;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_JOB_CONTROL: u32 = 1;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200809;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_SPAWN: u32 = 200809;
pub const _POSIX_VDISABLE: u32 = 0;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_CPUTIME: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 200809;
pub const _POSIX_CLOCK_SELECTION: u32 = 200809;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: u32 = 200809;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_SHARED_MEMORY_OBJECTS: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _PC_LINK_MAX: u32 = 0;
pub const _PC_MAX_CANON: u32 = 1;
pub const _PC_MAX_INPUT: u32 = 2;
pub const _PC_NAME_MAX: u32 = 3;
pub const _PC_PATH_MAX: u32 = 4;
pub const _PC_PIPE_BUF: u32 = 5;
pub const _PC_CHOWN_RESTRICTED: u32 = 6;
pub const _PC_NO_TRUNC: u32 = 7;
pub const _PC_VDISABLE: u32 = 8;
pub const _PC_SYNC_IO: u32 = 9;
pub const _PC_ASYNC_IO: u32 = 10;
pub const _PC_PRIO_IO: u32 = 11;
pub const _PC_SOCK_MAXBUF: u32 = 12;
pub const _PC_FILESIZEBITS: u32 = 13;
pub const _PC_REC_INCR_XFER_SIZE: u32 = 14;
pub const _PC_REC_MAX_XFER_SIZE: u32 = 15;
pub const _PC_REC_MIN_XFER_SIZE: u32 = 16;
pub const _PC_REC_XFER_ALIGN: u32 = 17;
pub const _PC_ALLOC_SIZE_MIN: u32 = 18;
pub const _PC_SYMLINK_MAX: u32 = 19;
pub const _PC_2_SYMLINKS: u32 = 20;
pub const _SC_ARG_MAX: u32 = 0;
pub const _SC_CHILD_MAX: u32 = 1;
pub const _SC_CLK_TCK: u32 = 2;
pub const _SC_NGROUPS_MAX: u32 = 3;
pub const _SC_OPEN_MAX: u32 = 4;
pub const _SC_STREAM_MAX: u32 = 5;
pub const _SC_TZNAME_MAX: u32 = 6;
pub const _SC_JOB_CONTROL: u32 = 7;
pub const _SC_SAVED_IDS: u32 = 8;
pub const _SC_REALTIME_SIGNALS: u32 = 9;
pub const _SC_PRIORITY_SCHEDULING: u32 = 10;
pub const _SC_TIMERS: u32 = 11;
pub const _SC_ASYNCHRONOUS_IO: u32 = 12;
pub const _SC_PRIORITIZED_IO: u32 = 13;
pub const _SC_SYNCHRONIZED_IO: u32 = 14;
pub const _SC_FSYNC: u32 = 15;
pub const _SC_MAPPED_FILES: u32 = 16;
pub const _SC_MEMLOCK: u32 = 17;
pub const _SC_MEMLOCK_RANGE: u32 = 18;
pub const _SC_MEMORY_PROTECTION: u32 = 19;
pub const _SC_MESSAGE_PASSING: u32 = 20;
pub const _SC_SEMAPHORES: u32 = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: u32 = 22;
pub const _SC_AIO_LISTIO_MAX: u32 = 23;
pub const _SC_AIO_MAX: u32 = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: u32 = 25;
pub const _SC_DELAYTIMER_MAX: u32 = 26;
pub const _SC_MQ_OPEN_MAX: u32 = 27;
pub const _SC_MQ_PRIO_MAX: u32 = 28;
pub const _SC_VERSION: u32 = 29;
pub const _SC_PAGE_SIZE: u32 = 30;
pub const _SC_PAGESIZE: u32 = 30;
pub const _SC_RTSIG_MAX: u32 = 31;
pub const _SC_SEM_NSEMS_MAX: u32 = 32;
pub const _SC_SEM_VALUE_MAX: u32 = 33;
pub const _SC_SIGQUEUE_MAX: u32 = 34;
pub const _SC_TIMER_MAX: u32 = 35;
pub const _SC_BC_BASE_MAX: u32 = 36;
pub const _SC_BC_DIM_MAX: u32 = 37;
pub const _SC_BC_SCALE_MAX: u32 = 38;
pub const _SC_BC_STRING_MAX: u32 = 39;
pub const _SC_COLL_WEIGHTS_MAX: u32 = 40;
pub const _SC_EXPR_NEST_MAX: u32 = 42;
pub const _SC_LINE_MAX: u32 = 43;
pub const _SC_RE_DUP_MAX: u32 = 44;
pub const _SC_2_VERSION: u32 = 46;
pub const _SC_2_C_BIND: u32 = 47;
pub const _SC_2_C_DEV: u32 = 48;
pub const _SC_2_FORT_DEV: u32 = 49;
pub const _SC_2_FORT_RUN: u32 = 50;
pub const _SC_2_SW_DEV: u32 = 51;
pub const _SC_2_LOCALEDEF: u32 = 52;
pub const _SC_UIO_MAXIOV: u32 = 60;
pub const _SC_IOV_MAX: u32 = 60;
pub const _SC_THREADS: u32 = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: u32 = 68;
pub const _SC_GETGR_R_SIZE_MAX: u32 = 69;
pub const _SC_GETPW_R_SIZE_MAX: u32 = 70;
pub const _SC_LOGIN_NAME_MAX: u32 = 71;
pub const _SC_TTY_NAME_MAX: u32 = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: u32 = 73;
pub const _SC_THREAD_KEYS_MAX: u32 = 74;
pub const _SC_THREAD_STACK_MIN: u32 = 75;
pub const _SC_THREAD_THREADS_MAX: u32 = 76;
pub const _SC_THREAD_ATTR_STACKADDR: u32 = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: u32 = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: u32 = 79;
pub const _SC_THREAD_PRIO_INHERIT: u32 = 80;
pub const _SC_THREAD_PRIO_PROTECT: u32 = 81;
pub const _SC_THREAD_PROCESS_SHARED: u32 = 82;
pub const _SC_NPROCESSORS_CONF: u32 = 83;
pub const _SC_NPROCESSORS_ONLN: u32 = 84;
pub const _SC_PHYS_PAGES: u32 = 85;
pub const _SC_AVPHYS_PAGES: u32 = 86;
pub const _SC_ATEXIT_MAX: u32 = 87;
pub const _SC_PASS_MAX: u32 = 88;
pub const _SC_XOPEN_VERSION: u32 = 89;
pub const _SC_XOPEN_XCU_VERSION: u32 = 90;
pub const _SC_XOPEN_UNIX: u32 = 91;
pub const _SC_XOPEN_CRYPT: u32 = 92;
pub const _SC_XOPEN_ENH_I18N: u32 = 93;
pub const _SC_XOPEN_SHM: u32 = 94;
pub const _SC_2_CHAR_TERM: u32 = 95;
pub const _SC_2_UPE: u32 = 97;
pub const _SC_XOPEN_XPG2: u32 = 98;
pub const _SC_XOPEN_XPG3: u32 = 99;
pub const _SC_XOPEN_XPG4: u32 = 100;
pub const _SC_NZERO: u32 = 109;
pub const _SC_XBS5_ILP32_OFF32: u32 = 125;
pub const _SC_XBS5_ILP32_OFFBIG: u32 = 126;
pub const _SC_XBS5_LP64_OFF64: u32 = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: u32 = 128;
pub const _SC_XOPEN_LEGACY: u32 = 129;
pub const _SC_XOPEN_REALTIME: u32 = 130;
pub const _SC_XOPEN_REALTIME_THREADS: u32 = 131;
pub const _SC_ADVISORY_INFO: u32 = 132;
pub const _SC_BARRIERS: u32 = 133;
pub const _SC_CLOCK_SELECTION: u32 = 137;
pub const _SC_CPUTIME: u32 = 138;
pub const _SC_THREAD_CPUTIME: u32 = 139;
pub const _SC_MONOTONIC_CLOCK: u32 = 149;
pub const _SC_READER_WRITER_LOCKS: u32 = 153;
pub const _SC_SPIN_LOCKS: u32 = 154;
pub const _SC_REGEXP: u32 = 155;
pub const _SC_SHELL: u32 = 157;
pub const _SC_SPAWN: u32 = 159;
pub const _SC_SPORADIC_SERVER: u32 = 160;
pub const _SC_THREAD_SPORADIC_SERVER: u32 = 161;
pub const _SC_TIMEOUTS: u32 = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: u32 = 165;
pub const _SC_2_PBS: u32 = 168;
pub const _SC_2_PBS_ACCOUNTING: u32 = 169;
pub const _SC_2_PBS_LOCATE: u32 = 170;
pub const _SC_2_PBS_MESSAGE: u32 = 171;
pub const _SC_2_PBS_TRACK: u32 = 172;
pub const _SC_SYMLOOP_MAX: u32 = 173;
pub const _SC_STREAMS: u32 = 174;
pub const _SC_2_PBS_CHECKPOINT: u32 = 175;
pub const _SC_V6_ILP32_OFF32: u32 = 176;
pub const _SC_V6_ILP32_OFFBIG: u32 = 177;
pub const _SC_V6_LP64_OFF64: u32 = 178;
pub const _SC_V6_LPBIG_OFFBIG: u32 = 179;
pub const _SC_HOST_NAME_MAX: u32 = 180;
pub const _SC_TRACE: u32 = 181;
pub const _SC_TRACE_EVENT_FILTER: u32 = 182;
pub const _SC_TRACE_INHERIT: u32 = 183;
pub const _SC_TRACE_LOG: u32 = 184;
pub const _SC_IPV6: u32 = 235;
pub const _SC_RAW_SOCKETS: u32 = 236;
pub const _SC_V7_ILP32_OFF32: u32 = 237;
pub const _SC_V7_ILP32_OFFBIG: u32 = 238;
pub const _SC_V7_LP64_OFF64: u32 = 239;
pub const _SC_V7_LPBIG_OFFBIG: u32 = 240;
pub const _SC_SS_REPL_MAX: u32 = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: u32 = 242;
pub const _SC_TRACE_NAME_MAX: u32 = 243;
pub const _SC_TRACE_SYS_MAX: u32 = 244;
pub const _SC_TRACE_USER_EVENT_MAX: u32 = 245;
pub const _SC_XOPEN_STREAMS: u32 = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: u32 = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: u32 = 248;
pub const _CS_PATH: u32 = 0;
pub const _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS: u32 = 1;
pub const _CS_GNU_LIBC_VERSION: u32 = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: u32 = 3;
pub const _CS_POSIX_V5_WIDTH_RESTRICTED_ENVS: u32 = 4;
pub const _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS: u32 = 5;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: u32 = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: u32 = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: u32 = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: u32 = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: u32 = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: u32 = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: u32 = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: u32 = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: u32 = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: u32 = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: u32 = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: u32 = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: u32 = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: u32 = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: u32 = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: u32 = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: u32 = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: u32 = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: u32 = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: u32 = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: u32 = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: u32 = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: u32 = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: u32 = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: u32 = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: u32 = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: u32 = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: u32 = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: u32 = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: u32 = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: u32 = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: u32 = 1147;
pub const _CS_V6_ENV: u32 = 1148;
pub const _CS_V7_ENV: u32 = 1149;
pub const SHUT_RD: u32 = 0;
pub const SHUT_WR: u32 = 1;
pub const SHUT_RDWR: u32 = 2;
pub const SOCK_STREAM: u32 = 1;
pub const SOCK_DGRAM: u32 = 2;
pub const SOCK_RAW: u32 = 3;
pub const SOCK_RDM: u32 = 4;
pub const SOCK_SEQPACKET: u32 = 5;
pub const SOCK_DCCP: u32 = 6;
pub const SOCK_PACKET: u32 = 10;
pub const SOCK_CLOEXEC: u32 = 524288;
pub const SOCK_NONBLOCK: u32 = 2048;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_FILE: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_AX25: u32 = 3;
pub const PF_IPX: u32 = 4;
pub const PF_APPLETALK: u32 = 5;
pub const PF_NETROM: u32 = 6;
pub const PF_BRIDGE: u32 = 7;
pub const PF_ATMPVC: u32 = 8;
pub const PF_X25: u32 = 9;
pub const PF_INET6: u32 = 10;
pub const PF_ROSE: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_NETBEUI: u32 = 13;
pub const PF_SECURITY: u32 = 14;
pub const PF_KEY: u32 = 15;
pub const PF_NETLINK: u32 = 16;
pub const PF_ROUTE: u32 = 16;
pub const PF_PACKET: u32 = 17;
pub const PF_ASH: u32 = 18;
pub const PF_ECONET: u32 = 19;
pub const PF_ATMSVC: u32 = 20;
pub const PF_RDS: u32 = 21;
pub const PF_SNA: u32 = 22;
pub const PF_IRDA: u32 = 23;
pub const PF_PPPOX: u32 = 24;
pub const PF_WANPIPE: u32 = 25;
pub const PF_LLC: u32 = 26;
pub const PF_IB: u32 = 27;
pub const PF_MPLS: u32 = 28;
pub const PF_CAN: u32 = 29;
pub const PF_TIPC: u32 = 30;
pub const PF_BLUETOOTH: u32 = 31;
pub const PF_IUCV: u32 = 32;
pub const PF_RXRPC: u32 = 33;
pub const PF_ISDN: u32 = 34;
pub const PF_PHONET: u32 = 35;
pub const PF_IEEE802154: u32 = 36;
pub const PF_CAIF: u32 = 37;
pub const PF_ALG: u32 = 38;
pub const PF_NFC: u32 = 39;
pub const PF_VSOCK: u32 = 40;
pub const PF_KCM: u32 = 41;
pub const PF_QIPCRTR: u32 = 42;
pub const PF_SMC: u32 = 43;
pub const PF_XDP: u32 = 44;
pub const PF_MAX: u32 = 45;
pub const AF_UNSPEC: u32 = 0;
pub const AF_LOCAL: u32 = 1;
pub const AF_UNIX: u32 = 1;
pub const AF_FILE: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_AX25: u32 = 3;
pub const AF_IPX: u32 = 4;
pub const AF_APPLETALK: u32 = 5;
pub const AF_NETROM: u32 = 6;
pub const AF_BRIDGE: u32 = 7;
pub const AF_ATMPVC: u32 = 8;
pub const AF_X25: u32 = 9;
pub const AF_INET6: u32 = 10;
pub const AF_ROSE: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_NETBEUI: u32 = 13;
pub const AF_SECURITY: u32 = 14;
pub const AF_KEY: u32 = 15;
pub const AF_NETLINK: u32 = 16;
pub const AF_ROUTE: u32 = 16;
pub const AF_PACKET: u32 = 17;
pub const AF_ASH: u32 = 18;
pub const AF_ECONET: u32 = 19;
pub const AF_ATMSVC: u32 = 20;
pub const AF_RDS: u32 = 21;
pub const AF_SNA: u32 = 22;
pub const AF_IRDA: u32 = 23;
pub const AF_PPPOX: u32 = 24;
pub const AF_WANPIPE: u32 = 25;
pub const AF_LLC: u32 = 26;
pub const AF_IB: u32 = 27;
pub const AF_MPLS: u32 = 28;
pub const AF_CAN: u32 = 29;
pub const AF_TIPC: u32 = 30;
pub const AF_BLUETOOTH: u32 = 31;
pub const AF_IUCV: u32 = 32;
pub const AF_RXRPC: u32 = 33;
pub const AF_ISDN: u32 = 34;
pub const AF_PHONET: u32 = 35;
pub const AF_IEEE802154: u32 = 36;
pub const AF_CAIF: u32 = 37;
pub const AF_ALG: u32 = 38;
pub const AF_NFC: u32 = 39;
pub const AF_VSOCK: u32 = 40;
pub const AF_KCM: u32 = 41;
pub const AF_QIPCRTR: u32 = 42;
pub const AF_SMC: u32 = 43;
pub const AF_XDP: u32 = 44;
pub const AF_MAX: u32 = 45;
pub const SO_DEBUG: u32 = 1;
pub const SO_REUSEADDR: u32 = 2;
pub const SO_TYPE: u32 = 3;
pub const SO_ERROR: u32 = 4;
pub const SO_DONTROUTE: u32 = 5;
pub const SO_BROADCAST: u32 = 6;
pub const SO_SNDBUF: u32 = 7;
pub const SO_RCVBUF: u32 = 8;
pub const SO_KEEPALIVE: u32 = 9;
pub const SO_OOBINLINE: u32 = 10;
pub const SO_NO_CHECK: u32 = 11;
pub const SO_PRIORITY: u32 = 12;
pub const SO_LINGER: u32 = 13;
pub const SO_BSDCOMPAT: u32 = 14;
pub const SO_REUSEPORT: u32 = 15;
pub const SO_PASSCRED: u32 = 16;
pub const SO_PEERCRED: u32 = 17;
pub const SO_RCVLOWAT: u32 = 18;
pub const SO_SNDLOWAT: u32 = 19;
pub const SO_ACCEPTCONN: u32 = 30;
pub const SO_PEERSEC: u32 = 31;
pub const SO_SNDBUFFORCE: u32 = 32;
pub const SO_RCVBUFFORCE: u32 = 33;
pub const SO_PROTOCOL: u32 = 38;
pub const SO_DOMAIN: u32 = 39;
pub const SO_RCVTIMEO: u32 = 20;
pub const SO_SNDTIMEO: u32 = 21;
pub const SO_TIMESTAMP: u32 = 29;
pub const SO_TIMESTAMPNS: u32 = 35;
pub const SO_TIMESTAMPING: u32 = 37;
pub const SO_SECURITY_AUTHENTICATION: u32 = 22;
pub const SO_SECURITY_ENCRYPTION_TRANSPORT: u32 = 23;
pub const SO_SECURITY_ENCRYPTION_NETWORK: u32 = 24;
pub const SO_BINDTODEVICE: u32 = 25;
pub const SO_ATTACH_FILTER: u32 = 26;
pub const SO_DETACH_FILTER: u32 = 27;
pub const SO_GET_FILTER: u32 = 26;
pub const SO_PEERNAME: u32 = 28;
pub const SCM_TIMESTAMP: u32 = 29;
pub const SO_PASSSEC: u32 = 34;
pub const SCM_TIMESTAMPNS: u32 = 35;
pub const SO_MARK: u32 = 36;
pub const SCM_TIMESTAMPING: u32 = 37;
pub const SO_RXQ_OVFL: u32 = 40;
pub const SO_WIFI_STATUS: u32 = 41;
pub const SCM_WIFI_STATUS: u32 = 41;
pub const SO_PEEK_OFF: u32 = 42;
pub const SO_NOFCS: u32 = 43;
pub const SO_LOCK_FILTER: u32 = 44;
pub const SO_SELECT_ERR_QUEUE: u32 = 45;
pub const SO_BUSY_POLL: u32 = 46;
pub const SO_MAX_PACING_RATE: u32 = 47;
pub const SO_BPF_EXTENSIONS: u32 = 48;
pub const SO_INCOMING_CPU: u32 = 49;
pub const SO_ATTACH_BPF: u32 = 50;
pub const SO_DETACH_BPF: u32 = 27;
pub const SO_ATTACH_REUSEPORT_CBPF: u32 = 51;
pub const SO_ATTACH_REUSEPORT_EBPF: u32 = 52;
pub const SO_CNX_ADVICE: u32 = 53;
pub const SCM_TIMESTAMPING_OPT_STATS: u32 = 54;
pub const SO_MEMINFO: u32 = 55;
pub const SO_INCOMING_NAPI_ID: u32 = 56;
pub const SO_COOKIE: u32 = 57;
pub const SCM_TIMESTAMPING_PKTINFO: u32 = 58;
pub const SO_PEERGROUPS: u32 = 59;
pub const SO_ZEROCOPY: u32 = 60;
pub const SO_TXTIME: u32 = 61;
pub const SCM_TXTIME: u32 = 61;
pub const SO_BINDTOIFINDEX: u32 = 62;
pub const SO_DETACH_REUSEPORT_BPF: u32 = 68;
pub const SO_PREFER_BUSY_POLL: u32 = 69;
pub const SO_BUSY_POLL_BUDGET: u32 = 70;
pub const SOL_SOCKET: u32 = 1;
pub const SOL_IP: u32 = 0;
pub const SOL_IPV6: u32 = 41;
pub const SOL_ICMPV6: u32 = 58;
pub const SOL_RAW: u32 = 255;
pub const SOL_DECNET: u32 = 261;
pub const SOL_X25: u32 = 262;
pub const SOL_PACKET: u32 = 263;
pub const SOL_ATM: u32 = 264;
pub const SOL_AAL: u32 = 265;
pub const SOL_IRDA: u32 = 266;
pub const SOL_NETBEUI: u32 = 267;
pub const SOL_LLC: u32 = 268;
pub const SOL_DCCP: u32 = 269;
pub const SOL_NETLINK: u32 = 270;
pub const SOL_TIPC: u32 = 271;
pub const SOL_RXRPC: u32 = 272;
pub const SOL_PPPOL2TP: u32 = 273;
pub const SOL_BLUETOOTH: u32 = 274;
pub const SOL_PNPIPE: u32 = 275;
pub const SOL_RDS: u32 = 276;
pub const SOL_IUCV: u32 = 277;
pub const SOL_CAIF: u32 = 278;
pub const SOL_ALG: u32 = 279;
pub const SOL_NFC: u32 = 280;
pub const SOL_KCM: u32 = 281;
pub const SOL_TLS: u32 = 282;
pub const SOL_XDP: u32 = 283;
pub const SOMAXCONN: u32 = 128;
pub const MSG_OOB: u32 = 1;
pub const MSG_PEEK: u32 = 2;
pub const MSG_DONTROUTE: u32 = 4;
pub const MSG_CTRUNC: u32 = 8;
pub const MSG_PROXY: u32 = 16;
pub const MSG_TRUNC: u32 = 32;
pub const MSG_DONTWAIT: u32 = 64;
pub const MSG_EOR: u32 = 128;
pub const MSG_WAITALL: u32 = 256;
pub const MSG_FIN: u32 = 512;
pub const MSG_SYN: u32 = 1024;
pub const MSG_CONFIRM: u32 = 2048;
pub const MSG_RST: u32 = 4096;
pub const MSG_ERRQUEUE: u32 = 8192;
pub const MSG_NOSIGNAL: u32 = 16384;
pub const MSG_MORE: u32 = 32768;
pub const MSG_WAITFORONE: u32 = 65536;
pub const MSG_BATCH: u32 = 262144;
pub const MSG_ZEROCOPY: u32 = 67108864;
pub const MSG_FASTOPEN: u32 = 536870912;
pub const MSG_CMSG_CLOEXEC: u32 = 1073741824;
pub const SCM_RIGHTS: u32 = 1;
pub const SCM_CREDENTIALS: u32 = 2;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const IPPORT_RESERVED: u32 = 1024;
pub const IPPROTO_IP: u32 = 0;
pub const IPPROTO_HOPOPTS: u32 = 0;
pub const IPPROTO_ICMP: u32 = 1;
pub const IPPROTO_IGMP: u32 = 2;
pub const IPPROTO_IPIP: u32 = 4;
pub const IPPROTO_TCP: u32 = 6;
pub const IPPROTO_EGP: u32 = 8;
pub const IPPROTO_PUP: u32 = 12;
pub const IPPROTO_UDP: u32 = 17;
pub const IPPROTO_IDP: u32 = 22;
pub const IPPROTO_TP: u32 = 29;
pub const IPPROTO_DCCP: u32 = 33;
pub const IPPROTO_IPV6: u32 = 41;
pub const IPPROTO_ROUTING: u32 = 43;
pub const IPPROTO_FRAGMENT: u32 = 44;
pub const IPPROTO_RSVP: u32 = 46;
pub const IPPROTO_GRE: u32 = 47;
pub const IPPROTO_ESP: u32 = 50;
pub const IPPROTO_AH: u32 = 51;
pub const IPPROTO_ICMPV6: u32 = 58;
pub const IPPROTO_NONE: u32 = 59;
pub const IPPROTO_DSTOPTS: u32 = 60;
pub const IPPROTO_MTP: u32 = 92;
pub const IPPROTO_BEETPH: u32 = 94;
pub const IPPROTO_ENCAP: u32 = 98;
pub const IPPROTO_PIM: u32 = 103;
pub const IPPROTO_COMP: u32 = 108;
pub const IPPROTO_SCTP: u32 = 132;
pub const IPPROTO_MH: u32 = 135;
pub const IPPROTO_UDPLITE: u32 = 136;
pub const IPPROTO_MPLS: u32 = 137;
pub const IPPROTO_ETHERNET: u32 = 143;
pub const IPPROTO_RAW: u32 = 255;
pub const IPPROTO_MPTCP: u32 = 262;
pub const IPPROTO_MAX: u32 = 263;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_LOOPBACKNET: u32 = 127;
pub const IP_TOS: u32 = 1;
pub const IP_TTL: u32 = 2;
pub const IP_HDRINCL: u32 = 3;
pub const IP_OPTIONS: u32 = 4;
pub const IP_ROUTER_ALERT: u32 = 5;
pub const IP_RECVOPTS: u32 = 6;
pub const IP_RETOPTS: u32 = 7;
pub const IP_PKTINFO: u32 = 8;
pub const IP_PKTOPTIONS: u32 = 9;
pub const IP_PMTUDISC: u32 = 10;
pub const IP_MTU_DISCOVER: u32 = 10;
pub const IP_RECVERR: u32 = 11;
pub const IP_RECVTTL: u32 = 12;
pub const IP_RECVTOS: u32 = 13;
pub const IP_MTU: u32 = 14;
pub const IP_FREEBIND: u32 = 15;
pub const IP_IPSEC_POLICY: u32 = 16;
pub const IP_XFRM_POLICY: u32 = 17;
pub const IP_PASSSEC: u32 = 18;
pub const IP_TRANSPARENT: u32 = 19;
pub const IP_ORIGDSTADDR: u32 = 20;
pub const IP_RECVORIGDSTADDR: u32 = 20;
pub const IP_MINTTL: u32 = 21;
pub const IP_NODEFRAG: u32 = 22;
pub const IP_CHECKSUM: u32 = 23;
pub const IP_BIND_ADDRESS_NO_PORT: u32 = 24;
pub const IP_RECVFRAGSIZE: u32 = 25;
pub const IP_RECVERR_RFC4884: u32 = 26;
pub const IP_MULTICAST_IF: u32 = 32;
pub const IP_MULTICAST_TTL: u32 = 33;
pub const IP_MULTICAST_LOOP: u32 = 34;
pub const IP_ADD_MEMBERSHIP: u32 = 35;
pub const IP_DROP_MEMBERSHIP: u32 = 36;
pub const IP_UNBLOCK_SOURCE: u32 = 37;
pub const IP_BLOCK_SOURCE: u32 = 38;
pub const IP_ADD_SOURCE_MEMBERSHIP: u32 = 39;
pub const IP_DROP_SOURCE_MEMBERSHIP: u32 = 40;
pub const IP_MSFILTER: u32 = 41;
pub const IP_MULTICAST_ALL: u32 = 49;
pub const IP_UNICAST_IF: u32 = 50;
pub const IP_RECVRETOPTS: u32 = 7;
pub const IP_PMTUDISC_DONT: u32 = 0;
pub const IP_PMTUDISC_WANT: u32 = 1;
pub const IP_PMTUDISC_DO: u32 = 2;
pub const IP_PMTUDISC_PROBE: u32 = 3;
pub const IP_PMTUDISC_INTERFACE: u32 = 4;
pub const IP_PMTUDISC_OMIT: u32 = 5;
pub const IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IP_MAX_MEMBERSHIPS: u32 = 20;
pub const MCAST_JOIN_GROUP: u32 = 42;
pub const MCAST_BLOCK_SOURCE: u32 = 43;
pub const MCAST_UNBLOCK_SOURCE: u32 = 44;
pub const MCAST_LEAVE_GROUP: u32 = 45;
pub const MCAST_JOIN_SOURCE_GROUP: u32 = 46;
pub const MCAST_LEAVE_SOURCE_GROUP: u32 = 47;
pub const MCAST_MSFILTER: u32 = 48;
pub const MCAST_EXCLUDE: u32 = 0;
pub const MCAST_INCLUDE: u32 = 1;
pub const IPV6_ADDRFORM: u32 = 1;
pub const IPV6_2292PKTINFO: u32 = 2;
pub const IPV6_2292HOPOPTS: u32 = 3;
pub const IPV6_2292DSTOPTS: u32 = 4;
pub const IPV6_2292RTHDR: u32 = 5;
pub const IPV6_2292PKTOPTIONS: u32 = 6;
pub const IPV6_CHECKSUM: u32 = 7;
pub const IPV6_2292HOPLIMIT: u32 = 8;
pub const IPV6_NEXTHOP: u32 = 9;
pub const IPV6_AUTHHDR: u32 = 10;
pub const IPV6_UNICAST_HOPS: u32 = 16;
pub const IPV6_MULTICAST_IF: u32 = 17;
pub const IPV6_MULTICAST_HOPS: u32 = 18;
pub const IPV6_MULTICAST_LOOP: u32 = 19;
pub const IPV6_JOIN_GROUP: u32 = 20;
pub const IPV6_LEAVE_GROUP: u32 = 21;
pub const IPV6_ROUTER_ALERT: u32 = 22;
pub const IPV6_MTU_DISCOVER: u32 = 23;
pub const IPV6_MTU: u32 = 24;
pub const IPV6_RECVERR: u32 = 25;
pub const IPV6_V6ONLY: u32 = 26;
pub const IPV6_JOIN_ANYCAST: u32 = 27;
pub const IPV6_LEAVE_ANYCAST: u32 = 28;
pub const IPV6_MULTICAST_ALL: u32 = 29;
pub const IPV6_ROUTER_ALERT_ISOLATE: u32 = 30;
pub const IPV6_IPSEC_POLICY: u32 = 34;
pub const IPV6_XFRM_POLICY: u32 = 35;
pub const IPV6_HDRINCL: u32 = 36;
pub const IPV6_RECVPKTINFO: u32 = 49;
pub const IPV6_PKTINFO: u32 = 50;
pub const IPV6_RECVHOPLIMIT: u32 = 51;
pub const IPV6_HOPLIMIT: u32 = 52;
pub const IPV6_RECVHOPOPTS: u32 = 53;
pub const IPV6_HOPOPTS: u32 = 54;
pub const IPV6_RTHDRDSTOPTS: u32 = 55;
pub const IPV6_RECVRTHDR: u32 = 56;
pub const IPV6_RTHDR: u32 = 57;
pub const IPV6_RECVDSTOPTS: u32 = 58;
pub const IPV6_DSTOPTS: u32 = 59;
pub const IPV6_RECVPATHMTU: u32 = 60;
pub const IPV6_PATHMTU: u32 = 61;
pub const IPV6_DONTFRAG: u32 = 62;
pub const IPV6_RECVTCLASS: u32 = 66;
pub const IPV6_TCLASS: u32 = 67;
pub const IPV6_AUTOFLOWLABEL: u32 = 70;
pub const IPV6_ADDR_PREFERENCES: u32 = 72;
pub const IPV6_MINHOPCOUNT: u32 = 73;
pub const IPV6_ORIGDSTADDR: u32 = 74;
pub const IPV6_RECVORIGDSTADDR: u32 = 74;
pub const IPV6_TRANSPARENT: u32 = 75;
pub const IPV6_UNICAST_IF: u32 = 76;
pub const IPV6_RECVFRAGSIZE: u32 = 77;
pub const IPV6_FREEBIND: u32 = 78;
pub const IPV6_ADD_MEMBERSHIP: u32 = 20;
pub const IPV6_DROP_MEMBERSHIP: u32 = 21;
pub const IPV6_RXHOPOPTS: u32 = 54;
pub const IPV6_RXDSTOPTS: u32 = 59;
pub const IPV6_PMTUDISC_DONT: u32 = 0;
pub const IPV6_PMTUDISC_WANT: u32 = 1;
pub const IPV6_PMTUDISC_DO: u32 = 2;
pub const IPV6_PMTUDISC_PROBE: u32 = 3;
pub const IPV6_PMTUDISC_INTERFACE: u32 = 4;
pub const IPV6_PMTUDISC_OMIT: u32 = 5;
pub const IPV6_PREFER_SRC_TMP: u32 = 1;
pub const IPV6_PREFER_SRC_PUBLIC: u32 = 2;
pub const IPV6_PREFER_SRC_PUBTMP_DEFAULT: u32 = 256;
pub const IPV6_PREFER_SRC_COA: u32 = 4;
pub const IPV6_PREFER_SRC_HOME: u32 = 1024;
pub const IPV6_PREFER_SRC_CGA: u32 = 8;
pub const IPV6_PREFER_SRC_NONCGA: u32 = 2048;
pub const IPV6_RTHDR_LOOSE: u32 = 0;
pub const IPV6_RTHDR_STRICT: u32 = 1;
pub const IPV6_RTHDR_TYPE_0: u32 = 0;
pub const __UAPI_DEF_IN_ADDR: u32 = 0;
pub const __UAPI_DEF_IN_IPPROTO: u32 = 0;
pub const __UAPI_DEF_IN_PKTINFO: u32 = 0;
pub const __UAPI_DEF_IP_MREQ: u32 = 0;
pub const __UAPI_DEF_SOCKADDR_IN: u32 = 0;
pub const __UAPI_DEF_IN_CLASS: u32 = 0;
pub const __UAPI_DEF_IN6_ADDR: u32 = 0;
pub const __UAPI_DEF_IN6_ADDR_ALT: u32 = 0;
pub const __UAPI_DEF_SOCKADDR_IN6: u32 = 0;
pub const __UAPI_DEF_IPV6_MREQ: u32 = 0;
pub const __UAPI_DEF_IPPROTO_V6: u32 = 0;
pub const __UAPI_DEF_IPV6_OPTIONS: u32 = 0;
pub const __UAPI_DEF_IN6_PKTINFO: u32 = 0;
pub const __UAPI_DEF_IP6_MTUINFO: u32 = 0;
pub const AI_PASSIVE: u32 = 1;
pub const AI_CANONNAME: u32 = 2;
pub const AI_NUMERICHOST: u32 = 4;
pub const AI_V4MAPPED: u32 = 8;
pub const AI_ALL: u32 = 16;
pub const AI_ADDRCONFIG: u32 = 32;
pub const AI_NUMERICSERV: u32 = 1024;
pub const NI_NUMERICHOST: u32 = 1;
pub const NI_NUMERICSERV: u32 = 2;
pub const NI_NOFQDN: u32 = 4;
pub const NI_NAMEREQD: u32 = 8;
pub const NI_DGRAM: u32 = 16;
pub const NI_NUMERICSCOPE: u32 = 256;
pub const EAI_BADFLAGS: i32 = -1;
pub const EAI_NONAME: i32 = -2;
pub const EAI_AGAIN: i32 = -3;
pub const EAI_FAIL: i32 = -4;
pub const EAI_FAMILY: i32 = -6;
pub const EAI_SOCKTYPE: i32 = -7;
pub const EAI_SERVICE: i32 = -8;
pub const EAI_MEMORY: i32 = -10;
pub const EAI_SYSTEM: i32 = -11;
pub const EAI_OVERFLOW: i32 = -12;
pub const HOST_NOT_FOUND: u32 = 1;
pub const TRY_AGAIN: u32 = 2;
pub const NO_RECOVERY: u32 = 3;
pub const NO_DATA: u32 = 4;
pub const NO_ADDRESS: u32 = 4;
pub const EAI_NODATA: i32 = -5;
pub const EAI_ADDRFAMILY: i32 = -9;
pub const EAI_INPROGRESS: i32 = -100;
pub const EAI_CANCELED: i32 = -101;
pub const EAI_NOTCANCELED: i32 = -102;
pub const EAI_ALLDONE: i32 = -103;
pub const EAI_INTR: i32 = -104;
pub const EAI_IDN_ENCODE: i32 = -105;
pub const NI_MAXHOST: u32 = 255;
pub const NI_MAXSERV: u32 = 32;
pub const O_BINARY: u32 = 0;
pub const TIME_T_FMT: &[u8; 3] = b"ld\0";
pub const FS_64BIT: u32 = 1;
pub const SWITCH_TIME_T_FMT: &[u8; 3] = b"ld\0";
pub const FALSE: u32 = 0;
pub const CJSON_VERSION_MAJOR: u32 = 1;
pub const CJSON_VERSION_MINOR: u32 = 7;
pub const CJSON_VERSION_PATCH: u32 = 12;
pub const cJSON_Invalid: u32 = 0;
pub const cJSON_False: u32 = 1;
pub const cJSON_True: u32 = 2;
pub const cJSON_NULL: u32 = 4;
pub const cJSON_Number: u32 = 8;
pub const cJSON_String: u32 = 16;
pub const cJSON_Array: u32 = 32;
pub const cJSON_Object: u32 = 64;
pub const cJSON_Raw: u32 = 128;
pub const cJSON_IsReference: u32 = 256;
pub const cJSON_StringIsConst: u32 = 512;
pub const CJSON_NESTING_LIMIT: u32 = 1000;
pub const VPX_IMAGE_ABI_VERSION: u32 = 4;
pub const VPX_IMG_FMT_PLANAR: u32 = 256;
pub const VPX_IMG_FMT_UV_FLIP: u32 = 512;
pub const VPX_IMG_FMT_HAS_ALPHA: u32 = 1024;
pub const VPX_IMG_FMT_HIGHBITDEPTH: u32 = 2048;
pub const VPX_PLANE_PACKED: u32 = 0;
pub const VPX_PLANE_Y: u32 = 0;
pub const VPX_PLANE_U: u32 = 1;
pub const VPX_PLANE_V: u32 = 2;
pub const VPX_PLANE_ALPHA: u32 = 3;
pub const SWITCH_IMG_FMT_PLANAR: u32 = 256;
pub const SWITCH_IMG_FMT_UV_FLIP: u32 = 512;
pub const SWITCH_IMG_FMT_HAS_ALPHA: u32 = 1024;
pub const SWITCH_PLANE_PACKED: u32 = 0;
pub const SWITCH_PLANE_Y: u32 = 0;
pub const SWITCH_PLANE_U: u32 = 1;
pub const SWITCH_PLANE_V: u32 = 2;
pub const SWITCH_PLANE_ALPHA: u32 = 3;
pub const VPX_IMG_FMT_HIGH: u32 = 2048;
pub const SWITCH_ENT_ORIGINATE_DELIM: &[u8; 4] = b":_:\0";
pub const SWITCH_BLANK_STRING: &[u8; 1] = b"\0";
pub const SWITCH_TON_UNDEF: u32 = 255;
pub const SWITCH_NUMPLAN_UNDEF: u32 = 255;
pub const SWITCH_SEQ_ESC: &[u8; 3] = b"\x1B[\0";
pub const SWITCH_SEQ_HOME_CHAR: u8 = 72u8;
pub const SWITCH_SEQ_HOME_CHAR_STR: &[u8; 2] = b"H\0";
pub const SWITCH_SEQ_CLEARLINE_CHAR: u8 = 49u8;
pub const SWITCH_SEQ_CLEARLINE_CHAR_STR: &[u8; 2] = b"1\0";
pub const SWITCH_SEQ_CLEARLINEEND_CHAR: &[u8; 2] = b"K\0";
pub const SWITCH_SEQ_CLEARSCR_CHAR0: u8 = 50u8;
pub const SWITCH_SEQ_CLEARSCR_CHAR1: u8 = 74u8;
pub const SWITCH_SEQ_CLEARSCR_CHAR: &[u8; 3] = b"2J\0";
pub const SWITCH_SEQ_AND_COLOR: &[u8; 2] = b";\0";
pub const SWITCH_SEQ_END_COLOR: &[u8; 2] = b"m\0";
pub const SWITCH_SEQ_F_BLACK: &[u8; 3] = b"30\0";
pub const SWITCH_SEQ_F_RED: &[u8; 3] = b"31\0";
pub const SWITCH_SEQ_F_GREEN: &[u8; 3] = b"32\0";
pub const SWITCH_SEQ_F_YELLOW: &[u8; 3] = b"33\0";
pub const SWITCH_SEQ_F_BLUE: &[u8; 3] = b"34\0";
pub const SWITCH_SEQ_F_MAGEN: &[u8; 3] = b"35\0";
pub const SWITCH_SEQ_F_CYAN: &[u8; 3] = b"36\0";
pub const SWITCH_SEQ_F_WHITE: &[u8; 3] = b"37\0";
pub const SWITCH_SEQ_B_BLACK: &[u8; 3] = b"40\0";
pub const SWITCH_SEQ_B_RED: &[u8; 3] = b"41\0";
pub const SWITCH_SEQ_B_GREEN: &[u8; 3] = b"42\0";
pub const SWITCH_SEQ_B_YELLOW: &[u8; 3] = b"43\0";
pub const SWITCH_SEQ_B_BLUE: &[u8; 3] = b"44\0";
pub const SWITCH_SEQ_B_MAGEN: &[u8; 3] = b"45\0";
pub const SWITCH_SEQ_B_CYAN: &[u8; 3] = b"46\0";
pub const SWITCH_SEQ_B_WHITE: &[u8; 3] = b"47\0";
pub const SWITCH_SEQ_FBLACK: &[u8; 6] = b"\x1B[30m\0";
pub const SWITCH_SEQ_FRED: &[u8; 6] = b"\x1B[31m\0";
pub const SWITCH_SEQ_FGREEN: &[u8; 6] = b"\x1B[32m\0";
pub const SWITCH_SEQ_FYELLOW: &[u8; 6] = b"\x1B[33m\0";
pub const SWITCH_SEQ_FBLUE: &[u8; 6] = b"\x1B[34m\0";
pub const SWITCH_SEQ_FMAGEN: &[u8; 6] = b"\x1B[35m\0";
pub const SWITCH_SEQ_FCYAN: &[u8; 6] = b"\x1B[36m\0";
pub const SWITCH_SEQ_FWHITE: &[u8; 6] = b"\x1B[37m\0";
pub const SWITCH_SEQ_BBLACK: &[u8; 6] = b"\x1B[40m\0";
pub const SWITCH_SEQ_BRED: &[u8; 6] = b"\x1B[41m\0";
pub const SWITCH_SEQ_BGREEN: &[u8; 6] = b"\x1B[42m\0";
pub const SWITCH_SEQ_BYELLOW: &[u8; 6] = b"\x1B[43m\0";
pub const SWITCH_SEQ_BBLUE: &[u8; 6] = b"\x1B[44m\0";
pub const SWITCH_SEQ_BMAGEN: &[u8; 6] = b"\x1B[45m\0";
pub const SWITCH_SEQ_BCYAN: &[u8; 6] = b"\x1B[46m\0";
pub const SWITCH_SEQ_BWHITE: &[u8; 6] = b"\x1B[47m\0";
pub const SWITCH_SEQ_HOME: &[u8; 4] = b"\x1B[H\0";
pub const SWITCH_SEQ_CLEARLINE: &[u8; 4] = b"\x1B[1\0";
pub const SWITCH_SEQ_CLEARLINEEND: &[u8; 4] = b"\x1B[K\0";
pub const SWITCH_SEQ_CLEARSCR: &[u8; 8] = b"\x1B[2J\x1B[H\0";
pub const SWITCH_DEFAULT_CLID_NAME: &[u8; 1] = b"\0";
pub const SWITCH_DEFAULT_CLID_NUMBER: &[u8; 11] = b"0000000000\0";
pub const SWITCH_DEFAULT_DTMF_DURATION: u32 = 2000;
pub const SWITCH_DEFAULT_TIMEOUT: u32 = 60;
pub const SWITCH_MIN_DTMF_DURATION: u32 = 400;
pub const SWITCH_MAX_DTMF_DURATION: u32 = 192000;
pub const SWITCH_PATH_SEPARATOR: &[u8; 2] = b"/\0";
pub const SWITCH_URL_SEPARATOR: &[u8; 4] = b"://\0";
pub const SWITCH_IGNORE_DISPLAY_UPDATES_VARIABLE: &[u8; 23] = b"ignore_display_updates\0";
pub const SWITCH_AUDIO_SPOOL_PATH_VARIABLE: &[u8; 17] = b"audio_spool_path\0";
pub const SWITCH_BRIDGE_HANGUP_CAUSE_VARIABLE: &[u8; 20] = b"bridge_hangup_cause\0";
pub const SWITCH_READ_TERMINATOR_USED_VARIABLE: &[u8; 21] = b"read_terminator_used\0";
pub const SWITCH_SEND_SILENCE_WHEN_IDLE_VARIABLE: &[u8; 23] = b"send_silence_when_idle\0";
pub const SWITCH_CURRENT_APPLICATION_VARIABLE: &[u8; 20] = b"current_application\0";
pub const SWITCH_CURRENT_APPLICATION_DATA_VARIABLE: &[u8; 25] = b"current_application_data\0";
pub const SWITCH_CURRENT_APPLICATION_RESPONSE_VARIABLE: &[u8; 29] =
    b"current_application_response\0";
pub const SWITCH_PASSTHRU_PTIME_MISMATCH_VARIABLE: &[u8; 24] = b"passthru_ptime_mismatch\0";
pub const SWITCH_ENABLE_HEARTBEAT_EVENTS_VARIABLE: &[u8; 24] = b"enable_heartbeat_events\0";
pub const SWITCH_BYPASS_MEDIA_AFTER_BRIDGE_VARIABLE: &[u8; 26] = b"bypass_media_after_bridge\0";
pub const SWITCH_READ_RESULT_VARIABLE: &[u8; 12] = b"read_result\0";
pub const SWITCH_ATT_XFER_RESULT_VARIABLE: &[u8; 16] = b"att_xfer_result\0";
pub const SWITCH_COPY_XML_CDR_VARIABLE: &[u8; 13] = b"copy_xml_cdr\0";
pub const SWITCH_COPY_JSON_CDR_VARIABLE: &[u8; 14] = b"copy_json_cdr\0";
pub const SWITCH_PROTO_SPECIFIC_HANGUP_CAUSE_VARIABLE: &[u8; 28] = b"proto_specific_hangup_cause\0";
pub const SWITCH_TRANSFER_HISTORY_VARIABLE: &[u8; 17] = b"transfer_history\0";
pub const SWITCH_TRANSFER_SOURCE_VARIABLE: &[u8; 16] = b"transfer_source\0";
pub const SWITCH_SENSITIVE_DTMF_VARIABLE: &[u8; 15] = b"sensitive_dtmf\0";
pub const SWITCH_RECORD_POST_PROCESS_EXEC_APP_VARIABLE: &[u8; 29] =
    b"record_post_process_exec_app\0";
pub const SWITCH_RECORD_POST_PROCESS_EXEC_API_VARIABLE: &[u8; 29] =
    b"record_post_process_exec_api\0";
pub const SWITCH_CHANNEL_EXECUTE_ON_ANSWER_VARIABLE: &[u8; 18] = b"execute_on_answer\0";
pub const SWITCH_CHANNEL_EXECUTE_ON_PRE_ANSWER_VARIABLE: &[u8; 22] = b"execute_on_pre_answer\0";
pub const SWITCH_CHANNEL_EXECUTE_ON_MEDIA_VARIABLE: &[u8; 17] = b"execute_on_media\0";
pub const SWITCH_CHANNEL_EXECUTE_ON_RING_VARIABLE: &[u8; 16] = b"execute_on_ring\0";
pub const SWITCH_CHANNEL_EXECUTE_ON_TONE_DETECT_VARIABLE: &[u8; 23] = b"execute_on_tone_detect\0";
pub const SWITCH_CHANNEL_EXECUTE_ON_ORIGINATE_VARIABLE: &[u8; 21] = b"execute_on_originate\0";
pub const SWITCH_CHANNEL_EXECUTE_ON_POST_ORIGINATE_VARIABLE: &[u8; 26] =
    b"execute_on_post_originate\0";
pub const SWITCH_CHANNEL_EXECUTE_ON_PRE_ORIGINATE_VARIABLE: &[u8; 25] =
    b"execute_on_pre_originate\0";
pub const SWITCH_CHANNEL_EXECUTE_ON_PRE_BRIDGE_VARIABLE: &[u8; 22] = b"execute_on_pre_bridge\0";
pub const SWITCH_CHANNEL_EXECUTE_ON_POST_BRIDGE_VARIABLE: &[u8; 23] = b"execute_on_post_bridge\0";
pub const SWITCH_CHANNEL_API_ON_ANSWER_VARIABLE: &[u8; 14] = b"api_on_answer\0";
pub const SWITCH_CHANNEL_API_ON_PRE_ANSWER_VARIABLE: &[u8; 18] = b"api_on_pre_answer\0";
pub const SWITCH_CHANNEL_API_ON_MEDIA_VARIABLE: &[u8; 13] = b"api_on_media\0";
pub const SWITCH_CHANNEL_API_ON_RING_VARIABLE: &[u8; 12] = b"api_on_ring\0";
pub const SWITCH_CHANNEL_API_ON_TONE_DETECT_VARIABLE: &[u8; 19] = b"api_on_tone_detect\0";
pub const SWITCH_CHANNEL_API_ON_ORIGINATE_VARIABLE: &[u8; 17] = b"api_on_originate\0";
pub const SWITCH_CHANNEL_API_ON_POST_ORIGINATE_VARIABLE: &[u8; 22] = b"api_on_post_originate\0";
pub const SWITCH_CHANNEL_API_ON_PRE_ORIGINATE_VARIABLE: &[u8; 21] = b"api_on_pre_originate\0";
pub const SWITCH_CALL_TIMEOUT_VARIABLE: &[u8; 13] = b"call_timeout\0";
pub const SWITCH_HOLDING_UUID_VARIABLE: &[u8; 13] = b"holding_uuid\0";
pub const SWITCH_SOFT_HOLDING_UUID_VARIABLE: &[u8; 18] = b"soft_holding_uuid\0";
pub const SWITCH_API_BRIDGE_END_VARIABLE: &[u8; 17] = b"api_after_bridge\0";
pub const SWITCH_API_BRIDGE_START_VARIABLE: &[u8; 18] = b"api_before_bridge\0";
pub const SWITCH_API_HANGUP_HOOK_VARIABLE: &[u8; 16] = b"api_hangup_hook\0";
pub const SWITCH_API_REPORTING_HOOK_VARIABLE: &[u8; 19] = b"api_reporting_hook\0";
pub const SWITCH_SESSION_IN_HANGUP_HOOK_VARIABLE: &[u8; 23] = b"session_in_hangup_hook\0";
pub const SWITCH_PROCESS_CDR_VARIABLE: &[u8; 12] = b"process_cdr\0";
pub const SWITCH_SKIP_CDR_CAUSES_VARIABLE: &[u8; 16] = b"skip_cdr_causes\0";
pub const SWITCH_FORCE_PROCESS_CDR_VARIABLE: &[u8; 18] = b"force_process_cdr\0";
pub const SWITCH_BRIDGE_CHANNEL_VARIABLE: &[u8; 15] = b"bridge_channel\0";
pub const SWITCH_CHANNEL_NAME_VARIABLE: &[u8; 13] = b"channel_name\0";
pub const SWITCH_BRIDGE_UUID_VARIABLE: &[u8; 12] = b"bridge_uuid\0";
pub const SWITCH_CONTINUE_ON_FAILURE_VARIABLE: &[u8; 17] = b"continue_on_fail\0";
pub const SWITCH_PLAYBACK_TERMINATORS_VARIABLE: &[u8; 21] = b"playback_terminators\0";
pub const SWITCH_PLAYBACK_TERMINATOR_USED: &[u8; 25] = b"playback_terminator_used\0";
pub const SWITCH_CACHE_SPEECH_HANDLES_VARIABLE: &[u8; 21] = b"cache_speech_handles\0";
pub const SWITCH_CACHE_SPEECH_HANDLES_OBJ_NAME: &[u8; 29] = b"__cache_speech_handles_obj__\0";
pub const SWITCH_BYPASS_MEDIA_VARIABLE: &[u8; 13] = b"bypass_media\0";
pub const SWITCH_PROXY_MEDIA_VARIABLE: &[u8; 12] = b"proxy_media\0";
pub const SWITCH_ENDPOINT_DISPOSITION_VARIABLE: &[u8; 21] = b"endpoint_disposition\0";
pub const SWITCH_HOLD_MUSIC_VARIABLE: &[u8; 11] = b"hold_music\0";
pub const SWITCH_TEMP_HOLD_MUSIC_VARIABLE: &[u8; 16] = b"temp_hold_music\0";
pub const SWITCH_EXPORT_VARS_VARIABLE: &[u8; 12] = b"export_vars\0";
pub const SWITCH_BRIDGE_EXPORT_VARS_VARIABLE: &[u8; 19] = b"bridge_export_vars\0";
pub const SWITCH_R_SDP_VARIABLE: &[u8; 13] = b"switch_r_sdp\0";
pub const SWITCH_L_SDP_VARIABLE: &[u8; 13] = b"switch_l_sdp\0";
pub const SWITCH_B_SDP_VARIABLE: &[u8; 13] = b"switch_m_sdp\0";
pub const SWITCH_BRIDGE_VARIABLE: &[u8; 10] = b"bridge_to\0";
pub const SWITCH_LAST_BRIDGE_VARIABLE: &[u8; 15] = b"last_bridge_to\0";
pub const SWITCH_SIGNAL_BRIDGE_VARIABLE: &[u8; 17] = b"signal_bridge_to\0";
pub const SWITCH_SIGNAL_BOND_VARIABLE: &[u8; 12] = b"signal_bond\0";
pub const SWITCH_ORIGINATE_SIGNAL_BOND_VARIABLE: &[u8; 22] = b"originate_signal_bond\0";
pub const SWITCH_ORIGINATOR_VARIABLE: &[u8; 11] = b"originator\0";
pub const SWITCH_ORIGINATOR_CODEC_VARIABLE: &[u8; 17] = b"originator_codec\0";
pub const SWITCH_ORIGINATOR_VIDEO_CODEC_VARIABLE: &[u8; 23] = b"originator_video_codec\0";
pub const SWITCH_LOCAL_MEDIA_IP_VARIABLE: &[u8; 15] = b"local_media_ip\0";
pub const SWITCH_LOCAL_MEDIA_PORT_VARIABLE: &[u8; 17] = b"local_media_port\0";
pub const SWITCH_ADVERTISED_MEDIA_IP_VARIABLE: &[u8; 20] = b"advertised_media_ip\0";
pub const SWITCH_REMOTE_MEDIA_IP_VARIABLE: &[u8; 16] = b"remote_media_ip\0";
pub const SWITCH_REMOTE_MEDIA_PORT_VARIABLE: &[u8; 18] = b"remote_media_port\0";
pub const SWITCH_REMOTE_VIDEO_IP_VARIABLE: &[u8; 16] = b"remote_video_ip\0";
pub const SWITCH_REMOTE_VIDEO_PORT_VARIABLE: &[u8; 18] = b"remote_video_port\0";
pub const SWITCH_LOCAL_VIDEO_IP_VARIABLE: &[u8; 15] = b"local_video_ip\0";
pub const SWITCH_LOCAL_VIDEO_PORT_VARIABLE: &[u8; 17] = b"local_video_port\0";
pub const SWITCH_LOCAL_TEXT_IP_VARIABLE: &[u8; 14] = b"local_text_ip\0";
pub const SWITCH_LOCAL_TEXT_PORT_VARIABLE: &[u8; 16] = b"local_text_port\0";
pub const SWITCH_HANGUP_AFTER_BRIDGE_VARIABLE: &[u8; 20] = b"hangup_after_bridge\0";
pub const SWITCH_PARK_AFTER_BRIDGE_VARIABLE: &[u8; 18] = b"park_after_bridge\0";
pub const SWITCH_PARK_AFTER_EARLY_BRIDGE_VARIABLE: &[u8; 24] = b"park_after_early_bridge\0";
pub const SWITCH_TRANSFER_AFTER_BRIDGE_VARIABLE: &[u8; 22] = b"transfer_after_bridge\0";
pub const SWITCH_TRANSFER_AFTER_EARLY_BRIDGE_VARIABLE: &[u8; 28] = b"transfer_after_early_bridge\0";
pub const SWITCH_EXEC_AFTER_BRIDGE_APP_VARIABLE: &[u8; 22] = b"exec_after_bridge_app\0";
pub const SWITCH_EXEC_AFTER_BRIDGE_ARG_VARIABLE: &[u8; 22] = b"exec_after_bridge_arg\0";
pub const SWITCH_MAX_FORWARDS_VARIABLE: &[u8; 13] = b"max_forwards\0";
pub const SWITCH_RFC7989_SESSION_ID_VARIABLE: &[u8; 13] = b"session_uuid\0";
pub const SWITCH_RFC7989_REMOTE_SESSION_ID_VARIABLE: &[u8; 20] = b"remote_session_uuid\0";
pub const SWITCH_RFC7989_APP_SESSION_ID_VARIABLE: &[u8; 17] = b"app_session_uuid\0";
pub const SWITCH_RFC7989_GENERIC_PARAM_VARIABLE: &[u8; 27] = b"generic_param_session_uuid\0";
pub const SWITCH_MAX_SESSION_TRANSFERS_VARIABLE: &[u8; 22] = b"max_session_transfers\0";
pub const SWITCH_DISABLE_APP_LOG_VARIABLE: &[u8; 16] = b"disable_app_log\0";
pub const SWITCH_SPEECH_KEY: &[u8; 7] = b"speech\0";
pub const SWITCH_UUID_BRIDGE: &[u8; 12] = b"uuid_bridge\0";
pub const SWITCH_BITS_PER_BYTE: u32 = 8;
pub const SWITCH_DEFAULT_FILE_BUFFER_LEN: u32 = 65536;
pub const SWITCH_DTMF_LOG_LEN: u32 = 1000;
pub const SWITCH_MAX_TRANS: u32 = 2000;
pub const SWITCH_CORE_SESSION_MAX_PRIVATES: u32 = 2;
pub const SWITCH_DEFAULT_VIDEO_SIZE: u32 = 1200;
pub const SWITCH_RTCP_AUDIO_INTERVAL_MSEC: &[u8; 5] = b"1000\0";
pub const SWITCH_RTCP_VIDEO_INTERVAL_MSEC: &[u8; 5] = b"1000\0";
pub const MAX_FMTP_LEN: u32 = 256;
pub const JITTER_VARIANCE_THRESHOLD: f64 = 400.0;
pub const IPDV_THRESHOLD: f64 = 1.0;
pub const LOST_BURST_ANALYZE: u32 = 500;
pub const LOST_BURST_CAPTURE: u32 = 1024;
pub const SWITCH_MAX_STACKS: u32 = 32;
pub const SWITCH_THREAD_STACKSIZE: u32 = 245760;
pub const SWITCH_SYSTEM_THREAD_STACKSIZE: u32 = 8388608;
pub const SWITCH_MAX_INTERVAL: u32 = 120;
pub const SWITCH_INTERVAL_PAD: u32 = 10;
pub const SWITCH_MAX_SAMPLE_LEN: u32 = 48;
pub const SWITCH_BYTES_PER_SAMPLE: u32 = 2;
pub const SWITCH_RECOMMENDED_BUFFER_SIZE: u32 = 8192;
pub const SWITCH_MAX_CODECS: u32 = 50;
pub const SWITCH_MAX_STATE_HANDLERS: u32 = 30;
pub const SWITCH_CORE_QUEUE_LEN: u32 = 100000;
pub const SWITCH_MAX_MANAGEMENT_BUFFER_LEN: u32 = 8192;
pub const SWITCH_RTP_CNG_PAYLOAD: u32 = 13;
pub const SWITCH_MEDIA_TYPE_TOTAL: u32 = 3;
pub const SWITCH_SOCK_INVALID: i32 = -1;
pub const DMACHINE_MAX_DIGIT_LEN: u32 = 512;
pub const MAX_ARG_RECURSION: u32 = 25;
pub const SWITCH_API_VERSION: u32 = 5;
pub const SWITCH_RTP_MAX_CRYPTO_LEN: u32 = 64;
pub const SWITCH_CRYPTO_MKI_INDEX: u32 = 0;
pub const SWITCH_CRYPTO_MKI_MAX: u32 = 20;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const SCHED_BATCH: u32 = 3;
pub const SCHED_IDLE: u32 = 5;
pub const SCHED_DEADLINE: u32 = 6;
pub const SCHED_RESET_ON_FORK: u32 = 1073741824;
pub const CSIGNAL: u32 = 255;
pub const CLONE_NEWTIME: u32 = 128;
pub const CLONE_VM: u32 = 256;
pub const CLONE_FS: u32 = 512;
pub const CLONE_FILES: u32 = 1024;
pub const CLONE_SIGHAND: u32 = 2048;
pub const CLONE_PIDFD: u32 = 4096;
pub const CLONE_PTRACE: u32 = 8192;
pub const CLONE_VFORK: u32 = 16384;
pub const CLONE_PARENT: u32 = 32768;
pub const CLONE_THREAD: u32 = 65536;
pub const CLONE_NEWNS: u32 = 131072;
pub const CLONE_SYSVSEM: u32 = 262144;
pub const CLONE_SETTLS: u32 = 524288;
pub const CLONE_PARENT_SETTID: u32 = 1048576;
pub const CLONE_CHILD_CLEARTID: u32 = 2097152;
pub const CLONE_DETACHED: u32 = 4194304;
pub const CLONE_UNTRACED: u32 = 8388608;
pub const CLONE_CHILD_SETTID: u32 = 16777216;
pub const CLONE_NEWCGROUP: u32 = 33554432;
pub const CLONE_NEWUTS: u32 = 67108864;
pub const CLONE_NEWIPC: u32 = 134217728;
pub const CLONE_NEWUSER: u32 = 268435456;
pub const CLONE_NEWPID: u32 = 536870912;
pub const CLONE_NEWNET: u32 = 1073741824;
pub const CLONE_IO: u32 = 2147483648;
pub const CPU_SETSIZE: u32 = 128;
pub const PTHREAD_CREATE_JOINABLE: u32 = 0;
pub const PTHREAD_CREATE_DETACHED: u32 = 1;
pub const PTHREAD_MUTEX_NORMAL: u32 = 0;
pub const PTHREAD_MUTEX_DEFAULT: u32 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: u32 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: u32 = 2;
pub const PTHREAD_MUTEX_STALLED: u32 = 0;
pub const PTHREAD_MUTEX_ROBUST: u32 = 1;
pub const PTHREAD_PRIO_NONE: u32 = 0;
pub const PTHREAD_PRIO_INHERIT: u32 = 1;
pub const PTHREAD_PRIO_PROTECT: u32 = 2;
pub const PTHREAD_INHERIT_SCHED: u32 = 0;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 1;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 0;
pub const PTHREAD_SCOPE_PROCESS: u32 = 1;
pub const PTHREAD_PROCESS_PRIVATE: u32 = 0;
pub const PTHREAD_PROCESS_SHARED: u32 = 1;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_CANCEL_ENABLE: u32 = 0;
pub const PTHREAD_CANCEL_DISABLE: u32 = 1;
pub const PTHREAD_CANCEL_MASKED: u32 = 2;
pub const PTHREAD_CANCEL_DEFERRED: u32 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: u32 = 1;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const SWITCH_MUTEX_DEFAULT: u32 = 0;
pub const SWITCH_MUTEX_NESTED: u32 = 1;
pub const SWITCH_MUTEX_UNNESTED: u32 = 2;
pub const SWITCH_UUID_FORMATTED_LENGTH: u32 = 256;
pub const SWITCH_MD5_DIGESTSIZE: u32 = 16;
pub const SWITCH_MD5_DIGEST_STRING_SIZE: u32 = 33;
pub const SWITCH_SEEK_SET: u32 = 0;
pub const SWITCH_SEEK_CUR: u32 = 1;
pub const SWITCH_SEEK_END: u32 = 2;
pub const SWITCH_FPROT_USETID: u32 = 32768;
pub const SWITCH_FPROT_UREAD: u32 = 1024;
pub const SWITCH_FPROT_UWRITE: u32 = 512;
pub const SWITCH_FPROT_UEXECUTE: u32 = 256;
pub const SWITCH_FPROT_GSETID: u32 = 16384;
pub const SWITCH_FPROT_GREAD: u32 = 64;
pub const SWITCH_FPROT_GWRITE: u32 = 32;
pub const SWITCH_FPROT_GEXECUTE: u32 = 16;
pub const SWITCH_FPROT_WSTICKY: u32 = 8192;
pub const SWITCH_FPROT_WREAD: u32 = 4;
pub const SWITCH_FPROT_WWRITE: u32 = 2;
pub const SWITCH_FPROT_WEXECUTE: u32 = 1;
pub const SWITCH_FPROT_OS_DEFAULT: u32 = 4095;
pub const SWITCH_FPROT_FILE_SOURCE_PERMS: u32 = 4096;
pub const SWITCH_FLOCK_SHARED: u32 = 1;
pub const SWITCH_FLOCK_EXCLUSIVE: u32 = 2;
pub const SWITCH_FLOCK_TYPEMASK: u32 = 15;
pub const SWITCH_FLOCK_NONBLOCK: u32 = 16;
pub const SWITCH_FOPEN_READ: u32 = 1;
pub const SWITCH_FOPEN_WRITE: u32 = 2;
pub const SWITCH_FOPEN_CREATE: u32 = 4;
pub const SWITCH_FOPEN_APPEND: u32 = 8;
pub const SWITCH_FOPEN_TRUNCATE: u32 = 16;
pub const SWITCH_FOPEN_BINARY: u32 = 32;
pub const SWITCH_FOPEN_EXCL: u32 = 64;
pub const SWITCH_FOPEN_BUFFERED: u32 = 128;
pub const SWITCH_FOPEN_DELONCLOSE: u32 = 256;
pub const SWITCH_FOPEN_XTHREAD: u32 = 512;
pub const SWITCH_FOPEN_SHARELOCK: u32 = 1024;
pub const SWITCH_FOPEN_NOCLEANUP: u32 = 2048;
pub const SWITCH_FOPEN_SENDFILE_ENABLED: u32 = 4096;
pub const SWITCH_FOPEN_LARGEFILE: u32 = 16384;
pub const SWITCH_SO_LINGER: u32 = 1;
pub const SWITCH_SO_KEEPALIVE: u32 = 2;
pub const SWITCH_SO_DEBUG: u32 = 4;
pub const SWITCH_SO_NONBLOCK: u32 = 8;
pub const SWITCH_SO_REUSEADDR: u32 = 16;
pub const SWITCH_SO_SNDBUF: u32 = 64;
pub const SWITCH_SO_RCVBUF: u32 = 128;
pub const SWITCH_SO_DISCONNECTED: u32 = 256;
pub const SWITCH_SO_TCP_NODELAY: u32 = 512;
pub const SWITCH_SO_TCP_KEEPIDLE: u32 = 520;
pub const SWITCH_SO_TCP_KEEPINTVL: u32 = 530;
pub const SWITCH_SO_IPV6_V6ONLY: u32 = 16384;
pub const SWITCH_INET: u32 = 2;
pub const SWITCH_INET6: u32 = 10;
pub const SWITCH_UNSPEC: u32 = 0;
pub const SWITCH_PROTO_TCP: u32 = 6;
pub const SWITCH_PROTO_UDP: u32 = 17;
pub const SWITCH_PROTO_SCTP: u32 = 132;
pub const SWITCH_POLLIN: u32 = 1;
pub const SWITCH_POLLPRI: u32 = 2;
pub const SWITCH_POLLOUT: u32 = 4;
pub const SWITCH_POLLERR: u32 = 16;
pub const SWITCH_POLLHUP: u32 = 32;
pub const SWITCH_POLLNVAL: u32 = 64;
pub const SWITCH_CORE_DB_OK: u32 = 0;
pub const SWITCH_CORE_DB_ERROR: u32 = 1;
pub const SWITCH_CORE_DB_INTERNAL: u32 = 2;
pub const SWITCH_CORE_DB_PERM: u32 = 3;
pub const SWITCH_CORE_DB_ABORT: u32 = 4;
pub const SWITCH_CORE_DB_BUSY: u32 = 5;
pub const SWITCH_CORE_DB_LOCKED: u32 = 6;
pub const SWITCH_CORE_DB_NOMEM: u32 = 7;
pub const SWITCH_CORE_DB_READONLY: u32 = 8;
pub const SWITCH_CORE_DB_INTERRUPT: u32 = 9;
pub const SWITCH_CORE_DB_IOERR: u32 = 10;
pub const SWITCH_CORE_DB_CORRUPT: u32 = 11;
pub const SWITCH_CORE_DB_NOTFOUND: u32 = 12;
pub const SWITCH_CORE_DB_FULL: u32 = 13;
pub const SWITCH_CORE_DB_CANTOPEN: u32 = 14;
pub const SWITCH_CORE_DB_PROTOCOL: u32 = 15;
pub const SWITCH_CORE_DB_EMPTY: u32 = 16;
pub const SWITCH_CORE_DB_SCHEMA: u32 = 17;
pub const SWITCH_CORE_DB_TOOBIG: u32 = 18;
pub const SWITCH_CORE_DB_CONSTRAINT: u32 = 19;
pub const SWITCH_CORE_DB_MISMATCH: u32 = 20;
pub const SWITCH_CORE_DB_MISUSE: u32 = 21;
pub const SWITCH_CORE_DB_NOLFS: u32 = 22;
pub const SWITCH_CORE_DB_AUTH: u32 = 23;
pub const SWITCH_CORE_DB_FORMAT: u32 = 24;
pub const SWITCH_CORE_DB_RANGE: u32 = 25;
pub const SWITCH_CORE_DB_NOTADB: u32 = 26;
pub const SWITCH_CORE_DB_ROW: u32 = 100;
pub const SWITCH_CORE_DB_DONE: u32 = 101;
pub const SWITCH_MAX_CORE_THREAD_SESSION_OBJS: u32 = 128;
pub const SWITCH_MAX_STREAMS: u32 = 128;
pub const DTLS_SRTP_FNAME: &[u8; 10] = b"dtls-srtp\0";
pub const MAX_FPLEN: u32 = 64;
pub const MAX_FPSTRLEN: u32 = 192;
pub const MESSAGE_STRING_ARG_MAX: u32 = 10;
pub const CACHE_DB_LEN: u32 = 256;
pub const SWITCH_GRANULAR_VOLUME_MAX: u32 = 50;
pub const SWITCH_RESAMPLE_QUALITY: u32 = 2;
pub const SWITCH_CMD_CHUNK_LEN: u32 = 1024;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 2;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_NAN: u32 = 0;
pub const FP_INFINITE: u32 = 1;
pub const FP_ZERO: u32 = 2;
pub const FP_SUBNORMAL: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const SWITCH_URL_UNSAFE: &[u8; 24] = b"\r\n #%&+:;<=>?@[\\]^`{|}\"\0";
pub const MAX_NETWORK_PORTS: u32 = 10;
pub const SWITCH_SMAX: u32 = 32767;
pub const SWITCH_SMIN: i32 = -32768;
pub const MAX_REPORT_BLOCKS: u32 = 5;
pub const NO_EVENT_CHANNEL_ID: u32 = 0;
pub const SWITCH_EVENT_CHANNEL_GLOBAL: &[u8; 11] = b"__global__\0";
pub const CHROMAKEY_MAX_MASK: u32 = 25;
pub const SWITCH_RTP_MAX_BUF_LEN: u32 = 16384;
pub const SWITCH_RTCP_MAX_BUF_LEN: u32 = 16384;
pub const SWITCH_RTP_MAX_BUF_LEN_WORDS: u32 = 4094;
pub const SWITCH_RTP_CRYPTO_KEY_80: &[u8; 24] = b"AES_CM_128_HMAC_SHA1_80\0";
pub const SWITCH_RTP_BUNDLE_INTERNAL_PT: u32 = 21;
pub const MAX_CAND: u32 = 50;
pub const MAX_CAND_IDX_COUNT: u32 = 2;
pub const SWITCH_XML_BUFSIZE: u32 = 1024;
pub const DEFAULT_ODBC_RETRIES: u32 = 120;
pub const LIMIT_IGNORE_TRANSFER_VARIABLE: &[u8; 22] = b"limit_ignore_transfer\0";
pub const LIMIT_BACKEND_VARIABLE: &[u8; 14] = b"limit_backend\0";
pub const LIMIT_EVENT_USAGE: &[u8; 13] = b"limit::usage\0";
pub const LIMIT_DEF_XFER_EXTEN: &[u8; 15] = b"limit_exceeded\0";
pub const SWITCH_MAX_CAND_ACL: u32 = 25;
pub const SWITCH_NO_CRYPTO_TAG: i32 = -1;
pub const TELETONE_MAX_DTMF_DIGITS: u32 = 128;
pub const TELETONE_MAX_TONES: u32 = 18;
pub const TELETONE_TONE_RANGE: u32 = 127;
pub const TELETONE_VOL_DB_MAX: u32 = 0;
pub const TELETONE_VOL_DB_MIN: i32 = -63;
pub const MAX_PHASE_TONES: u32 = 4;
pub const SINE_TABLE_MAX: u32 = 128;
pub const SINE_TABLE_LEN: u32 = 127;
pub const MAX_PHASE_ACCUMULATOR: u64 = 4294967296;
pub const DBM0_MAX_POWER: f64 = 6.16;
pub const DTMF_NORMAL_TWIST: f64 = 6.3;
pub const DTMF_REVERSE_TWIST: f64 = 2.5;
pub const DTMF_RELATIVE_PEAK_ROW: f64 = 6.3;
pub const DTMF_RELATIVE_PEAK_COL: f64 = 6.3;
pub const DTMF_2ND_HARMONIC_ROW: f64 = 2.5;
pub const DTMF_2ND_HARMONIC_COL: f64 = 63.1;
pub const GRID_FACTOR: u32 = 4;
pub const BLOCK_LEN: u32 = 102;
pub const M_TWO_PI: f64 = 6.283185307179586;
pub type wchar_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtof(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoll(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn malloc(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        arg1: ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn aligned_alloc(
        arg1: ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn quick_exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsearch(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
        arg4: usize,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        arg1: *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: usize,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn mblen(arg1: *const ::std::os::raw::c_char, arg2: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn posix_memalign(
        arg1: *mut *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemp(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn alloca(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemps(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemps(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn valloc(arg1: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memalign(
        arg1: ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn getloadavg(arg1: *mut f64, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn reallocarray(
        arg1: *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort_r(
        arg1: *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: usize,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg5: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn ptsname_r(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ecvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn secure_getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    _unused: [u8; 0],
}
extern "C" {
    pub fn strtof_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *mut __locale_struct,
    ) -> f32;
}
extern "C" {
    pub fn strtod_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *mut __locale_struct,
    ) -> f64;
}
extern "C" {
    pub fn strtold_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *mut __locale_struct,
    ) -> u128;
}
pub type off_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    _unused: [u8; 0],
}
pub type FILE = _IO_FILE;
pub type va_list = [u64; 4usize];
pub type __isoc_va_list = [u64; 4usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub union _G_fpos64_t {
    pub __opaque: [::std::os::raw::c_char; 16usize],
    pub __lldata: ::std::os::raw::c_longlong,
    pub __align: f64,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__opaque)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lldata) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__lldata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type fpos_t = _G_fpos64_t;
extern "C" {
    pub static stdin: *mut FILE;
}
extern "C" {
    pub static stdout: *mut FILE;
}
extern "C" {
    pub static stderr: *mut FILE;
}
extern "C" {
    pub fn fopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_ulong,
        arg3: ::std::os::raw::c_ulong,
        arg4: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_ulong,
        arg3: ::std::os::raw::c_ulong,
        arg4: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: [u64; 4usize],
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: [u64; 4usize],
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: [u64; 4usize],
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
        arg3: *const ::std::os::raw::c_char,
        arg4: [u64; 4usize],
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: [u64; 4usize],
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: [u64; 4usize],
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: [u64; 4usize],
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        arg1: *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(arg1: *mut *mut ::std::os::raw::c_char, arg2: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseeko(
        arg1: *mut FILE,
        arg2: off_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: __isoc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut usize,
        arg3: ::std::os::raw::c_int,
        arg4: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn getline(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut usize,
        arg3: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cuserid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE);
}
extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char, arg3: usize);
}
extern "C" {
    pub fn fgetc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        arg1: *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: usize,
        arg4: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        arg1: *const ::std::os::raw::c_void,
        arg2: usize,
        arg3: usize,
        arg4: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __isoc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets_unlocked(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fputs_unlocked(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
pub type cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> isize,
>;
pub type cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> isize,
>;
pub type cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut off_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type cookie_close_function_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
#[test]
fn bindgen_test_layout__IO_cookie_io_functions_t() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_cookie_io_functions_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_cookie_io_functions_t>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_cookie_io_functions_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(close)
        )
    );
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
extern "C" {
    pub fn fopencookie(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: cookie_io_functions_t,
    ) -> *mut FILE;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __ll: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __ld: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ll) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__ll)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ld) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__ld)
        )
    );
}
extern "C" {
    pub fn __assert_fail(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    );
}
pub type __jmp_buf = [::std::os::raw::c_ulong; 22usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    pub __jb: __jmp_buf,
    pub __fl: ::std::os::raw::c_ulong,
    pub __ss: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___jmp_buf_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__jmp_buf_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__jmp_buf_tag>(),
        312usize,
        concat!("Size of: ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__jb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__jb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fl) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__fl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__ss)
        )
    );
}
pub type jmp_buf = [__jmp_buf_tag; 1usize];
pub type sigjmp_buf = jmp_buf;
extern "C" {
    pub fn sigsetjmp(
        arg1: *mut __jmp_buf_tag,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siglongjmp(arg1: *mut __jmp_buf_tag, arg2: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _setjmp(arg1: *mut __jmp_buf_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _longjmp(arg1: *mut __jmp_buf_tag, arg2: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn setjmp(arg1: *mut __jmp_buf_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn longjmp(arg1: *mut __jmp_buf_tag, arg2: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn isalnum(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type locale_t = *mut __locale_struct;
extern "C" {
    pub fn isalnum_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isascii(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toascii(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type mode_t = ::std::os::raw::c_uint;
pub type pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    const UNINIT: ::std::mem::MaybeUninit<iovec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flock {
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
    pub l_start: off_t,
    pub l_len: off_t,
    pub l_pid: pid_t,
}
#[test]
fn bindgen_test_layout_flock() {
    const UNINIT: ::std::mem::MaybeUninit<flock> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<flock>(),
        32usize,
        concat!("Size of: ", stringify!(flock))
    );
    assert_eq!(
        ::std::mem::align_of::<flock>(),
        8usize,
        concat!("Alignment of ", stringify!(flock))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_whence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_whence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_pid) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_pid)
        )
    );
}
extern "C" {
    pub fn creat(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcntl(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn open(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn openat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_fadvise(
        arg1: ::std::os::raw::c_int,
        arg2: off_t,
        arg3: off_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_fallocate(
        arg1: ::std::os::raw::c_int,
        arg2: off_t,
        arg3: off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lockf(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: off_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug)]
pub struct file_handle {
    pub handle_bytes: ::std::os::raw::c_uint,
    pub handle_type: ::std::os::raw::c_int,
    pub f_handle: __IncompleteArrayField<::std::os::raw::c_uchar>,
}
#[test]
fn bindgen_test_layout_file_handle() {
    const UNINIT: ::std::mem::MaybeUninit<file_handle> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<file_handle>(),
        8usize,
        concat!("Size of: ", stringify!(file_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<file_handle>(),
        4usize,
        concat!("Alignment of ", stringify!(file_handle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle_bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_handle),
            "::",
            stringify!(handle_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle_type) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(file_handle),
            "::",
            stringify!(handle_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_handle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_handle),
            "::",
            stringify!(f_handle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct f_owner_ex {
    pub type_: ::std::os::raw::c_int,
    pub pid: pid_t,
}
#[test]
fn bindgen_test_layout_f_owner_ex() {
    const UNINIT: ::std::mem::MaybeUninit<f_owner_ex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<f_owner_ex>(),
        8usize,
        concat!("Size of: ", stringify!(f_owner_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<f_owner_ex>(),
        4usize,
        concat!("Alignment of ", stringify!(f_owner_ex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(f_owner_ex),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(f_owner_ex),
            "::",
            stringify!(pid)
        )
    );
}
extern "C" {
    pub fn fallocate(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: off_t,
        arg4: off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn name_to_handle_at(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut file_handle,
        arg4: *mut ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn open_by_handle_at(
        arg1: ::std::os::raw::c_int,
        arg2: *mut file_handle,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readahead(arg1: ::std::os::raw::c_int, arg2: off_t, arg3: usize) -> isize;
}
extern "C" {
    pub fn sync_file_range(
        arg1: ::std::os::raw::c_int,
        arg2: off_t,
        arg3: off_t,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vmsplice(
        arg1: ::std::os::raw::c_int,
        arg2: *const iovec,
        arg3: usize,
        arg4: ::std::os::raw::c_uint,
    ) -> isize;
}
extern "C" {
    pub fn splice(
        arg1: ::std::os::raw::c_int,
        arg2: *mut off_t,
        arg3: ::std::os::raw::c_int,
        arg4: *mut off_t,
        arg5: usize,
        arg6: ::std::os::raw::c_uint,
    ) -> isize;
}
extern "C" {
    pub fn tee(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: ::std::os::raw::c_uint,
    ) -> isize;
}
extern "C" {
    pub fn memcpy(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strchr(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strerror(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    );
}
extern "C" {
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtok_r(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stpcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(arg1: *const ::std::os::raw::c_char, arg2: usize) -> usize;
}
extern "C" {
    pub fn strdup(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcoll_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn memccpy(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strsep(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strlcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn explicit_bzero(arg1: *mut ::std::os::raw::c_void, arg2: usize);
}
extern "C" {
    pub fn strverscmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strchrnul(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcasestr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memmem(
        arg1: *const ::std::os::raw::c_void,
        arg2: usize,
        arg3: *const ::std::os::raw::c_void,
        arg4: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memrchr(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mempcpy(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn basename() -> *mut ::std::os::raw::c_char;
}
pub type blksize_t = ::std::os::raw::c_int;
pub type nlink_t = ::std::os::raw::c_uint;
pub type time_t = ::std::os::raw::c_long;
pub type ino_t = ::std::os::raw::c_ulong;
pub type dev_t = ::std::os::raw::c_ulong;
pub type blkcnt_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type uid_t = ::std::os::raw::c_uint;
pub type gid_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: dev_t,
    pub st_ino: ino_t,
    pub st_mode: mode_t,
    pub st_nlink: nlink_t,
    pub st_uid: uid_t,
    pub st_gid: gid_t,
    pub st_rdev: dev_t,
    pub __pad: ::std::os::raw::c_ulong,
    pub st_size: off_t,
    pub st_blksize: blksize_t,
    pub __pad2: ::std::os::raw::c_int,
    pub st_blocks: blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __unused: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout_stat() {
    const UNINIT: ::std::mem::MaybeUninit<stat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<stat>(),
        128usize,
        concat!("Size of: ", stringify!(stat))
    );
    assert_eq!(
        ::std::mem::align_of::<stat>(),
        8usize,
        concat!("Alignment of ", stringify!(stat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_dev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ino) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_nlink) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_uid) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_gid) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_rdev) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_size) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_blksize) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_blocks) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_atim) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_atim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mtim) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mtim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ctim) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ctim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__unused) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__unused)
        )
    );
}
extern "C" {
    pub fn stat(arg1: *const ::std::os::raw::c_char, arg2: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstat(arg1: ::std::os::raw::c_int, arg2: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lstat(arg1: *const ::std::os::raw::c_char, arg2: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstatat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut stat,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chmod(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchmod(arg1: ::std::os::raw::c_int, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchmodat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: mode_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn umask(arg1: mode_t) -> mode_t;
}
extern "C" {
    pub fn mkdir(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifo(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdirat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifoat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mknod(
        arg1: *const ::std::os::raw::c_char,
        arg2: mode_t,
        arg3: dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mknodat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: mode_t,
        arg4: dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimens(arg1: ::std::os::raw::c_int, arg2: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimensat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const timespec,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchmod(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
pub type register_t = ::std::os::raw::c_long;
pub type suseconds_t = ::std::os::raw::c_long;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type fsblkcnt_t = ::std::os::raw::c_ulong;
pub type fsfilcnt_t = ::std::os::raw::c_ulong;
pub type timer_t = *mut ::std::os::raw::c_void;
pub type clockid_t = ::std::os::raw::c_int;
pub type clock_t = ::std::os::raw::c_long;
pub type id_t = ::std::os::raw::c_uint;
pub type key_t = ::std::os::raw::c_int;
pub type useconds_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread {
    _unused: [u8; 0],
}
pub type pthread_t = *mut __pthread;
pub type pthread_once_t = ::std::os::raw::c_int;
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutexattr_t {
    pub __attr: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__attr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__attr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_condattr_t {
    pub __attr: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__attr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__attr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrierattr_t {
    pub __attr: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__attr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__attr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlockattr_t {
    pub __attr: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__attr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__attr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_attr_t {
    pub __u: pthread_attr_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t__bindgen_ty_1 {
    pub __i: [::std::os::raw::c_int; 14usize],
    pub __vi: [::std::os::raw::c_int; 14usize],
    pub __s: [::std::os::raw::c_ulong; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t__bindgen_ty_1>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t__bindgen_ty_1),
            "::",
            stringify!(__i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__vi) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t__bindgen_ty_1),
            "::",
            stringify!(__vi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t__bindgen_ty_1),
            "::",
            stringify!(__s)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__u)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_mutex_t {
    pub __u: pthread_mutex_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t__bindgen_ty_1 {
    pub __i: [::std::os::raw::c_int; 10usize],
    pub __vi: [::std::os::raw::c_int; 10usize],
    pub __p: [*mut ::std::os::raw::c_void; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t__bindgen_ty_1),
            "::",
            stringify!(__i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__vi) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t__bindgen_ty_1),
            "::",
            stringify!(__vi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t__bindgen_ty_1),
            "::",
            stringify!(__p)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__u)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_cond_t {
    pub __u: pthread_cond_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t__bindgen_ty_1 {
    pub __i: [::std::os::raw::c_int; 12usize],
    pub __vi: [::std::os::raw::c_int; 12usize],
    pub __p: [*mut ::std::os::raw::c_void; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__vi) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__vi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__p)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__u)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_rwlock_t {
    pub __u: pthread_rwlock_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t__bindgen_ty_1 {
    pub __i: [::std::os::raw::c_int; 14usize],
    pub __vi: [::std::os::raw::c_int; 14usize],
    pub __p: [*mut ::std::os::raw::c_void; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t__bindgen_ty_1>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__vi) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__vi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__p)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__u)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_barrier_t {
    pub __u: pthread_barrier_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t__bindgen_ty_1 {
    pub __i: [::std::os::raw::c_int; 8usize],
    pub __vi: [::std::os::raw::c_int; 8usize],
    pub __p: [*mut ::std::os::raw::c_void; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t__bindgen_ty_1),
            "::",
            stringify!(__i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__vi) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t__bindgen_ty_1),
            "::",
            stringify!(__vi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t__bindgen_ty_1),
            "::",
            stringify!(__p)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__u)
        )
    );
}
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type ushort = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type uint = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ulong = ::std::os::raw::c_ulong;
pub type quad_t = ::std::os::raw::c_longlong;
pub type u_quad_t = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__bits)
        )
    );
}
pub type sigset_t = __sigset_t;
pub type fd_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
extern "C" {
    pub fn select(
        arg1: ::std::os::raw::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        arg1: ::std::os::raw::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *const timespec,
        arg6: *const sigset_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(arg1: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
extern "C" {
    pub fn mktime(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn asctime(arg1: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(arg1: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn timespec_get(arg1: *mut timespec, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strftime_l(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const tm,
        arg5: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime_r(
        arg1: *const tm,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        arg1: *const time_t,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tzset();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    const UNINIT: ::std::mem::MaybeUninit<itimerspec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
extern "C" {
    pub fn nanosleep(arg1: *const timespec, arg2: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(arg1: clockid_t, arg2: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(arg1: clockid_t, arg2: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(arg1: clockid_t, arg2: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        arg1: clockid_t,
        arg2: ::std::os::raw::c_int,
        arg3: *const timespec,
        arg4: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(arg1: pid_t, arg2: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        arg1: clockid_t,
        arg2: *mut sigevent,
        arg3: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(arg1: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        arg1: timer_t,
        arg2: ::std::os::raw::c_int,
        arg3: *const itimerspec,
        arg4: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(arg1: timer_t, arg2: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(arg1: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn strptime(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdate(arg1: *const ::std::os::raw::c_char) -> *mut tm;
}
extern "C" {
    pub fn stime(arg1: *const time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timegm(arg1: *mut tm) -> time_t;
}
pub type stack_t = sigaltstack;
pub type greg_t = ::std::os::raw::c_ulong;
pub type gregset_t = [::std::os::raw::c_ulong; 34usize];
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct fpregset_t {
    pub vregs: [__uint128_t; 32usize],
    pub fpsr: ::std::os::raw::c_uint,
    pub fpcr: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_fpregset_t() {
    const UNINIT: ::std::mem::MaybeUninit<fpregset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fpregset_t>(),
        528usize,
        concat!("Size of: ", stringify!(fpregset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<fpregset_t>(),
        16usize,
        concat!("Alignment of ", stringify!(fpregset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vregs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregset_t),
            "::",
            stringify!(vregs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fpsr) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregset_t),
            "::",
            stringify!(fpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fpcr) as usize - ptr as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregset_t),
            "::",
            stringify!(fpcr)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct sigcontext {
    pub fault_address: ::std::os::raw::c_ulong,
    pub regs: [::std::os::raw::c_ulong; 31usize],
    pub sp: ::std::os::raw::c_ulong,
    pub pc: ::std::os::raw::c_ulong,
    pub pstate: ::std::os::raw::c_ulong,
    pub __bindgen_padding_0: u64,
    pub __reserved: [u128; 256usize],
}
#[test]
fn bindgen_test_layout_sigcontext() {
    const UNINIT: ::std::mem::MaybeUninit<sigcontext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigcontext>(),
        4384usize,
        concat!("Size of: ", stringify!(sigcontext))
    );
    assert_eq!(
        ::std::mem::align_of::<sigcontext>(),
        16usize,
        concat!("Alignment of ", stringify!(sigcontext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fault_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(fault_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).regs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(regs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sp) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pc) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(pc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pstate) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(pstate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__reserved) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(__reserved)
        )
    );
}
pub type mcontext_t = sigcontext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _aarch64_ctx {
    pub magic: ::std::os::raw::c_uint,
    pub size: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__aarch64_ctx() {
    const UNINIT: ::std::mem::MaybeUninit<_aarch64_ctx> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_aarch64_ctx>(),
        8usize,
        concat!("Size of: ", stringify!(_aarch64_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<_aarch64_ctx>(),
        4usize,
        concat!("Alignment of ", stringify!(_aarch64_ctx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_aarch64_ctx),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_aarch64_ctx),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct fpsimd_context {
    pub head: _aarch64_ctx,
    pub fpsr: ::std::os::raw::c_uint,
    pub fpcr: ::std::os::raw::c_uint,
    pub vregs: [__uint128_t; 32usize],
}
#[test]
fn bindgen_test_layout_fpsimd_context() {
    const UNINIT: ::std::mem::MaybeUninit<fpsimd_context> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fpsimd_context>(),
        528usize,
        concat!("Size of: ", stringify!(fpsimd_context))
    );
    assert_eq!(
        ::std::mem::align_of::<fpsimd_context>(),
        16usize,
        concat!("Alignment of ", stringify!(fpsimd_context))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpsimd_context),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fpsr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fpsimd_context),
            "::",
            stringify!(fpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fpcr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(fpsimd_context),
            "::",
            stringify!(fpcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vregs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fpsimd_context),
            "::",
            stringify!(vregs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esr_context {
    pub head: _aarch64_ctx,
    pub esr: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_esr_context() {
    const UNINIT: ::std::mem::MaybeUninit<esr_context> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<esr_context>(),
        16usize,
        concat!("Size of: ", stringify!(esr_context))
    );
    assert_eq!(
        ::std::mem::align_of::<esr_context>(),
        8usize,
        concat!("Alignment of ", stringify!(esr_context))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(esr_context),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).esr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(esr_context),
            "::",
            stringify!(esr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct extra_context {
    pub head: _aarch64_ctx,
    pub datap: ::std::os::raw::c_ulong,
    pub size: ::std::os::raw::c_uint,
    pub __reserved: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_extra_context() {
    const UNINIT: ::std::mem::MaybeUninit<extra_context> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<extra_context>(),
        32usize,
        concat!("Size of: ", stringify!(extra_context))
    );
    assert_eq!(
        ::std::mem::align_of::<extra_context>(),
        8usize,
        concat!("Alignment of ", stringify!(extra_context))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(extra_context),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).datap) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(extra_context),
            "::",
            stringify!(datap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(extra_context),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__reserved) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(extra_context),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sve_context {
    pub head: _aarch64_ctx,
    pub vl: ::std::os::raw::c_ushort,
    pub __reserved: [::std::os::raw::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout_sve_context() {
    const UNINIT: ::std::mem::MaybeUninit<sve_context> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sve_context>(),
        16usize,
        concat!("Size of: ", stringify!(sve_context))
    );
    assert_eq!(
        ::std::mem::align_of::<sve_context>(),
        4usize,
        concat!("Alignment of ", stringify!(sve_context))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sve_context),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vl) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sve_context),
            "::",
            stringify!(vl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__reserved) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(sve_context),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_flags: ::std::os::raw::c_int,
    pub ss_size: usize,
}
#[test]
fn bindgen_test_layout_sigaltstack() {
    const UNINIT: ::std::mem::MaybeUninit<sigaltstack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaltstack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaltstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaltstack),
            "::",
            stringify!(ss_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaltstack),
            "::",
            stringify!(ss_size)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct ucontext {
    pub uc_flags: ::std::os::raw::c_ulong,
    pub uc_link: *mut ucontext,
    pub uc_stack: stack_t,
    pub uc_sigmask: sigset_t,
    pub __bindgen_padding_0: u64,
    pub uc_mcontext: mcontext_t,
}
#[test]
fn bindgen_test_layout_ucontext() {
    const UNINIT: ::std::mem::MaybeUninit<ucontext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucontext>(),
        4560usize,
        concat!("Size of: ", stringify!(ucontext))
    );
    assert_eq!(
        ::std::mem::align_of::<ucontext>(),
        16usize,
        concat!("Alignment of ", stringify!(ucontext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(uc_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_link) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_stack) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_sigmask) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_mcontext) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(uc_mcontext)
        )
    );
}
pub type ucontext_t = ucontext;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sigval() {
    const UNINIT: ::std::mem::MaybeUninit<sigval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub __si_fields: siginfo_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1 {
    pub __pad: [::std::os::raw::c_char; 112usize],
    pub __si_common: siginfo_t__bindgen_ty_1__bindgen_ty_1,
    pub __sigfault: siginfo_t__bindgen_ty_1__bindgen_ty_2,
    pub __sigpoll: siginfo_t__bindgen_ty_1__bindgen_ty_3,
    pub __sigsys: siginfo_t__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 {
    pub __first: siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub __second: siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __piduid: siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub __timer: siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub si_pid: pid_t,
    pub si_uid: uid_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_pid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_uid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_uid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub si_timerid: ::std::os::raw::c_int,
    pub si_overrun: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<
        siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_timerid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_timerid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_overrun) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_overrun)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__piduid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__piduid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__timer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__timer)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub si_value: sigval,
    pub __sigchld: siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub si_status: ::std::os::raw::c_int,
    pub si_utime: clock_t,
    pub si_stime: clock_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_utime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(si_utime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_stime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(si_stime)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sigchld) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(__sigchld)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<siginfo_t__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__second) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__second)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_addr_lsb: ::std::os::raw::c_short,
    pub __first: siginfo_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub __addr_bnd: siginfo_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub si_pkey: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub si_lower: *mut ::std::os::raw::c_void,
    pub si_upper: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        siginfo_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_lower) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_lower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_upper) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_upper)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<siginfo_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__addr_bnd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__addr_bnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_pkey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(si_pkey)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<siginfo_t__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_addr_lsb) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_addr_lsb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__first) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(__first)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    pub si_band: ::std::os::raw::c_long,
    pub si_fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<siginfo_t__bindgen_ty_1__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_band) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_fd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 {
    pub si_call_addr: *mut ::std::os::raw::c_void,
    pub si_syscall: ::std::os::raw::c_int,
    pub si_arch: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<siginfo_t__bindgen_ty_1__bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_call_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_call_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_syscall) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_syscall)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_arch) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_arch)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<siginfo_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1>(),
        112usize,
        concat!("Size of: ", stringify!(siginfo_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(__pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__si_common) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(__si_common)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sigfault) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(__sigfault)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sigpoll) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(__sigpoll)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sigsys) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(__sigsys)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t() {
    const UNINIT: ::std::mem::MaybeUninit<siginfo_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t>(),
        128usize,
        concat!("Size of: ", stringify!(siginfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_signo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_errno) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__si_fields) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(__si_fields)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sa_handler: sigaction__bindgen_ty_1,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
    pub sa_restorer: ::std::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction__bindgen_ty_1 {
    pub sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut siginfo_t,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout_sigaction__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<sigaction__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigaction__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(sa_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_sigaction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(sa_sigaction)
        )
    );
}
#[test]
fn bindgen_test_layout_sigaction() {
    const UNINIT: ::std::mem::MaybeUninit<sigaction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        152usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sa_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sa_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_restorer) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_restorer)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_value: sigval,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_notify: ::std::os::raw::c_int,
    pub __sev_fields: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 {
    pub __pad: [::std::os::raw::c_char; 48usize],
    pub sigev_notify_thread_id: pid_t,
    pub __sev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<sigevent__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify_function) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(sigev_notify_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify_attributes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(sigev_notify_attributes)
        )
    );
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<sigevent__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(__pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify_thread_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(sigev_notify_thread_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sev_thread) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(__sev_thread)
        )
    );
}
#[test]
fn bindgen_test_layout_sigevent() {
    const UNINIT: ::std::mem::MaybeUninit<sigevent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        64usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_signo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sev_fields) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(__sev_fields)
        )
    );
}
extern "C" {
    pub fn __libc_current_sigrtmin() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmax() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kill(arg1: pid_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigemptyset(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigfillset(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaddset(arg1: *mut sigset_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigdelset(arg1: *mut sigset_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigismember(arg1: *const sigset_t, arg2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigprocmask(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsuspend(arg1: *const sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaction(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigaction,
        arg3: *mut sigaction,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpending(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwait(
        arg1: *const sigset_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwaitinfo(arg1: *const sigset_t, arg2: *mut siginfo_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigtimedwait(
        arg1: *const sigset_t,
        arg2: *mut siginfo_t,
        arg3: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigqueue(
        arg1: pid_t,
        arg2: ::std::os::raw::c_int,
        arg3: sigval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_sigmask(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_kill(arg1: pthread_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psiginfo(arg1: *const siginfo_t, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn psignal(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn killpg(arg1: pid_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaltstack(arg1: *const stack_t, arg2: *mut stack_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sighold(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigignore(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siginterrupt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpause(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigrelse(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigset(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type sighandler_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
extern "C" {
    pub fn bsd_signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
extern "C" {
    pub fn sigisemptyset(arg1: *const sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigorset(
        arg1: *mut sigset_t,
        arg2: *const sigset_t,
        arg3: *const sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigandset(
        arg1: *mut sigset_t,
        arg2: *const sigset_t,
        arg3: *const sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type sig_atomic_t = ::std::os::raw::c_int;
extern "C" {
    pub fn signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
extern "C" {
    pub fn raise(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub static mut program_invocation_short_name: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut program_invocation_name: *mut ::std::os::raw::c_char;
}
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = i8;
pub type int_fast64_t = i64;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast64_t = u64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast16_t = i32;
pub type int_fast32_t = i32;
pub type uint_fast16_t = u32;
pub type uint_fast32_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<imaxdiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(arg1: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(arg1: intmax_t, arg2: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn pipe(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pipe2(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn close(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_close(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup2(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup3(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek(arg1: ::std::os::raw::c_int, arg2: off_t, arg3: ::std::os::raw::c_int) -> off_t;
}
extern "C" {
    pub fn fsync(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdatasync(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn read(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    ) -> isize;
}
extern "C" {
    pub fn write(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
    ) -> isize;
}
extern "C" {
    pub fn pread(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
        arg4: off_t,
    ) -> isize;
}
extern "C" {
    pub fn pwrite(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
        arg4: off_t,
    ) -> isize;
}
extern "C" {
    pub fn chown(
        arg1: *const ::std::os::raw::c_char,
        arg2: uid_t,
        arg3: gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchown(arg1: ::std::os::raw::c_int, arg2: uid_t, arg3: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchown(
        arg1: *const ::std::os::raw::c_char,
        arg2: uid_t,
        arg3: gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchownat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: uid_t,
        arg4: gid_t,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn link(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn linkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symlink(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symlinkat(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlink(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> isize;
}
extern "C" {
    pub fn readlinkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: usize,
    ) -> isize;
}
extern "C" {
    pub fn unlink(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlinkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmdir(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn truncate(arg1: *const ::std::os::raw::c_char, arg2: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftruncate(arg1: ::std::os::raw::c_int, arg2: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn access(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faccessat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chdir(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchdir(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getcwd(arg1: *mut ::std::os::raw::c_char, arg2: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn alarm(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sleep(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fork() -> pid_t;
}
extern "C" {
    pub fn _Fork() -> pid_t;
}
extern "C" {
    pub fn execve(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execv(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execle(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execl(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execlp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fexecve(
        arg1: ::std::os::raw::c_int,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getpid() -> pid_t;
}
extern "C" {
    pub fn getppid() -> pid_t;
}
extern "C" {
    pub fn getpgrp() -> pid_t;
}
extern "C" {
    pub fn getpgid(arg1: pid_t) -> pid_t;
}
extern "C" {
    pub fn setpgid(arg1: pid_t, arg2: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsid() -> pid_t;
}
extern "C" {
    pub fn getsid(arg1: pid_t) -> pid_t;
}
extern "C" {
    pub fn ttyname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ttyname_r(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isatty(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcgetpgrp(arg1: ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn tcsetpgrp(arg1: ::std::os::raw::c_int, arg2: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getuid() -> uid_t;
}
extern "C" {
    pub fn geteuid() -> uid_t;
}
extern "C" {
    pub fn getgid() -> gid_t;
}
extern "C" {
    pub fn getegid() -> gid_t;
}
extern "C" {
    pub fn getgroups(arg1: ::std::os::raw::c_int, arg2: *mut gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setuid(arg1: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seteuid(arg1: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgid(arg1: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setegid(arg1: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getlogin_r(arg1: *mut ::std::os::raw::c_char, arg2: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostname(arg1: *mut ::std::os::raw::c_char, arg2: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getopt(
        arg1: ::std::os::raw::c_int,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut optind: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut opterr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optopt: ::std::os::raw::c_int;
}
extern "C" {
    pub fn pathconf(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fpathconf(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sysconf(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn confstr(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> usize;
}
extern "C" {
    pub fn setreuid(arg1: uid_t, arg2: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setregid(arg1: gid_t, arg2: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nice(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn setpgrp() -> pid_t;
}
extern "C" {
    pub fn crypt(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn encrypt(arg1: *mut ::std::os::raw::c_char, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn swab(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: isize,
    );
}
extern "C" {
    pub fn usleep(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ualarm(
        arg1: ::std::os::raw::c_uint,
        arg2: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn brk(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sbrk(arg1: isize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vhangup() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chroot(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostname(arg1: *const ::std::os::raw::c_char, arg2: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdomainname(arg1: *mut ::std::os::raw::c_char, arg2: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setdomainname(arg1: *const ::std::os::raw::c_char, arg2: usize)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgroups(arg1: usize, arg2: *const gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpass(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn daemon(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn acct(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn syscall(arg1: ::std::os::raw::c_long, ...) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn execvpe(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn issetugid() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getentropy(arg1: *mut ::std::os::raw::c_void, arg2: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optreset: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut environ: *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setresuid(arg1: uid_t, arg2: uid_t, arg3: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setresgid(arg1: gid_t, arg2: gid_t, arg3: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getresuid(arg1: *mut uid_t, arg2: *mut uid_t, arg3: *mut uid_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getresgid(arg1: *mut gid_t, arg2: *mut gid_t, arg3: *mut gid_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_current_dir_name() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn syncfs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn euidaccess(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eaccess(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn copy_file_range(
        arg1: ::std::os::raw::c_int,
        arg2: *mut off_t,
        arg3: ::std::os::raw::c_int,
        arg4: *mut off_t,
        arg5: usize,
        arg6: ::std::os::raw::c_uint,
    ) -> isize;
}
extern "C" {
    pub fn gettid() -> pid_t;
}
pub type socklen_t = ::std::os::raw::c_uint;
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: ::std::os::raw::c_int,
    pub __pad1: ::std::os::raw::c_int,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: socklen_t,
    pub __pad2: ::std::os::raw::c_int,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    const UNINIT: ::std::mem::MaybeUninit<msghdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<msghdr>(),
        56usize,
        concat!("Size of: ", stringify!(msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_namelen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_namelen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_iov) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iov)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_iovlen) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iovlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_control) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_controllen) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_controllen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmsghdr {
    pub cmsg_len: socklen_t,
    pub __pad1: ::std::os::raw::c_int,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    const UNINIT: ::std::mem::MaybeUninit<cmsghdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cmsghdr>(),
        16usize,
        concat!("Size of: ", stringify!(cmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmsghdr>(),
        4usize,
        concat!("Alignment of ", stringify!(cmsghdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_level) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_type) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucred {
    pub pid: pid_t,
    pub uid: uid_t,
    pub gid: gid_t,
}
#[test]
fn bindgen_test_layout_ucred() {
    const UNINIT: ::std::mem::MaybeUninit<ucred> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucred>(),
        12usize,
        concat!("Size of: ", stringify!(ucred))
    );
    assert_eq!(
        ::std::mem::align_of::<ucred>(),
        4usize,
        concat!("Alignment of ", stringify!(ucred))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucred),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ucred),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucred),
            "::",
            stringify!(gid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmsghdr {
    pub msg_hdr: msghdr,
    pub msg_len: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_mmsghdr() {
    const UNINIT: ::std::mem::MaybeUninit<mmsghdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mmsghdr>(),
        64usize,
        concat!("Size of: ", stringify!(mmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<mmsghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(mmsghdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mmsghdr),
            "::",
            stringify!(msg_hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_len) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mmsghdr),
            "::",
            stringify!(msg_len)
        )
    );
}
extern "C" {
    pub fn sendmmsg(
        arg1: ::std::os::raw::c_int,
        arg2: *mut mmsghdr,
        arg3: ::std::os::raw::c_uint,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn recvmmsg(
        arg1: ::std::os::raw::c_int,
        arg2: *mut mmsghdr,
        arg3: ::std::os::raw::c_uint,
        arg4: ::std::os::raw::c_uint,
        arg5: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    const UNINIT: ::std::mem::MaybeUninit<linger> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<linger>(),
        8usize,
        concat!("Size of: ", stringify!(linger))
    );
    assert_eq!(
        ::std::mem::align_of::<linger>(),
        4usize,
        concat!("Alignment of ", stringify!(linger))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_onoff) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_onoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_linger) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_linger)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_data) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::std::os::raw::c_char; 118usize],
    pub __ss_align: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_storage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss_padding) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss_align) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_align)
        )
    );
}
extern "C" {
    pub fn socket(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socketpair(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shutdown(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bind(
        arg1: ::std::os::raw::c_int,
        arg2: *const sockaddr,
        arg3: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn connect(
        arg1: ::std::os::raw::c_int,
        arg2: *const sockaddr,
        arg3: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn listen(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn accept(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn accept4(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockname(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeername(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn send(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn recv(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn sendto(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
        arg5: *const sockaddr,
        arg6: socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn recvfrom(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
        arg5: *mut sockaddr,
        arg6: *mut socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn sendmsg(
        arg1: ::std::os::raw::c_int,
        arg2: *const msghdr,
        arg3: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn recvmsg(
        arg1: ::std::os::raw::c_int,
        arg2: *mut msghdr,
        arg3: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn getsockopt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsockopt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_void,
        arg5: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sockatmark(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type in_port_t = u16;
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    const UNINIT: ::std::mem::MaybeUninit<in_addr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr),
            "::",
            stringify!(s_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_in> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_port) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_addr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_zero) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_zero)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_union: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __s6_addr: [u8; 16usize],
    pub __s6_addr16: [u16; 8usize],
    pub __s6_addr32: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<in6_addr__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__s6_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__s6_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__s6_addr16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__s6_addr16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__s6_addr32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__s6_addr32)
        )
    );
}
#[test]
fn bindgen_test_layout_in6_addr() {
    const UNINIT: ::std::mem::MaybeUninit<in6_addr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__in6_union) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr),
            "::",
            stringify!(__in6_union)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_in6> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in6>(),
        28usize,
        concat!("Size of: ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in6>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_port) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_flowinfo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_flowinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_scope_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_scope_id)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ipv6_mreq() {
    const UNINIT: ::std::mem::MaybeUninit<ipv6_mreq> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ipv6_mreq>(),
        20usize,
        concat!("Size of: ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ipv6_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipv6mr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipv6mr_interface) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_interface)
        )
    );
}
extern "C" {
    pub static in6addr_any: in6_addr;
}
extern "C" {
    pub static in6addr_loopback: in6_addr;
}
extern "C" {
    pub fn htonl(arg1: u32) -> u32;
}
extern "C" {
    pub fn htons(arg1: u16) -> u16;
}
extern "C" {
    pub fn ntohl(arg1: u32) -> u32;
}
extern "C" {
    pub fn ntohs(arg1: u16) -> u16;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_ip_opts() {
    const UNINIT: ::std::mem::MaybeUninit<ip_opts> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_opts>(),
        44usize,
        concat!("Size of: ", stringify!(ip_opts))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_opts>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_opts))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip_dst) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip_opts) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_opts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq() {
    const UNINIT: ::std::mem::MaybeUninit<ip_mreq> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_mreq>(),
        8usize,
        concat!("Size of: ", stringify!(ip_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_interface) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_interface)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ip_mreqn() {
    const UNINIT: ::std::mem::MaybeUninit<ip_mreqn> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_mreqn>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreqn))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreqn>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreqn))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_address) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_ifindex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
    pub imr_sourceaddr: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq_source() {
    const UNINIT: ::std::mem::MaybeUninit<ip_mreq_source> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_mreq_source>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq_source>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_interface) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_sourceaddr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_sourceaddr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_msfilter {
    pub imsf_multiaddr: in_addr,
    pub imsf_interface: in_addr,
    pub imsf_fmode: u32,
    pub imsf_numsrc: u32,
    pub imsf_slist: [in_addr; 1usize],
}
#[test]
fn bindgen_test_layout_ip_msfilter() {
    const UNINIT: ::std::mem::MaybeUninit<ip_msfilter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_msfilter>(),
        20usize,
        concat!("Size of: ", stringify!(ip_msfilter))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_msfilter>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_msfilter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imsf_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imsf_interface) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imsf_fmode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_fmode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imsf_numsrc) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_numsrc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imsf_slist) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_slist)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_req() {
    const UNINIT: ::std::mem::MaybeUninit<group_req> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<group_req>(),
        136usize,
        concat!("Size of: ", stringify!(group_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_req>(),
        8usize,
        concat!("Alignment of ", stringify!(group_req))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gr_interface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gr_group) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_group)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_source_req() {
    const UNINIT: ::std::mem::MaybeUninit<group_source_req> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<group_source_req>(),
        264usize,
        concat!("Size of: ", stringify!(group_source_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_source_req>(),
        8usize,
        concat!("Alignment of ", stringify!(group_source_req))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gsr_interface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gsr_group) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gsr_source) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_source)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_filter {
    pub gf_interface: u32,
    pub gf_group: sockaddr_storage,
    pub gf_fmode: u32,
    pub gf_numsrc: u32,
    pub gf_slist: [sockaddr_storage; 1usize],
}
#[test]
fn bindgen_test_layout_group_filter() {
    const UNINIT: ::std::mem::MaybeUninit<group_filter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<group_filter>(),
        272usize,
        concat!("Size of: ", stringify!(group_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<group_filter>(),
        8usize,
        concat!("Alignment of ", stringify!(group_filter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gf_interface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gf_group) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gf_fmode) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_fmode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gf_numsrc) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_numsrc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gf_slist) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_slist)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_int,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
#[test]
fn bindgen_test_layout_in_pktinfo() {
    const UNINIT: ::std::mem::MaybeUninit<in_pktinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in_pktinfo>(),
        12usize,
        concat!("Size of: ", stringify!(in_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in_pktinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi_ifindex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_ifindex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi_spec_dst) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_spec_dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi_addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_addr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_pktinfo {
    pub ipi6_addr: in6_addr,
    pub ipi6_ifindex: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_in6_pktinfo() {
    const UNINIT: ::std::mem::MaybeUninit<in6_pktinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in6_pktinfo>(),
        20usize,
        concat!("Size of: ", stringify!(in6_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_pktinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi6_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_pktinfo),
            "::",
            stringify!(ipi6_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi6_ifindex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_pktinfo),
            "::",
            stringify!(ipi6_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_mtuinfo {
    pub ip6m_addr: sockaddr_in6,
    pub ip6m_mtu: u32,
}
#[test]
fn bindgen_test_layout_ip6_mtuinfo() {
    const UNINIT: ::std::mem::MaybeUninit<ip6_mtuinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip6_mtuinfo>(),
        32usize,
        concat!("Size of: ", stringify!(ip6_mtuinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ip6_mtuinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(ip6_mtuinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6m_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_mtuinfo),
            "::",
            stringify!(ip6m_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6m_mtu) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_mtuinfo),
            "::",
            stringify!(ip6m_mtu)
        )
    );
}
extern "C" {
    pub fn inet_addr(arg1: *const ::std::os::raw::c_char) -> in_addr_t;
}
extern "C" {
    pub fn inet_network(arg1: *const ::std::os::raw::c_char) -> in_addr_t;
}
extern "C" {
    pub fn inet_ntoa(arg1: in_addr) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn inet_pton(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet_ntop(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_char,
        arg4: socklen_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn inet_aton(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut in_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet_makeaddr(arg1: in_addr_t, arg2: in_addr_t) -> in_addr;
}
extern "C" {
    pub fn inet_lnaof(arg1: in_addr) -> in_addr_t;
}
extern "C" {
    pub fn inet_netof(arg1: in_addr) -> in_addr_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addrinfo {
    pub ai_flags: ::std::os::raw::c_int,
    pub ai_family: ::std::os::raw::c_int,
    pub ai_socktype: ::std::os::raw::c_int,
    pub ai_protocol: ::std::os::raw::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_addr: *mut sockaddr,
    pub ai_canonname: *mut ::std::os::raw::c_char,
    pub ai_next: *mut addrinfo,
}
#[test]
fn bindgen_test_layout_addrinfo() {
    const UNINIT: ::std::mem::MaybeUninit<addrinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<addrinfo>(),
        48usize,
        concat!("Size of: ", stringify!(addrinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<addrinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(addrinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_family) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_socktype) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_socktype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_protocol) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_protocol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_addrlen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_addrlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_addr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_canonname) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_canonname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_next) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_next)
        )
    );
}
extern "C" {
    pub fn getaddrinfo(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const addrinfo,
        arg4: *mut *mut addrinfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn freeaddrinfo(arg1: *mut addrinfo);
}
extern "C" {
    pub fn getnameinfo(
        arg1: *const sockaddr,
        arg2: socklen_t,
        arg3: *mut ::std::os::raw::c_char,
        arg4: socklen_t,
        arg5: *mut ::std::os::raw::c_char,
        arg6: socklen_t,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gai_strerror(arg1: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netent {
    pub n_name: *mut ::std::os::raw::c_char,
    pub n_aliases: *mut *mut ::std::os::raw::c_char,
    pub n_addrtype: ::std::os::raw::c_int,
    pub n_net: u32,
}
#[test]
fn bindgen_test_layout_netent() {
    const UNINIT: ::std::mem::MaybeUninit<netent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<netent>(),
        24usize,
        concat!("Size of: ", stringify!(netent))
    );
    assert_eq!(
        ::std::mem::align_of::<netent>(),
        8usize,
        concat!("Alignment of ", stringify!(netent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_aliases) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_aliases)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_addrtype) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_addrtype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_net) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_net)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hostent {
    pub h_name: *mut ::std::os::raw::c_char,
    pub h_aliases: *mut *mut ::std::os::raw::c_char,
    pub h_addrtype: ::std::os::raw::c_int,
    pub h_length: ::std::os::raw::c_int,
    pub h_addr_list: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_hostent() {
    const UNINIT: ::std::mem::MaybeUninit<hostent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hostent>(),
        32usize,
        concat!("Size of: ", stringify!(hostent))
    );
    assert_eq!(
        ::std::mem::align_of::<hostent>(),
        8usize,
        concat!("Alignment of ", stringify!(hostent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_aliases) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_aliases)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_addrtype) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_addrtype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_length) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_addr_list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_addr_list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct servent {
    pub s_name: *mut ::std::os::raw::c_char,
    pub s_aliases: *mut *mut ::std::os::raw::c_char,
    pub s_port: ::std::os::raw::c_int,
    pub s_proto: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_servent() {
    const UNINIT: ::std::mem::MaybeUninit<servent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<servent>(),
        32usize,
        concat!("Size of: ", stringify!(servent))
    );
    assert_eq!(
        ::std::mem::align_of::<servent>(),
        8usize,
        concat!("Alignment of ", stringify!(servent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_aliases) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_aliases)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_port) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_proto) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_proto)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct protoent {
    pub p_name: *mut ::std::os::raw::c_char,
    pub p_aliases: *mut *mut ::std::os::raw::c_char,
    pub p_proto: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_protoent() {
    const UNINIT: ::std::mem::MaybeUninit<protoent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<protoent>(),
        24usize,
        concat!("Size of: ", stringify!(protoent))
    );
    assert_eq!(
        ::std::mem::align_of::<protoent>(),
        8usize,
        concat!("Alignment of ", stringify!(protoent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(protoent),
            "::",
            stringify!(p_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_aliases) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(protoent),
            "::",
            stringify!(p_aliases)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_proto) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(protoent),
            "::",
            stringify!(p_proto)
        )
    );
}
extern "C" {
    pub fn sethostent(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn endhostent();
}
extern "C" {
    pub fn gethostent() -> *mut hostent;
}
extern "C" {
    pub fn setnetent(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn endnetent();
}
extern "C" {
    pub fn getnetent() -> *mut netent;
}
extern "C" {
    pub fn getnetbyaddr(arg1: u32, arg2: ::std::os::raw::c_int) -> *mut netent;
}
extern "C" {
    pub fn getnetbyname(arg1: *const ::std::os::raw::c_char) -> *mut netent;
}
extern "C" {
    pub fn setservent(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn endservent();
}
extern "C" {
    pub fn getservent() -> *mut servent;
}
extern "C" {
    pub fn getservbyname(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut servent;
}
extern "C" {
    pub fn getservbyport(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut servent;
}
extern "C" {
    pub fn setprotoent(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn endprotoent();
}
extern "C" {
    pub fn getprotoent() -> *mut protoent;
}
extern "C" {
    pub fn getprotobyname(arg1: *const ::std::os::raw::c_char) -> *mut protoent;
}
extern "C" {
    pub fn getprotobynumber(arg1: ::std::os::raw::c_int) -> *mut protoent;
}
extern "C" {
    pub fn gethostbyname(arg1: *const ::std::os::raw::c_char) -> *mut hostent;
}
extern "C" {
    pub fn gethostbyaddr(
        arg1: *const ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn __h_errno_location() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn herror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn hstrerror(arg1: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gethostbyname_r(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut hostent,
        arg3: *mut ::std::os::raw::c_char,
        arg4: usize,
        arg5: *mut *mut hostent,
        arg6: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostbyname2_r(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut hostent,
        arg4: *mut ::std::os::raw::c_char,
        arg5: usize,
        arg6: *mut *mut hostent,
        arg7: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostbyname2(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn gethostbyaddr_r(
        arg1: *const ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: *mut hostent,
        arg5: *mut ::std::os::raw::c_char,
        arg6: usize,
        arg7: *mut *mut hostent,
        arg8: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getservbyport_r(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut servent,
        arg4: *mut ::std::os::raw::c_char,
        arg5: usize,
        arg6: *mut *mut servent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getservbyname_r(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut servent,
        arg4: *mut ::std::os::raw::c_char,
        arg5: usize,
        arg6: *mut *mut servent,
    ) -> ::std::os::raw::c_int;
}
pub type switch_int32_t = i32;
pub type switch_size_t = usize;
pub type switch_ssize_t = isize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cJSON {
    pub next: *mut cJSON,
    pub prev: *mut cJSON,
    pub child: *mut cJSON,
    pub type_: ::std::os::raw::c_int,
    pub valuestring: *mut ::std::os::raw::c_char,
    pub valueint: ::std::os::raw::c_int,
    pub valuedouble: f64,
    pub string: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_cJSON() {
    const UNINIT: ::std::mem::MaybeUninit<cJSON> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cJSON>(),
        64usize,
        concat!("Size of: ", stringify!(cJSON))
    );
    assert_eq!(
        ::std::mem::align_of::<cJSON>(),
        8usize,
        concat!("Alignment of ", stringify!(cJSON))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cJSON),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cJSON),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).child) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cJSON),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cJSON),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valuestring) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cJSON),
            "::",
            stringify!(valuestring)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valueint) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cJSON),
            "::",
            stringify!(valueint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valuedouble) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cJSON),
            "::",
            stringify!(valuedouble)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).string) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cJSON),
            "::",
            stringify!(string)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cJSON_Hooks {
    pub malloc_fn:
        ::std::option::Option<unsafe extern "C" fn(sz: usize) -> *mut ::std::os::raw::c_void>,
    pub free_fn: ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_cJSON_Hooks() {
    const UNINIT: ::std::mem::MaybeUninit<cJSON_Hooks> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cJSON_Hooks>(),
        16usize,
        concat!("Size of: ", stringify!(cJSON_Hooks))
    );
    assert_eq!(
        ::std::mem::align_of::<cJSON_Hooks>(),
        8usize,
        concat!("Alignment of ", stringify!(cJSON_Hooks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).malloc_fn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cJSON_Hooks),
            "::",
            stringify!(malloc_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_fn) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cJSON_Hooks),
            "::",
            stringify!(free_fn)
        )
    );
}
pub type cJSON_bool = ::std::os::raw::c_int;
extern "C" {
    pub fn cJSON_Version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cJSON_InitHooks(hooks: *mut cJSON_Hooks);
}
extern "C" {
    pub fn cJSON_Parse(value: *const ::std::os::raw::c_char) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_ParseWithOpts(
        value: *const ::std::os::raw::c_char,
        return_parse_end: *mut *const ::std::os::raw::c_char,
        require_null_terminated: cJSON_bool,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_Print(item: *const cJSON) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cJSON_PrintUnformatted(item: *const cJSON) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cJSON_PrintBuffered(
        item: *const cJSON,
        prebuffer: ::std::os::raw::c_int,
        fmt: cJSON_bool,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cJSON_PrintPreallocated(
        item: *mut cJSON,
        buffer: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
        format: cJSON_bool,
    ) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_Delete(c: *mut cJSON);
}
extern "C" {
    pub fn cJSON_GetArraySize(array: *const cJSON) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cJSON_GetArrayItem(array: *const cJSON, index: ::std::os::raw::c_int) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_GetObjectItem(
        object: *const cJSON,
        string: *const ::std::os::raw::c_char,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_GetObjectItemCaseSensitive(
        object: *const cJSON,
        string: *const ::std::os::raw::c_char,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_HasObjectItem(
        object: *const cJSON,
        string: *const ::std::os::raw::c_char,
    ) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_GetErrorPtr() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cJSON_GetStringValue(item: *mut cJSON) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cJSON_IsInvalid(item: *const cJSON) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_IsFalse(item: *const cJSON) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_IsTrue(item: *const cJSON) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_IsBool(item: *const cJSON) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_IsNull(item: *const cJSON) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_IsNumber(item: *const cJSON) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_IsString(item: *const cJSON) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_IsArray(item: *const cJSON) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_IsObject(item: *const cJSON) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_IsRaw(item: *const cJSON) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_CreateNull() -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_CreateTrue() -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_CreateFalse() -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_CreateBool(boolean: cJSON_bool) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_CreateNumber(num: f64) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_CreateString(string: *const ::std::os::raw::c_char) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_CreateRaw(raw: *const ::std::os::raw::c_char) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_CreateArray() -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_CreateObject() -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_CreateStringReference(string: *const ::std::os::raw::c_char) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_CreateObjectReference(child: *const cJSON) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_CreateArrayReference(child: *const cJSON) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_CreateIntArray(
        numbers: *const ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_CreateFloatArray(numbers: *const f32, count: ::std::os::raw::c_int) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_CreateDoubleArray(numbers: *const f64, count: ::std::os::raw::c_int)
        -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_CreateStringArray(
        strings: *mut *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_int,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_AddItemToArray(array: *mut cJSON, item: *mut cJSON);
}
extern "C" {
    pub fn cJSON_AddItemToObject(
        object: *mut cJSON,
        string: *const ::std::os::raw::c_char,
        item: *mut cJSON,
    );
}
extern "C" {
    pub fn cJSON_AddItemToObjectCS(
        object: *mut cJSON,
        string: *const ::std::os::raw::c_char,
        item: *mut cJSON,
    );
}
extern "C" {
    pub fn cJSON_AddItemReferenceToArray(array: *mut cJSON, item: *mut cJSON);
}
extern "C" {
    pub fn cJSON_AddItemReferenceToObject(
        object: *mut cJSON,
        string: *const ::std::os::raw::c_char,
        item: *mut cJSON,
    );
}
extern "C" {
    pub fn cJSON_DetachItemViaPointer(parent: *mut cJSON, item: *mut cJSON) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_DetachItemFromArray(array: *mut cJSON, which: ::std::os::raw::c_int)
        -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_DeleteItemFromArray(array: *mut cJSON, which: ::std::os::raw::c_int);
}
extern "C" {
    pub fn cJSON_DetachItemFromObject(
        object: *mut cJSON,
        string: *const ::std::os::raw::c_char,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_DetachItemFromObjectCaseSensitive(
        object: *mut cJSON,
        string: *const ::std::os::raw::c_char,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_DeleteItemFromObject(object: *mut cJSON, string: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn cJSON_DeleteItemFromObjectCaseSensitive(
        object: *mut cJSON,
        string: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn cJSON_InsertItemInArray(
        array: *mut cJSON,
        which: ::std::os::raw::c_int,
        newitem: *mut cJSON,
    );
}
extern "C" {
    pub fn cJSON_ReplaceItemViaPointer(
        parent: *mut cJSON,
        item: *mut cJSON,
        replacement: *mut cJSON,
    ) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_ReplaceItemInArray(
        array: *mut cJSON,
        which: ::std::os::raw::c_int,
        newitem: *mut cJSON,
    );
}
extern "C" {
    pub fn cJSON_ReplaceItemInObject(
        object: *mut cJSON,
        string: *const ::std::os::raw::c_char,
        newitem: *mut cJSON,
    );
}
extern "C" {
    pub fn cJSON_ReplaceItemInObjectCaseSensitive(
        object: *mut cJSON,
        string: *const ::std::os::raw::c_char,
        newitem: *mut cJSON,
    );
}
extern "C" {
    pub fn cJSON_Duplicate(item: *const cJSON, recurse: cJSON_bool) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_Compare(
        a: *const cJSON,
        b: *const cJSON,
        case_sensitive: cJSON_bool,
    ) -> cJSON_bool;
}
extern "C" {
    pub fn cJSON_Minify(json: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn cJSON_AddNullToObject(
        object: *mut cJSON,
        name: *const ::std::os::raw::c_char,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_AddTrueToObject(
        object: *mut cJSON,
        name: *const ::std::os::raw::c_char,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_AddFalseToObject(
        object: *mut cJSON,
        name: *const ::std::os::raw::c_char,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_AddBoolToObject(
        object: *mut cJSON,
        name: *const ::std::os::raw::c_char,
        boolean: cJSON_bool,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_AddNumberToObject(
        object: *mut cJSON,
        name: *const ::std::os::raw::c_char,
        number: f64,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_AddStringToObject(
        object: *mut cJSON,
        name: *const ::std::os::raw::c_char,
        string: *const ::std::os::raw::c_char,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_AddRawToObject(
        object: *mut cJSON,
        name: *const ::std::os::raw::c_char,
        raw: *const ::std::os::raw::c_char,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_AddObjectToObject(
        object: *mut cJSON,
        name: *const ::std::os::raw::c_char,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_AddArrayToObject(
        object: *mut cJSON,
        name: *const ::std::os::raw::c_char,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_SetNumberHelper(object: *mut cJSON, number: f64) -> f64;
}
extern "C" {
    pub fn cJSON_malloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cJSON_free(object: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn cJSONUtils_GetPointer(
        object: *mut cJSON,
        pointer: *const ::std::os::raw::c_char,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSONUtils_GetPointerCaseSensitive(
        object: *mut cJSON,
        pointer: *const ::std::os::raw::c_char,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSONUtils_GeneratePatches(from: *mut cJSON, to: *mut cJSON) -> *mut cJSON;
}
extern "C" {
    pub fn cJSONUtils_GeneratePatchesCaseSensitive(from: *mut cJSON, to: *mut cJSON) -> *mut cJSON;
}
extern "C" {
    pub fn cJSONUtils_AddPatchToArray(
        array: *mut cJSON,
        operation: *const ::std::os::raw::c_char,
        path: *const ::std::os::raw::c_char,
        value: *const cJSON,
    );
}
extern "C" {
    pub fn cJSONUtils_ApplyPatches(
        object: *mut cJSON,
        patches: *const cJSON,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cJSONUtils_ApplyPatchesCaseSensitive(
        object: *mut cJSON,
        patches: *const cJSON,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cJSONUtils_MergePatch(target: *mut cJSON, patch: *const cJSON) -> *mut cJSON;
}
extern "C" {
    pub fn cJSONUtils_MergePatchCaseSensitive(
        target: *mut cJSON,
        patch: *const cJSON,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSONUtils_GenerateMergePatch(from: *mut cJSON, to: *mut cJSON) -> *mut cJSON;
}
extern "C" {
    pub fn cJSONUtils_GenerateMergePatchCaseSensitive(
        from: *mut cJSON,
        to: *mut cJSON,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn cJSONUtils_FindPointerFromObjectTo(
        object: *const cJSON,
        target: *const cJSON,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cJSONUtils_SortObject(object: *mut cJSON);
}
extern "C" {
    pub fn cJSONUtils_SortObjectCaseSensitive(object: *mut cJSON);
}
extern "C" {
    pub fn cJSON_CreateStringPrintf(fmt: *const ::std::os::raw::c_char, ...) -> *mut cJSON;
}
extern "C" {
    pub fn cJSON_GetObjectCstr(
        object: *const cJSON,
        string: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
pub const vpx_img_fmt_VPX_IMG_FMT_NONE: vpx_img_fmt = 0;
#[doc = "< 24 bit per pixel packed RGB"]
pub const vpx_img_fmt_VPX_IMG_FMT_RGB24: vpx_img_fmt = 1;
#[doc = "< 32 bit per pixel packed 0RGB"]
pub const vpx_img_fmt_VPX_IMG_FMT_RGB32: vpx_img_fmt = 2;
#[doc = "< 16 bit per pixel, 565"]
pub const vpx_img_fmt_VPX_IMG_FMT_RGB565: vpx_img_fmt = 3;
#[doc = "< 16 bit per pixel, 555"]
pub const vpx_img_fmt_VPX_IMG_FMT_RGB555: vpx_img_fmt = 4;
#[doc = "< UYVY packed YUV"]
pub const vpx_img_fmt_VPX_IMG_FMT_UYVY: vpx_img_fmt = 5;
#[doc = "< YUYV packed YUV"]
pub const vpx_img_fmt_VPX_IMG_FMT_YUY2: vpx_img_fmt = 6;
#[doc = "< YVYU packed YUV"]
pub const vpx_img_fmt_VPX_IMG_FMT_YVYU: vpx_img_fmt = 7;
#[doc = "< 24 bit per pixel packed BGR"]
pub const vpx_img_fmt_VPX_IMG_FMT_BGR24: vpx_img_fmt = 8;
#[doc = "< 32 bit packed BGR0"]
pub const vpx_img_fmt_VPX_IMG_FMT_RGB32_LE: vpx_img_fmt = 9;
#[doc = "< 32 bit packed ARGB, alpha=255"]
pub const vpx_img_fmt_VPX_IMG_FMT_ARGB: vpx_img_fmt = 10;
#[doc = "< 32 bit packed BGRA, alpha=255"]
pub const vpx_img_fmt_VPX_IMG_FMT_ARGB_LE: vpx_img_fmt = 11;
#[doc = "< 16 bit per pixel, gggbbbbb rrrrrggg"]
pub const vpx_img_fmt_VPX_IMG_FMT_RGB565_LE: vpx_img_fmt = 12;
#[doc = "< 16 bit per pixel, gggbbbbb 0rrrrrgg"]
pub const vpx_img_fmt_VPX_IMG_FMT_RGB555_LE: vpx_img_fmt = 13;
pub const vpx_img_fmt_VPX_IMG_FMT_YV12: vpx_img_fmt = 769;
pub const vpx_img_fmt_VPX_IMG_FMT_I420: vpx_img_fmt = 258;
pub const vpx_img_fmt_VPX_IMG_FMT_VPXYV12: vpx_img_fmt = 771;
#[doc = " < planar 4:2:0 format with vpx color space"]
pub const vpx_img_fmt_VPX_IMG_FMT_VPXI420: vpx_img_fmt = 260;
#[doc = " < planar 4:2:0 format with vpx color space"]
pub const vpx_img_fmt_VPX_IMG_FMT_I422: vpx_img_fmt = 261;
#[doc = " < planar 4:2:0 format with vpx color space"]
pub const vpx_img_fmt_VPX_IMG_FMT_I444: vpx_img_fmt = 262;
#[doc = " < planar 4:2:0 format with vpx color space"]
pub const vpx_img_fmt_VPX_IMG_FMT_I440: vpx_img_fmt = 263;
#[doc = " < planar 4:2:0 format with vpx color space"]
pub const vpx_img_fmt_VPX_IMG_FMT_444A: vpx_img_fmt = 1286;
#[doc = " < planar 4:2:0 format with vpx color space"]
pub const vpx_img_fmt_VPX_IMG_FMT_I42016: vpx_img_fmt = 2306;
#[doc = " < planar 4:2:0 format with vpx color space"]
pub const vpx_img_fmt_VPX_IMG_FMT_I42216: vpx_img_fmt = 2309;
#[doc = " < planar 4:2:0 format with vpx color space"]
pub const vpx_img_fmt_VPX_IMG_FMT_I44416: vpx_img_fmt = 2310;
#[doc = " < planar 4:2:0 format with vpx color space"]
pub const vpx_img_fmt_VPX_IMG_FMT_I44016: vpx_img_fmt = 2311;
#[doc = "\\brief List of supported image formats"]
pub type vpx_img_fmt = ::std::os::raw::c_uint;
#[doc = "\\brief List of supported image formats"]
pub use self::vpx_img_fmt as vpx_img_fmt_t;
#[doc = "< Unknown"]
pub const vpx_color_space_VPX_CS_UNKNOWN: vpx_color_space = 0;
#[doc = "< BT.601"]
pub const vpx_color_space_VPX_CS_BT_601: vpx_color_space = 1;
#[doc = "< BT.709"]
pub const vpx_color_space_VPX_CS_BT_709: vpx_color_space = 2;
#[doc = "< SMPTE.170"]
pub const vpx_color_space_VPX_CS_SMPTE_170: vpx_color_space = 3;
#[doc = "< SMPTE.240"]
pub const vpx_color_space_VPX_CS_SMPTE_240: vpx_color_space = 4;
#[doc = "< BT.2020"]
pub const vpx_color_space_VPX_CS_BT_2020: vpx_color_space = 5;
#[doc = "< Reserved"]
pub const vpx_color_space_VPX_CS_RESERVED: vpx_color_space = 6;
#[doc = "< sRGB"]
pub const vpx_color_space_VPX_CS_SRGB: vpx_color_space = 7;
#[doc = "\\brief List of supported color spaces"]
pub type vpx_color_space = ::std::os::raw::c_uint;
#[doc = "\\brief List of supported color spaces"]
pub use self::vpx_color_space as vpx_color_space_t;
#[doc = "< Y [16..235], UV [16..240]"]
pub const vpx_color_range_VPX_CR_STUDIO_RANGE: vpx_color_range = 0;
#[doc = "< YUV/RGB [0..255]"]
pub const vpx_color_range_VPX_CR_FULL_RANGE: vpx_color_range = 1;
#[doc = "\\brief List of supported color range"]
pub type vpx_color_range = ::std::os::raw::c_uint;
#[doc = "\\brief List of supported color range"]
pub use self::vpx_color_range as vpx_color_range_t;
#[doc = "\\brief Image Descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_image {
    #[doc = "< Image Format"]
    pub fmt: vpx_img_fmt_t,
    #[doc = "< Color Space"]
    pub cs: vpx_color_space_t,
    #[doc = "< Color Range"]
    pub range: vpx_color_range_t,
    #[doc = "< Stored image width"]
    pub w: ::std::os::raw::c_uint,
    #[doc = "< Stored image height"]
    pub h: ::std::os::raw::c_uint,
    #[doc = "< Stored image bit-depth"]
    pub bit_depth: ::std::os::raw::c_uint,
    #[doc = "< Displayed image width"]
    pub d_w: ::std::os::raw::c_uint,
    #[doc = "< Displayed image height"]
    pub d_h: ::std::os::raw::c_uint,
    #[doc = "< Intended rendering image width"]
    pub r_w: ::std::os::raw::c_uint,
    #[doc = "< Intended rendering image height"]
    pub r_h: ::std::os::raw::c_uint,
    #[doc = "< subsampling order, X"]
    pub x_chroma_shift: ::std::os::raw::c_uint,
    #[doc = "< subsampling order, Y"]
    pub y_chroma_shift: ::std::os::raw::c_uint,
    #[doc = "< pointer to the top left pixel for each plane"]
    pub planes: [*mut ::std::os::raw::c_uchar; 4usize],
    #[doc = "< stride between rows for each plane"]
    pub stride: [::std::os::raw::c_int; 4usize],
    #[doc = "< bits per sample (for packed formats)"]
    pub bps: ::std::os::raw::c_int,
    #[doc = "\\brief The following member may be set by the application to associate\n data with this image."]
    pub user_priv: *mut ::std::os::raw::c_void,
    #[doc = "< private"]
    pub img_data: *mut ::std::os::raw::c_uchar,
    #[doc = "< private"]
    pub img_data_owner: ::std::os::raw::c_int,
    #[doc = "< private"]
    pub self_allocd: ::std::os::raw::c_int,
    #[doc = "< Frame buffer data associated with the image."]
    pub fb_priv: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_vpx_image() {
    const UNINIT: ::std::mem::MaybeUninit<vpx_image> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vpx_image>(),
        136usize,
        concat!("Size of: ", stringify!(vpx_image))
    );
    assert_eq!(
        ::std::mem::align_of::<vpx_image>(),
        8usize,
        concat!("Alignment of ", stringify!(vpx_image))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fmt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(fmt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cs) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bit_depth) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(bit_depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_w) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(d_w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_h) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(d_h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r_w) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(r_w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r_h) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(r_h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x_chroma_shift) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(x_chroma_shift)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_chroma_shift) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(y_chroma_shift)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).planes) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(planes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bps) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(bps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_priv) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(user_priv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).img_data) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(img_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).img_data_owner) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(img_data_owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).self_allocd) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(self_allocd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fb_priv) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(fb_priv)
        )
    );
}
#[doc = "\\brief Image Descriptor"]
pub type vpx_image_t = vpx_image;
#[doc = "\\brief Representation of a rectangle on a surface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_image_rect {
    #[doc = "< leftmost column"]
    pub x: ::std::os::raw::c_uint,
    #[doc = "< topmost row"]
    pub y: ::std::os::raw::c_uint,
    #[doc = "< width"]
    pub w: ::std::os::raw::c_uint,
    #[doc = "< height"]
    pub h: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_vpx_image_rect() {
    const UNINIT: ::std::mem::MaybeUninit<vpx_image_rect> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vpx_image_rect>(),
        16usize,
        concat!("Size of: ", stringify!(vpx_image_rect))
    );
    assert_eq!(
        ::std::mem::align_of::<vpx_image_rect>(),
        4usize,
        concat!("Alignment of ", stringify!(vpx_image_rect))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image_rect),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image_rect),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image_rect),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image_rect),
            "::",
            stringify!(h)
        )
    );
}
#[doc = "\\brief Representation of a rectangle on a surface"]
pub type vpx_image_rect_t = vpx_image_rect;
extern "C" {
    #[doc = "\\brief Open a descriptor, allocating storage for the underlying image\n\n Returns a descriptor for storing an image of the given format. The\n storage for the descriptor is allocated on the heap.\n\n \\param[in]    img       Pointer to storage for descriptor. If this parameter\n                         is NULL, the storage for the descriptor will be\n                         allocated on the heap.\n \\param[in]    fmt       Format for the image\n \\param[in]    d_w       Width of the image\n \\param[in]    d_h       Height of the image\n \\param[in]    align     Alignment, in bytes, of the image buffer and\n                         each row in the image(stride).\n\n \\return Returns a pointer to the initialized image descriptor. If the img\n         parameter is non-null, the value of the img parameter will be\n         returned."]
    pub fn vpx_img_alloc(
        img: *mut vpx_image_t,
        fmt: vpx_img_fmt_t,
        d_w: ::std::os::raw::c_uint,
        d_h: ::std::os::raw::c_uint,
        align: ::std::os::raw::c_uint,
    ) -> *mut vpx_image_t;
}
extern "C" {
    #[doc = "\\brief Open a descriptor, using existing storage for the underlying image\n\n Returns a descriptor for storing an image of the given format. The\n storage for descriptor has been allocated elsewhere, and a descriptor is\n desired to \"wrap\" that storage.\n\n \\param[in]    img           Pointer to storage for descriptor. If this\n                             parameter is NULL, the storage for the descriptor\n                             will be allocated on the heap.\n \\param[in]    fmt           Format for the image\n \\param[in]    d_w           Width of the image\n \\param[in]    d_h           Height of the image\n \\param[in]    stride_align  Alignment, in bytes, of each row in the image.\n \\param[in]    img_data      Storage to use for the image\n\n \\return Returns a pointer to the initialized image descriptor. If the img\n         parameter is non-null, the value of the img parameter will be\n         returned."]
    pub fn vpx_img_wrap(
        img: *mut vpx_image_t,
        fmt: vpx_img_fmt_t,
        d_w: ::std::os::raw::c_uint,
        d_h: ::std::os::raw::c_uint,
        stride_align: ::std::os::raw::c_uint,
        img_data: *mut ::std::os::raw::c_uchar,
    ) -> *mut vpx_image_t;
}
extern "C" {
    #[doc = "\\brief Set the rectangle identifying the displayed portion of the image\n\n Updates the displayed rectangle (aka viewport) on the image surface to\n match the specified coordinates and size.\n\n \\param[in]    img       Image descriptor\n \\param[in]    x         leftmost column\n \\param[in]    y         topmost row\n \\param[in]    w         width\n \\param[in]    h         height\n\n \\return 0 if the requested rectangle is valid, nonzero otherwise."]
    pub fn vpx_img_set_rect(
        img: *mut vpx_image_t,
        x: ::std::os::raw::c_uint,
        y: ::std::os::raw::c_uint,
        w: ::std::os::raw::c_uint,
        h: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Flip the image vertically (top for bottom)\n\n Adjusts the image descriptor's pointers and strides to make the image\n be referenced upside-down.\n\n \\param[in]    img       Image descriptor"]
    pub fn vpx_img_flip(img: *mut vpx_image_t);
}
extern "C" {
    #[doc = "\\brief Close an image descriptor\n\n Frees all allocated storage associated with an image descriptor.\n\n \\param[in]    img       Image descriptor"]
    pub fn vpx_img_free(img: *mut vpx_image_t);
}
#[doc = "\\brief List of supported image formats"]
pub use self::vpx_img_fmt_t as switch_img_fmt_t;
#[doc = "\\brief Image Descriptor"]
pub type switch_image_t = vpx_image_t;
pub type switch_byte_t = u8;
pub const switch_pvt_class_t_SWITCH_PVT_PRIMARY: switch_pvt_class_t = 0;
pub const switch_pvt_class_t_SWITCH_PVT_SECONDARY: switch_pvt_class_t = 1;
pub type switch_pvt_class_t = ::std::os::raw::c_uint;
pub const switch_dtmf_source_t_SWITCH_DTMF_UNKNOWN: switch_dtmf_source_t = 0;
pub const switch_dtmf_source_t_SWITCH_DTMF_INBAND_AUDIO: switch_dtmf_source_t = 1;
pub const switch_dtmf_source_t_SWITCH_DTMF_RTP: switch_dtmf_source_t = 2;
pub const switch_dtmf_source_t_SWITCH_DTMF_ENDPOINT: switch_dtmf_source_t = 3;
pub const switch_dtmf_source_t_SWITCH_DTMF_APP: switch_dtmf_source_t = 4;
#[doc = "\\enum switch_dtmf_source_t\n\\brief DTMF sources\n<pre>\nSWITCH_DTMF_UNKNOWN             - Unknown source\nSWITCH_DTMF_INBAND_AUDIO        - From audio\nSWITCH_DTMF_RTP                 - From RTP as a telephone event\nSWITCH_DTMF_ENDPOINT            - From endpoint signaling\nSWITCH_DTMF_APP                 - From application\n</pre>"]
pub type switch_dtmf_source_t = ::std::os::raw::c_uint;
pub const switch_digit_action_target_t_DIGIT_TARGET_SELF: switch_digit_action_target_t = 0;
pub const switch_digit_action_target_t_DIGIT_TARGET_PEER: switch_digit_action_target_t = 1;
pub const switch_digit_action_target_t_DIGIT_TARGET_BOTH: switch_digit_action_target_t = 2;
pub type switch_digit_action_target_t = ::std::os::raw::c_uint;
pub const dtmf_flag_t_DTMF_FLAG_SKIP_PROCESS: dtmf_flag_t = 1;
pub const dtmf_flag_t_DTMF_FLAG_SENSITIVE: dtmf_flag_t = 2;
pub type dtmf_flag_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_dtmf_t {
    pub digit: ::std::os::raw::c_char,
    pub duration: u32,
    pub flags: i32,
    pub source: switch_dtmf_source_t,
}
#[test]
fn bindgen_test_layout_switch_dtmf_t() {
    const UNINIT: ::std::mem::MaybeUninit<switch_dtmf_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_dtmf_t>(),
        16usize,
        concat!("Size of: ", stringify!(switch_dtmf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_dtmf_t>(),
        4usize,
        concat!("Alignment of ", stringify!(switch_dtmf_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_dtmf_t),
            "::",
            stringify!(digit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duration) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_dtmf_t),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_dtmf_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_dtmf_t),
            "::",
            stringify!(source)
        )
    );
}
pub const switch_call_direction_t_SWITCH_CALL_DIRECTION_INBOUND: switch_call_direction_t = 0;
pub const switch_call_direction_t_SWITCH_CALL_DIRECTION_OUTBOUND: switch_call_direction_t = 1;
pub type switch_call_direction_t = ::std::os::raw::c_uint;
pub const switch_bind_flag_enum_t_SBF_DIAL_ALEG: switch_bind_flag_enum_t = 1;
pub const switch_bind_flag_enum_t_SBF_EXEC_ALEG: switch_bind_flag_enum_t = 2;
pub const switch_bind_flag_enum_t_SBF_DIAL_BLEG: switch_bind_flag_enum_t = 4;
pub const switch_bind_flag_enum_t_SBF_EXEC_BLEG: switch_bind_flag_enum_t = 8;
pub const switch_bind_flag_enum_t_SBF_EXEC_OPPOSITE: switch_bind_flag_enum_t = 16;
pub const switch_bind_flag_enum_t_SBF_EXEC_SAME: switch_bind_flag_enum_t = 32;
pub const switch_bind_flag_enum_t_SBF_ONCE: switch_bind_flag_enum_t = 64;
pub const switch_bind_flag_enum_t_SBF_EXEC_INLINE: switch_bind_flag_enum_t = 128;
pub type switch_bind_flag_enum_t = ::std::os::raw::c_uint;
pub type switch_bind_flag_t = u32;
pub const switch_dtmf_direction_t_SWITCH_DTMF_RECV: switch_dtmf_direction_t = 0;
pub const switch_dtmf_direction_t_SWITCH_DTMF_SEND: switch_dtmf_direction_t = 1;
pub type switch_dtmf_direction_t = ::std::os::raw::c_uint;
pub const switch_originate_flag_enum_t_SOF_NONE: switch_originate_flag_enum_t = 0;
pub const switch_originate_flag_enum_t_SOF_NOBLOCK: switch_originate_flag_enum_t = 1;
pub const switch_originate_flag_enum_t_SOF_FORKED_DIAL: switch_originate_flag_enum_t = 2;
pub const switch_originate_flag_enum_t_SOF_NO_EFFECTIVE_ANI: switch_originate_flag_enum_t = 4;
pub const switch_originate_flag_enum_t_SOF_NO_EFFECTIVE_ANIII: switch_originate_flag_enum_t = 8;
pub const switch_originate_flag_enum_t_SOF_NO_EFFECTIVE_CID_NUM: switch_originate_flag_enum_t = 16;
pub const switch_originate_flag_enum_t_SOF_NO_EFFECTIVE_CID_NAME: switch_originate_flag_enum_t = 32;
pub const switch_originate_flag_enum_t_SOF_NO_LIMITS: switch_originate_flag_enum_t = 64;
pub type switch_originate_flag_enum_t = ::std::os::raw::c_uint;
pub type switch_originate_flag_t = u32;
pub const switch_port_flag_enum_t_SPF_NONE: switch_port_flag_enum_t = 0;
pub const switch_port_flag_enum_t_SPF_ODD: switch_port_flag_enum_t = 1;
pub const switch_port_flag_enum_t_SPF_EVEN: switch_port_flag_enum_t = 2;
pub const switch_port_flag_enum_t_SPF_ROBUST_TCP: switch_port_flag_enum_t = 4;
pub const switch_port_flag_enum_t_SPF_ROBUST_UDP: switch_port_flag_enum_t = 8;
pub type switch_port_flag_enum_t = ::std::os::raw::c_uint;
pub type switch_port_flag_t = u32;
pub const switch_eavesdrop_flag_enum_t_ED_NONE: switch_eavesdrop_flag_enum_t = 0;
pub const switch_eavesdrop_flag_enum_t_ED_MUX_READ: switch_eavesdrop_flag_enum_t = 1;
pub const switch_eavesdrop_flag_enum_t_ED_MUX_WRITE: switch_eavesdrop_flag_enum_t = 2;
pub const switch_eavesdrop_flag_enum_t_ED_DTMF: switch_eavesdrop_flag_enum_t = 4;
pub const switch_eavesdrop_flag_enum_t_ED_COPY_DISPLAY: switch_eavesdrop_flag_enum_t = 8;
pub const switch_eavesdrop_flag_enum_t_ED_BRIDGE_READ: switch_eavesdrop_flag_enum_t = 16;
pub const switch_eavesdrop_flag_enum_t_ED_BRIDGE_WRITE: switch_eavesdrop_flag_enum_t = 32;
pub const switch_eavesdrop_flag_enum_t_ED_TAP_READ: switch_eavesdrop_flag_enum_t = 64;
pub const switch_eavesdrop_flag_enum_t_ED_TAP_WRITE: switch_eavesdrop_flag_enum_t = 128;
pub const switch_eavesdrop_flag_enum_t_ED_STEREO: switch_eavesdrop_flag_enum_t = 256;
pub type switch_eavesdrop_flag_enum_t = ::std::os::raw::c_uint;
pub type switch_eavesdrop_flag_t = u32;
pub const switch_core_flag_enum_t_SCF_NONE: switch_core_flag_enum_t = 0;
pub const switch_core_flag_enum_t_SCF_USE_SQL: switch_core_flag_enum_t = 1;
pub const switch_core_flag_enum_t_SCF_NO_NEW_OUTBOUND_SESSIONS: switch_core_flag_enum_t = 2;
pub const switch_core_flag_enum_t_SCF_NO_NEW_INBOUND_SESSIONS: switch_core_flag_enum_t = 4;
pub const switch_core_flag_enum_t_SCF_NO_NEW_SESSIONS: switch_core_flag_enum_t = 6;
pub const switch_core_flag_enum_t_SCF_SHUTTING_DOWN: switch_core_flag_enum_t = 8;
pub const switch_core_flag_enum_t_SCF_VG: switch_core_flag_enum_t = 16;
pub const switch_core_flag_enum_t_SCF_RESTART: switch_core_flag_enum_t = 32;
pub const switch_core_flag_enum_t_SCF_SHUTDOWN_REQUESTED: switch_core_flag_enum_t = 64;
pub const switch_core_flag_enum_t_SCF_USE_AUTO_NAT: switch_core_flag_enum_t = 128;
pub const switch_core_flag_enum_t_SCF_EARLY_HANGUP: switch_core_flag_enum_t = 256;
pub const switch_core_flag_enum_t_SCF_CALIBRATE_CLOCK: switch_core_flag_enum_t = 512;
pub const switch_core_flag_enum_t_SCF_USE_HEAVY_TIMING: switch_core_flag_enum_t = 1024;
pub const switch_core_flag_enum_t_SCF_USE_CLOCK_RT: switch_core_flag_enum_t = 2048;
pub const switch_core_flag_enum_t_SCF_VERBOSE_EVENTS: switch_core_flag_enum_t = 4096;
pub const switch_core_flag_enum_t_SCF_USE_WIN32_MONOTONIC: switch_core_flag_enum_t = 8192;
pub const switch_core_flag_enum_t_SCF_AUTO_SCHEMAS: switch_core_flag_enum_t = 16384;
pub const switch_core_flag_enum_t_SCF_MINIMAL: switch_core_flag_enum_t = 32768;
pub const switch_core_flag_enum_t_SCF_USE_NAT_MAPPING: switch_core_flag_enum_t = 65536;
pub const switch_core_flag_enum_t_SCF_CLEAR_SQL: switch_core_flag_enum_t = 131072;
pub const switch_core_flag_enum_t_SCF_THREADED_SYSTEM_EXEC: switch_core_flag_enum_t = 262144;
pub const switch_core_flag_enum_t_SCF_SYNC_CLOCK_REQUESTED: switch_core_flag_enum_t = 524288;
pub const switch_core_flag_enum_t_SCF_CORE_NON_SQLITE_DB_REQ: switch_core_flag_enum_t = 1048576;
pub const switch_core_flag_enum_t_SCF_DEBUG_SQL: switch_core_flag_enum_t = 2097152;
pub const switch_core_flag_enum_t_SCF_API_EXPANSION: switch_core_flag_enum_t = 4194304;
pub const switch_core_flag_enum_t_SCF_SESSION_THREAD_POOL: switch_core_flag_enum_t = 8388608;
pub const switch_core_flag_enum_t_SCF_DIALPLAN_TIMESTAMPS: switch_core_flag_enum_t = 16777216;
pub const switch_core_flag_enum_t_SCF_CPF_SOFT_PREFIX: switch_core_flag_enum_t = 33554432;
pub const switch_core_flag_enum_t_SCF_CPF_SOFT_LOOKUP: switch_core_flag_enum_t = 67108864;
pub const switch_core_flag_enum_t_SCF_EVENT_CHANNEL_ENABLE_HIERARCHY_DELIVERY:
    switch_core_flag_enum_t = 134217728;
pub const switch_core_flag_enum_t_SCF_EVENT_CHANNEL_HIERARCHY_DELIVERY_ONCE:
    switch_core_flag_enum_t = 268435456;
pub const switch_core_flag_enum_t_SCF_EVENT_CHANNEL_LOG_UNDELIVERABLE_JSON:
    switch_core_flag_enum_t = 536870912;
pub const switch_core_flag_enum_t_SCF_LOG_DISABLE: switch_core_flag_enum_t = 1073741824;
pub type switch_core_flag_enum_t = ::std::os::raw::c_uint;
pub type switch_core_flag_t = u32;
pub const switch_module_interface_name_t_SWITCH_ENDPOINT_INTERFACE: switch_module_interface_name_t =
    0;
pub const switch_module_interface_name_t_SWITCH_TIMER_INTERFACE: switch_module_interface_name_t = 1;
pub const switch_module_interface_name_t_SWITCH_DIALPLAN_INTERFACE: switch_module_interface_name_t =
    2;
pub const switch_module_interface_name_t_SWITCH_CODEC_INTERFACE: switch_module_interface_name_t = 3;
pub const switch_module_interface_name_t_SWITCH_APPLICATION_INTERFACE:
    switch_module_interface_name_t = 4;
pub const switch_module_interface_name_t_SWITCH_API_INTERFACE: switch_module_interface_name_t = 5;
pub const switch_module_interface_name_t_SWITCH_FILE_INTERFACE: switch_module_interface_name_t = 6;
pub const switch_module_interface_name_t_SWITCH_SPEECH_INTERFACE: switch_module_interface_name_t =
    7;
pub const switch_module_interface_name_t_SWITCH_DIRECTORY_INTERFACE:
    switch_module_interface_name_t = 8;
pub const switch_module_interface_name_t_SWITCH_CHAT_INTERFACE: switch_module_interface_name_t = 9;
pub const switch_module_interface_name_t_SWITCH_SAY_INTERFACE: switch_module_interface_name_t = 10;
pub const switch_module_interface_name_t_SWITCH_ASR_INTERFACE: switch_module_interface_name_t = 11;
pub const switch_module_interface_name_t_SWITCH_MANAGEMENT_INTERFACE:
    switch_module_interface_name_t = 12;
pub const switch_module_interface_name_t_SWITCH_LIMIT_INTERFACE: switch_module_interface_name_t =
    13;
pub const switch_module_interface_name_t_SWITCH_CHAT_APPLICATION_INTERFACE:
    switch_module_interface_name_t = 14;
pub const switch_module_interface_name_t_SWITCH_JSON_API_INTERFACE: switch_module_interface_name_t =
    15;
pub const switch_module_interface_name_t_SWITCH_DATABASE_INTERFACE: switch_module_interface_name_t =
    16;
pub type switch_module_interface_name_t = ::std::os::raw::c_uint;
pub const switch_database_flag_enum_t_SWITCH_DATABASE_FLAG_ROW_SIZE_LIMIT:
    switch_database_flag_enum_t = 1;
#[doc = "\\enum switch_database_flag_t\n\\brief Database flags\n<pre>\nSWITCH_DATABASE_FLAG_ROW_SIZE_LIMIT = (1 <<  0) - Indicates that database has got row-size limit for the combined sizes of all columns.\n</pre>"]
pub type switch_database_flag_enum_t = ::std::os::raw::c_uint;
pub type switch_database_flag_t = u32;
pub const switch_unicast_flag_enum_t_SUF_NONE: switch_unicast_flag_enum_t = 0;
pub const switch_unicast_flag_enum_t_SUF_THREAD_RUNNING: switch_unicast_flag_enum_t = 1;
pub const switch_unicast_flag_enum_t_SUF_READY: switch_unicast_flag_enum_t = 2;
pub const switch_unicast_flag_enum_t_SUF_NATIVE: switch_unicast_flag_enum_t = 4;
pub type switch_unicast_flag_enum_t = ::std::os::raw::c_uint;
pub type switch_unicast_flag_t = u32;
pub const switch_bool_t_SWITCH_FALSE: switch_bool_t = 0;
pub const switch_bool_t_SWITCH_TRUE: switch_bool_t = 1;
pub type switch_bool_t = ::std::os::raw::c_uint;
pub const switch_say_method_t_SSM_NA: switch_say_method_t = 0;
pub const switch_say_method_t_SSM_PRONOUNCED: switch_say_method_t = 1;
pub const switch_say_method_t_SSM_ITERATED: switch_say_method_t = 2;
pub const switch_say_method_t_SSM_COUNTED: switch_say_method_t = 3;
pub const switch_say_method_t_SSM_PRONOUNCED_YEAR: switch_say_method_t = 4;
pub type switch_say_method_t = ::std::os::raw::c_uint;
pub const switch_say_type_t_SST_NUMBER: switch_say_type_t = 0;
pub const switch_say_type_t_SST_ITEMS: switch_say_type_t = 1;
pub const switch_say_type_t_SST_PERSONS: switch_say_type_t = 2;
pub const switch_say_type_t_SST_MESSAGES: switch_say_type_t = 3;
pub const switch_say_type_t_SST_CURRENCY: switch_say_type_t = 4;
pub const switch_say_type_t_SST_TIME_MEASUREMENT: switch_say_type_t = 5;
pub const switch_say_type_t_SST_CURRENT_DATE: switch_say_type_t = 6;
pub const switch_say_type_t_SST_CURRENT_TIME: switch_say_type_t = 7;
pub const switch_say_type_t_SST_CURRENT_DATE_TIME: switch_say_type_t = 8;
pub const switch_say_type_t_SST_TELEPHONE_NUMBER: switch_say_type_t = 9;
pub const switch_say_type_t_SST_TELEPHONE_EXTENSION: switch_say_type_t = 10;
pub const switch_say_type_t_SST_URL: switch_say_type_t = 11;
pub const switch_say_type_t_SST_IP_ADDRESS: switch_say_type_t = 12;
pub const switch_say_type_t_SST_EMAIL_ADDRESS: switch_say_type_t = 13;
pub const switch_say_type_t_SST_POSTAL_ADDRESS: switch_say_type_t = 14;
pub const switch_say_type_t_SST_ACCOUNT_NUMBER: switch_say_type_t = 15;
pub const switch_say_type_t_SST_NAME_SPELLED: switch_say_type_t = 16;
pub const switch_say_type_t_SST_NAME_PHONETIC: switch_say_type_t = 17;
pub const switch_say_type_t_SST_SHORT_DATE_TIME: switch_say_type_t = 18;
pub type switch_say_type_t = ::std::os::raw::c_uint;
pub const switch_say_gender_t_SSG_MASCULINE: switch_say_gender_t = 0;
pub const switch_say_gender_t_SSG_FEMININE: switch_say_gender_t = 1;
pub const switch_say_gender_t_SSG_NEUTER: switch_say_gender_t = 2;
pub const switch_say_gender_t_SSG_UTRUM: switch_say_gender_t = 3;
pub type switch_say_gender_t = ::std::os::raw::c_uint;
pub const switch_management_action_t_SMA_NONE: switch_management_action_t = 0;
pub const switch_management_action_t_SMA_GET: switch_management_action_t = 1;
pub const switch_management_action_t_SMA_SET: switch_management_action_t = 2;
pub type switch_management_action_t = ::std::os::raw::c_uint;
pub const switch_scheduler_flag_enum_t_SSHF_NONE: switch_scheduler_flag_enum_t = 0;
pub const switch_scheduler_flag_enum_t_SSHF_OWN_THREAD: switch_scheduler_flag_enum_t = 1;
pub const switch_scheduler_flag_enum_t_SSHF_FREE_ARG: switch_scheduler_flag_enum_t = 2;
pub const switch_scheduler_flag_enum_t_SSHF_NO_DEL: switch_scheduler_flag_enum_t = 4;
pub type switch_scheduler_flag_enum_t = ::std::os::raw::c_uint;
pub type switch_scheduler_flag_t = u32;
pub const switch_media_flag_enum_t_SMF_NONE: switch_media_flag_enum_t = 0;
pub const switch_media_flag_enum_t_SMF_REBRIDGE: switch_media_flag_enum_t = 1;
pub const switch_media_flag_enum_t_SMF_ECHO_ALEG: switch_media_flag_enum_t = 2;
pub const switch_media_flag_enum_t_SMF_ECHO_BLEG: switch_media_flag_enum_t = 4;
pub const switch_media_flag_enum_t_SMF_FORCE: switch_media_flag_enum_t = 8;
pub const switch_media_flag_enum_t_SMF_LOOP: switch_media_flag_enum_t = 16;
pub const switch_media_flag_enum_t_SMF_HOLD_BLEG: switch_media_flag_enum_t = 32;
pub const switch_media_flag_enum_t_SMF_IMMEDIATE: switch_media_flag_enum_t = 64;
pub const switch_media_flag_enum_t_SMF_EXEC_INLINE: switch_media_flag_enum_t = 128;
pub const switch_media_flag_enum_t_SMF_PRIORITY: switch_media_flag_enum_t = 256;
pub const switch_media_flag_enum_t_SMF_REPLYONLY_A: switch_media_flag_enum_t = 512;
pub const switch_media_flag_enum_t_SMF_REPLYONLY_B: switch_media_flag_enum_t = 1024;
pub type switch_media_flag_enum_t = ::std::os::raw::c_uint;
pub type switch_media_flag_t = u32;
pub const switch_bitpack_mode_t_SWITCH_BITPACK_MODE_RFC3551: switch_bitpack_mode_t = 0;
pub const switch_bitpack_mode_t_SWITCH_BITPACK_MODE_AAL2: switch_bitpack_mode_t = 1;
pub type switch_bitpack_mode_t = ::std::os::raw::c_uint;
pub const switch_abc_type_t_SWITCH_ABC_TYPE_INIT: switch_abc_type_t = 0;
pub const switch_abc_type_t_SWITCH_ABC_TYPE_READ: switch_abc_type_t = 1;
pub const switch_abc_type_t_SWITCH_ABC_TYPE_WRITE: switch_abc_type_t = 2;
pub const switch_abc_type_t_SWITCH_ABC_TYPE_WRITE_REPLACE: switch_abc_type_t = 3;
pub const switch_abc_type_t_SWITCH_ABC_TYPE_READ_REPLACE: switch_abc_type_t = 4;
pub const switch_abc_type_t_SWITCH_ABC_TYPE_READ_PING: switch_abc_type_t = 5;
pub const switch_abc_type_t_SWITCH_ABC_TYPE_TAP_NATIVE_READ: switch_abc_type_t = 6;
pub const switch_abc_type_t_SWITCH_ABC_TYPE_TAP_NATIVE_WRITE: switch_abc_type_t = 7;
pub const switch_abc_type_t_SWITCH_ABC_TYPE_CLOSE: switch_abc_type_t = 8;
pub const switch_abc_type_t_SWITCH_ABC_TYPE_READ_VIDEO_PING: switch_abc_type_t = 9;
pub const switch_abc_type_t_SWITCH_ABC_TYPE_WRITE_VIDEO_PING: switch_abc_type_t = 10;
pub const switch_abc_type_t_SWITCH_ABC_TYPE_STREAM_VIDEO_PING: switch_abc_type_t = 11;
pub const switch_abc_type_t_SWITCH_ABC_TYPE_VIDEO_PATCH: switch_abc_type_t = 12;
pub const switch_abc_type_t_SWITCH_ABC_TYPE_READ_TEXT: switch_abc_type_t = 13;
pub type switch_abc_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_bitpack_t {
    pub buf: *mut switch_byte_t,
    pub buflen: u32,
    pub cur: *mut switch_byte_t,
    pub bytes: u32,
    pub bits_tot: u32,
    pub bits_cur: switch_byte_t,
    pub bits_rem: switch_byte_t,
    pub frame_bits: switch_byte_t,
    pub shiftby: switch_byte_t,
    pub this_byte: switch_byte_t,
    pub under: switch_byte_t,
    pub over: switch_byte_t,
    pub mode: switch_bitpack_mode_t,
}
#[test]
fn bindgen_test_layout_switch_bitpack_t() {
    const UNINIT: ::std::mem::MaybeUninit<switch_bitpack_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_bitpack_t>(),
        48usize,
        concat!("Size of: ", stringify!(switch_bitpack_t))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_bitpack_t>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_bitpack_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_bitpack_t),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buflen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_bitpack_t),
            "::",
            stringify!(buflen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cur) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_bitpack_t),
            "::",
            stringify!(cur)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_bitpack_t),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits_tot) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_bitpack_t),
            "::",
            stringify!(bits_tot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits_cur) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_bitpack_t),
            "::",
            stringify!(bits_cur)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits_rem) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_bitpack_t),
            "::",
            stringify!(bits_rem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_bits) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_bitpack_t),
            "::",
            stringify!(frame_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shiftby) as usize - ptr as usize },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_bitpack_t),
            "::",
            stringify!(shiftby)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).this_byte) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_bitpack_t),
            "::",
            stringify!(this_byte)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).under) as usize - ptr as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_bitpack_t),
            "::",
            stringify!(under)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).over) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_bitpack_t),
            "::",
            stringify!(over)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_bitpack_t),
            "::",
            stringify!(mode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_directories {
    pub base_dir: *mut ::std::os::raw::c_char,
    pub mod_dir: *mut ::std::os::raw::c_char,
    pub conf_dir: *mut ::std::os::raw::c_char,
    pub log_dir: *mut ::std::os::raw::c_char,
    pub run_dir: *mut ::std::os::raw::c_char,
    pub db_dir: *mut ::std::os::raw::c_char,
    pub script_dir: *mut ::std::os::raw::c_char,
    pub temp_dir: *mut ::std::os::raw::c_char,
    pub htdocs_dir: *mut ::std::os::raw::c_char,
    pub grammar_dir: *mut ::std::os::raw::c_char,
    pub storage_dir: *mut ::std::os::raw::c_char,
    pub cache_dir: *mut ::std::os::raw::c_char,
    pub recordings_dir: *mut ::std::os::raw::c_char,
    pub sounds_dir: *mut ::std::os::raw::c_char,
    pub lib_dir: *mut ::std::os::raw::c_char,
    pub certs_dir: *mut ::std::os::raw::c_char,
    pub fonts_dir: *mut ::std::os::raw::c_char,
    pub images_dir: *mut ::std::os::raw::c_char,
    pub data_dir: *mut ::std::os::raw::c_char,
    pub localstate_dir: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_switch_directories() {
    const UNINIT: ::std::mem::MaybeUninit<switch_directories> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_directories>(),
        160usize,
        concat!("Size of: ", stringify!(switch_directories))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_directories>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_directories))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_dir) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directories),
            "::",
            stringify!(base_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mod_dir) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directories),
            "::",
            stringify!(mod_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conf_dir) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directories),
            "::",
            stringify!(conf_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_dir) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directories),
            "::",
            stringify!(log_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).run_dir) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directories),
            "::",
            stringify!(run_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).db_dir) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directories),
            "::",
            stringify!(db_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).script_dir) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directories),
            "::",
            stringify!(script_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temp_dir) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directories),
            "::",
            stringify!(temp_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).htdocs_dir) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directories),
            "::",
            stringify!(htdocs_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).grammar_dir) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directories),
            "::",
            stringify!(grammar_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).storage_dir) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directories),
            "::",
            stringify!(storage_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cache_dir) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directories),
            "::",
            stringify!(cache_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recordings_dir) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directories),
            "::",
            stringify!(recordings_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sounds_dir) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directories),
            "::",
            stringify!(sounds_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lib_dir) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directories),
            "::",
            stringify!(lib_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).certs_dir) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directories),
            "::",
            stringify!(certs_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fonts_dir) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directories),
            "::",
            stringify!(fonts_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).images_dir) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directories),
            "::",
            stringify!(images_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_dir) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directories),
            "::",
            stringify!(data_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).localstate_dir) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directories),
            "::",
            stringify!(localstate_dir)
        )
    );
}
extern "C" {
    pub static mut SWITCH_GLOBAL_dirs: switch_directories;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_filenames {
    pub conf_name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_switch_filenames() {
    const UNINIT: ::std::mem::MaybeUninit<switch_filenames> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_filenames>(),
        8usize,
        concat!("Size of: ", stringify!(switch_filenames))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_filenames>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_filenames))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conf_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_filenames),
            "::",
            stringify!(conf_name)
        )
    );
}
extern "C" {
    pub static mut SWITCH_GLOBAL_filenames: switch_filenames;
}
pub const switch_rw_t_SWITCH_RW_READ: switch_rw_t = 0;
pub const switch_rw_t_SWITCH_RW_WRITE: switch_rw_t = 1;
pub type switch_rw_t = ::std::os::raw::c_uint;
pub const switch_caller_profile_flag_enum_t_SWITCH_CPF_NONE: switch_caller_profile_flag_enum_t = 0;
pub const switch_caller_profile_flag_enum_t_SWITCH_CPF_SCREEN: switch_caller_profile_flag_enum_t =
    1;
pub const switch_caller_profile_flag_enum_t_SWITCH_CPF_HIDE_NAME:
    switch_caller_profile_flag_enum_t = 2;
pub const switch_caller_profile_flag_enum_t_SWITCH_CPF_HIDE_NUMBER:
    switch_caller_profile_flag_enum_t = 4;
pub const switch_caller_profile_flag_enum_t_SWITCH_CPF_SOFT_PREFIX:
    switch_caller_profile_flag_enum_t = 8;
pub const switch_caller_profile_flag_enum_t_SWITCH_CPF_SOFT_LOOKUP:
    switch_caller_profile_flag_enum_t = 16;
pub type switch_caller_profile_flag_enum_t = ::std::os::raw::c_uint;
pub type switch_caller_profile_flag_t = u32;
pub const switch_audio_col_t_SWITCH_AUDIO_COL_STR_TITLE: switch_audio_col_t = 1;
pub const switch_audio_col_t_SWITCH_AUDIO_COL_STR_COPYRIGHT: switch_audio_col_t = 2;
pub const switch_audio_col_t_SWITCH_AUDIO_COL_STR_SOFTWARE: switch_audio_col_t = 3;
pub const switch_audio_col_t_SWITCH_AUDIO_COL_STR_ARTIST: switch_audio_col_t = 4;
pub const switch_audio_col_t_SWITCH_AUDIO_COL_STR_COMMENT: switch_audio_col_t = 5;
pub const switch_audio_col_t_SWITCH_AUDIO_COL_STR_DATE: switch_audio_col_t = 6;
pub const switch_audio_col_t_SWITCH_AUDIO_COL_STR_ALBUM: switch_audio_col_t = 7;
pub const switch_audio_col_t_SWITCH_AUDIO_COL_STR_LICENSE: switch_audio_col_t = 8;
pub const switch_audio_col_t_SWITCH_AUDIO_COL_STR_TRACKNUMBER: switch_audio_col_t = 9;
pub const switch_audio_col_t_SWITCH_AUDIO_COL_STR_GENRE: switch_audio_col_t = 16;
pub const switch_audio_col_t_SWITCH_AUDIO_COL_STR_FILE_SIZE: switch_audio_col_t = 240;
pub const switch_audio_col_t_SWITCH_AUDIO_COL_STR_FILE_TRIMMED: switch_audio_col_t = 241;
pub const switch_audio_col_t_SWITCH_AUDIO_COL_STR_FILE_TRIMMED_MS: switch_audio_col_t = 242;
pub type switch_audio_col_t = ::std::os::raw::c_uint;
pub const switch_xml_section_enum_t_SWITCH_XML_SECTION_RESULT: switch_xml_section_enum_t = 0;
pub const switch_xml_section_enum_t_SWITCH_XML_SECTION_CONFIG: switch_xml_section_enum_t = 1;
pub const switch_xml_section_enum_t_SWITCH_XML_SECTION_DIRECTORY: switch_xml_section_enum_t = 2;
pub const switch_xml_section_enum_t_SWITCH_XML_SECTION_DIALPLAN: switch_xml_section_enum_t = 4;
pub const switch_xml_section_enum_t_SWITCH_XML_SECTION_LANGUAGES: switch_xml_section_enum_t = 8;
pub const switch_xml_section_enum_t_SWITCH_XML_SECTION_CHATPLAN: switch_xml_section_enum_t = 16;
pub const switch_xml_section_enum_t_SWITCH_XML_SECTION_CHANNELS: switch_xml_section_enum_t = 32;
pub const switch_xml_section_enum_t_SWITCH_XML_SECTION_MAX: switch_xml_section_enum_t = 32;
pub type switch_xml_section_enum_t = ::std::os::raw::c_uint;
pub type switch_xml_section_t = u32;
pub const switch_vad_flag_enum_t_SWITCH_VAD_FLAG_TALKING: switch_vad_flag_enum_t = 1;
pub const switch_vad_flag_enum_t_SWITCH_VAD_FLAG_EVENTS_TALK: switch_vad_flag_enum_t = 2;
pub const switch_vad_flag_enum_t_SWITCH_VAD_FLAG_EVENTS_NOTALK: switch_vad_flag_enum_t = 4;
pub const switch_vad_flag_enum_t_SWITCH_VAD_FLAG_CNG: switch_vad_flag_enum_t = 8;
#[doc = "\\enum switch_vad_flag_t\n\\brief RTP Related Flags\n<pre>\nSWITCH_VAD_FLAG_TALKING         - Currently Talking\nSWITCH_VAD_FLAG_EVENTS_TALK     - Fire events when talking is detected\nSWITCH_VAD_FLAG_EVENTS_NOTALK   - Fire events when not talking is detected\nSWITCH_VAD_FLAG_CNG\t\t\t\t- Send CNG\n</pre>"]
pub type switch_vad_flag_enum_t = ::std::os::raw::c_uint;
pub type switch_vad_flag_t = u32;
pub const switch_vad_state_t_SWITCH_VAD_STATE_NONE: switch_vad_state_t = 0;
pub const switch_vad_state_t_SWITCH_VAD_STATE_START_TALKING: switch_vad_state_t = 1;
pub const switch_vad_state_t_SWITCH_VAD_STATE_TALKING: switch_vad_state_t = 2;
pub const switch_vad_state_t_SWITCH_VAD_STATE_STOP_TALKING: switch_vad_state_t = 3;
pub const switch_vad_state_t_SWITCH_VAD_STATE_ERROR: switch_vad_state_t = 4;
pub type switch_vad_state_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_vad_s {
    _unused: [u8; 0],
}
pub type switch_vad_t = switch_vad_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct error_period {
    pub start: i64,
    pub stop: i64,
    pub flaws: u32,
    pub consecutive_flaws: u32,
    pub next: *mut error_period,
}
#[test]
fn bindgen_test_layout_error_period() {
    const UNINIT: ::std::mem::MaybeUninit<error_period> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<error_period>(),
        32usize,
        concat!("Size of: ", stringify!(error_period))
    );
    assert_eq!(
        ::std::mem::align_of::<error_period>(),
        8usize,
        concat!("Alignment of ", stringify!(error_period))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(error_period),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(error_period),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flaws) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(error_period),
            "::",
            stringify!(flaws)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).consecutive_flaws) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(error_period),
            "::",
            stringify!(consecutive_flaws)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(error_period),
            "::",
            stringify!(next)
        )
    );
}
pub type switch_error_period_t = error_period;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_rtp_numbers_t {
    pub raw_bytes: switch_size_t,
    pub media_bytes: switch_size_t,
    pub packet_count: switch_size_t,
    pub period_packet_count: switch_size_t,
    pub media_packet_count: switch_size_t,
    pub skip_packet_count: switch_size_t,
    pub jb_packet_count: switch_size_t,
    pub dtmf_packet_count: switch_size_t,
    pub cng_packet_count: switch_size_t,
    pub flush_packet_count: switch_size_t,
    pub largest_jb_size: switch_size_t,
    pub last_proc_time: i64,
    pub jitter_n: i64,
    pub jitter_add: i64,
    pub jitter_addsq: i64,
    pub variance: f64,
    pub min_variance: f64,
    pub max_variance: f64,
    pub std_deviation: f64,
    pub lossrate: f64,
    pub burstrate: f64,
    pub mean_interval: f64,
    pub loss: [::std::os::raw::c_int; 1024usize],
    pub last_loss: ::std::os::raw::c_int,
    pub recved: ::std::os::raw::c_int,
    pub last_processed_seq: ::std::os::raw::c_int,
    pub flaws: switch_size_t,
    pub last_flaw: switch_size_t,
    pub R: f64,
    pub mos: f64,
    pub error_log: *mut error_period,
}
#[test]
fn bindgen_test_layout_switch_rtp_numbers_t() {
    const UNINIT: ::std::mem::MaybeUninit<switch_rtp_numbers_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_rtp_numbers_t>(),
        4328usize,
        concat!("Size of: ", stringify!(switch_rtp_numbers_t))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_rtp_numbers_t>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_rtp_numbers_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_numbers_t),
            "::",
            stringify!(raw_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).media_bytes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_numbers_t),
            "::",
            stringify!(media_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packet_count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_numbers_t),
            "::",
            stringify!(packet_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).period_packet_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_numbers_t),
            "::",
            stringify!(period_packet_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).media_packet_count) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_numbers_t),
            "::",
            stringify!(media_packet_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skip_packet_count) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_numbers_t),
            "::",
            stringify!(skip_packet_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).jb_packet_count) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_numbers_t),
            "::",
            stringify!(jb_packet_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dtmf_packet_count) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_numbers_t),
            "::",
            stringify!(dtmf_packet_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cng_packet_count) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_numbers_t),
            "::",
            stringify!(cng_packet_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flush_packet_count) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_numbers_t),
            "::",
            stringify!(flush_packet_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).largest_jb_size) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_numbers_t),
            "::",
            stringify!(largest_jb_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_proc_time) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_numbers_t),
            "::",
            stringify!(last_proc_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).jitter_n) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_numbers_t),
            "::",
            stringify!(jitter_n)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).jitter_add) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_numbers_t),
            "::",
            stringify!(jitter_add)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).jitter_addsq) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_numbers_t),
            "::",
            stringify!(jitter_addsq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).variance) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_numbers_t),
            "::",
            stringify!(variance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_variance) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_numbers_t),
            "::",
            stringify!(min_variance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_variance) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_numbers_t),
            "::",
            stringify!(max_variance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).std_deviation) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_numbers_t),
            "::",
            stringify!(std_deviation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lossrate) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_numbers_t),
            "::",
            stringify!(lossrate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).burstrate) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_numbers_t),
            "::",
            stringify!(burstrate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mean_interval) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_numbers_t),
            "::",
            stringify!(mean_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loss) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_numbers_t),
            "::",
            stringify!(loss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_loss) as usize - ptr as usize },
        4272usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_numbers_t),
            "::",
            stringify!(last_loss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recved) as usize - ptr as usize },
        4276usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_numbers_t),
            "::",
            stringify!(recved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_processed_seq) as usize - ptr as usize },
        4280usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_numbers_t),
            "::",
            stringify!(last_processed_seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flaws) as usize - ptr as usize },
        4288usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_numbers_t),
            "::",
            stringify!(flaws)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_flaw) as usize - ptr as usize },
        4296usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_numbers_t),
            "::",
            stringify!(last_flaw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).R) as usize - ptr as usize },
        4304usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_numbers_t),
            "::",
            stringify!(R)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mos) as usize - ptr as usize },
        4312usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_numbers_t),
            "::",
            stringify!(mos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_log) as usize - ptr as usize },
        4320usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_numbers_t),
            "::",
            stringify!(error_log)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_rtcp_numbers_t {
    pub packet_count: u32,
    pub octet_count: u32,
    pub peer_ssrc: u32,
    pub last_rpt_ts: u32,
    pub ssrc: u32,
    pub csrc: u32,
    pub last_pkt_tsdiff: u32,
    pub inter_jitter: f64,
    pub last_rpt_ext_seq: u32,
    pub last_rpt_cycle: u16,
    pub period_pkt_count: u16,
    pub pkt_count: u16,
    pub sent_pkt_count: u16,
    pub rtcp_rtp_count: u32,
    pub high_ext_seq_recv: u32,
    pub cycle: u16,
    pub bad_seq: u32,
    pub base_seq: u16,
    pub cum_lost: u32,
    pub last_recv_lsr_local: u32,
    pub last_recv_lsr_peer: u32,
    pub init: u32,
}
#[test]
fn bindgen_test_layout_switch_rtcp_numbers_t() {
    const UNINIT: ::std::mem::MaybeUninit<switch_rtcp_numbers_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_rtcp_numbers_t>(),
        88usize,
        concat!("Size of: ", stringify!(switch_rtcp_numbers_t))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_rtcp_numbers_t>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_rtcp_numbers_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packet_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_numbers_t),
            "::",
            stringify!(packet_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).octet_count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_numbers_t),
            "::",
            stringify!(octet_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).peer_ssrc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_numbers_t),
            "::",
            stringify!(peer_ssrc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_rpt_ts) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_numbers_t),
            "::",
            stringify!(last_rpt_ts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ssrc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_numbers_t),
            "::",
            stringify!(ssrc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).csrc) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_numbers_t),
            "::",
            stringify!(csrc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_pkt_tsdiff) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_numbers_t),
            "::",
            stringify!(last_pkt_tsdiff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inter_jitter) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_numbers_t),
            "::",
            stringify!(inter_jitter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_rpt_ext_seq) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_numbers_t),
            "::",
            stringify!(last_rpt_ext_seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_rpt_cycle) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_numbers_t),
            "::",
            stringify!(last_rpt_cycle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).period_pkt_count) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_numbers_t),
            "::",
            stringify!(period_pkt_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pkt_count) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_numbers_t),
            "::",
            stringify!(pkt_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sent_pkt_count) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_numbers_t),
            "::",
            stringify!(sent_pkt_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rtcp_rtp_count) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_numbers_t),
            "::",
            stringify!(rtcp_rtp_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).high_ext_seq_recv) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_numbers_t),
            "::",
            stringify!(high_ext_seq_recv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cycle) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_numbers_t),
            "::",
            stringify!(cycle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bad_seq) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_numbers_t),
            "::",
            stringify!(bad_seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_seq) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_numbers_t),
            "::",
            stringify!(base_seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cum_lost) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_numbers_t),
            "::",
            stringify!(cum_lost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_recv_lsr_local) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_numbers_t),
            "::",
            stringify!(last_recv_lsr_local)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_recv_lsr_peer) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_numbers_t),
            "::",
            stringify!(last_recv_lsr_peer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_numbers_t),
            "::",
            stringify!(init)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_rtcp_video_counters_t {
    pub nack_count: u16,
    pub fir_count: u16,
    pub pli_count: u16,
    pub sr_count: u16,
    pub rr_count: u16,
}
#[test]
fn bindgen_test_layout_switch_rtcp_video_counters_t() {
    const UNINIT: ::std::mem::MaybeUninit<switch_rtcp_video_counters_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_rtcp_video_counters_t>(),
        10usize,
        concat!("Size of: ", stringify!(switch_rtcp_video_counters_t))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_rtcp_video_counters_t>(),
        2usize,
        concat!("Alignment of ", stringify!(switch_rtcp_video_counters_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nack_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_video_counters_t),
            "::",
            stringify!(nack_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fir_count) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_video_counters_t),
            "::",
            stringify!(fir_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pli_count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_video_counters_t),
            "::",
            stringify!(pli_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sr_count) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_video_counters_t),
            "::",
            stringify!(sr_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rr_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_video_counters_t),
            "::",
            stringify!(rr_count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_rtcp_video_stats_t {
    pub video_in: switch_rtcp_video_counters_t,
    pub video_out: switch_rtcp_video_counters_t,
}
#[test]
fn bindgen_test_layout_switch_rtcp_video_stats_t() {
    const UNINIT: ::std::mem::MaybeUninit<switch_rtcp_video_stats_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_rtcp_video_stats_t>(),
        20usize,
        concat!("Size of: ", stringify!(switch_rtcp_video_stats_t))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_rtcp_video_stats_t>(),
        2usize,
        concat!("Alignment of ", stringify!(switch_rtcp_video_stats_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).video_in) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_video_stats_t),
            "::",
            stringify!(video_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).video_out) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_video_stats_t),
            "::",
            stringify!(video_out)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_rtp_stats_t {
    pub inbound: switch_rtp_numbers_t,
    pub outbound: switch_rtp_numbers_t,
    pub rtcp: switch_rtcp_numbers_t,
    pub read_count: u32,
}
#[test]
fn bindgen_test_layout_switch_rtp_stats_t() {
    const UNINIT: ::std::mem::MaybeUninit<switch_rtp_stats_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_rtp_stats_t>(),
        8752usize,
        concat!("Size of: ", stringify!(switch_rtp_stats_t))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_rtp_stats_t>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_rtp_stats_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inbound) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_stats_t),
            "::",
            stringify!(inbound)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outbound) as usize - ptr as usize },
        4328usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_stats_t),
            "::",
            stringify!(outbound)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rtcp) as usize - ptr as usize },
        8656usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_stats_t),
            "::",
            stringify!(rtcp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_count) as usize - ptr as usize },
        8744usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_stats_t),
            "::",
            stringify!(read_count)
        )
    );
}
pub const switch_rtp_flush_t_SWITCH_RTP_FLUSH_ONCE: switch_rtp_flush_t = 0;
pub const switch_rtp_flush_t_SWITCH_RTP_FLUSH_STICK: switch_rtp_flush_t = 1;
pub const switch_rtp_flush_t_SWITCH_RTP_FLUSH_UNSTICK: switch_rtp_flush_t = 2;
pub type switch_rtp_flush_t = ::std::os::raw::c_uint;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_NOBLOCK: switch_rtp_flag_t = 0;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_DTMF_ON: switch_rtp_flag_t = 1;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_IO: switch_rtp_flag_t = 2;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_USE_TIMER: switch_rtp_flag_t = 3;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_RTCP_PASSTHRU: switch_rtp_flag_t = 4;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_SECURE_SEND: switch_rtp_flag_t = 5;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_SECURE_RECV: switch_rtp_flag_t = 6;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_AUTOADJ: switch_rtp_flag_t = 7;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_RTCP_AUTOADJ: switch_rtp_flag_t = 8;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_RAW_WRITE: switch_rtp_flag_t = 9;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_GOOGLEHACK: switch_rtp_flag_t = 10;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_VAD: switch_rtp_flag_t = 11;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_BREAK: switch_rtp_flag_t = 12;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_UDPTL: switch_rtp_flag_t = 13;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_DATAWAIT: switch_rtp_flag_t = 14;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_BYTESWAP: switch_rtp_flag_t = 15;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_PASS_RFC2833: switch_rtp_flag_t = 16;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_AUTO_CNG: switch_rtp_flag_t = 17;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_SECURE_SEND_RESET: switch_rtp_flag_t = 18;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_SECURE_RECV_RESET: switch_rtp_flag_t = 19;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_PROXY_MEDIA: switch_rtp_flag_t = 20;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_SHUTDOWN: switch_rtp_flag_t = 21;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_FLUSH: switch_rtp_flag_t = 22;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_AUTOFLUSH: switch_rtp_flag_t = 23;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_STICKY_FLUSH: switch_rtp_flag_t = 24;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_DEBUG_RTP_READ: switch_rtp_flag_t = 25;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_DEBUG_RTP_WRITE: switch_rtp_flag_t = 26;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_ESTIMATORS: switch_rtp_flag_t = 27;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_ADJ_BITRATE_CAP: switch_rtp_flag_t = 28;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_VIDEO: switch_rtp_flag_t = 29;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_ENABLE_RTCP: switch_rtp_flag_t = 30;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_RTCP_MUX: switch_rtp_flag_t = 31;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_KILL_JB: switch_rtp_flag_t = 32;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_VIDEO_BREAK: switch_rtp_flag_t = 33;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_PAUSE: switch_rtp_flag_t = 34;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_FIR: switch_rtp_flag_t = 35;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_PLI: switch_rtp_flag_t = 36;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_RESET: switch_rtp_flag_t = 37;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_MUTE: switch_rtp_flag_t = 38;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_NACK: switch_rtp_flag_t = 39;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_TMMBR: switch_rtp_flag_t = 40;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_DETECT_SSRC: switch_rtp_flag_t = 41;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_TEXT: switch_rtp_flag_t = 42;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_OLD_FIR: switch_rtp_flag_t = 43;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_PASSTHRU: switch_rtp_flag_t = 44;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_SECURE_SEND_MKI: switch_rtp_flag_t = 45;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_SECURE_RECV_MKI: switch_rtp_flag_t = 46;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_SRTP_HANGUP_ON_ERROR: switch_rtp_flag_t = 47;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_AUDIO_FIRE_SEND_RTCP_EVENT: switch_rtp_flag_t = 48;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_VIDEO_FIRE_SEND_RTCP_EVENT: switch_rtp_flag_t = 49;
pub const switch_rtp_flag_t_SWITCH_RTP_FLAG_INVALID: switch_rtp_flag_t = 50;
#[doc = "\\enum switch_rtp_flag_t\n\\brief RTP Related Flags\n<pre>\nSWITCH_RTP_FLAG_NOBLOCK       - Do not block\nSWITCH_RTP_FLAG_IO            - IO is ready\nSWITCH_RTP_FLAG_USE_TIMER     - Timeout Reads and replace with a CNG Frame\nSWITCH_RTP_FLAG_SECURE        - Secure RTP\nSWITCH_RTP_FLAG_AUTOADJ       - Auto-Adjust the dest based on the source\nSWITCH_RTP_FLAG_RAW_WRITE     - Try to forward packets unscathed\nSWITCH_RTP_FLAG_GOOGLEHACK    - Convert payload from 102 to 97\nSWITCH_RTP_FLAG_VAD           - Enable VAD\nSWITCH_RTP_FLAG_BREAK\t\t  - Stop what you are doing and return SWITCH_STATUS_BREAK\nSWITCH_RTP_FLAG_DATAWAIT\t  - Do not return from reads unless there is data even when non blocking\nSWITCH_RTP_FLAG_BUGGY_2833    - Emulate the bug in cisco equipment to allow interop\nSWITCH_RTP_FLAG_PASS_RFC2833  - Pass 2833 (ignore it)\nSWITCH_RTP_FLAG_AUTO_CNG      - Generate outbound CNG frames when idle\n</pre>"]
pub type switch_rtp_flag_t = ::std::os::raw::c_uint;
pub const switch_rtp_bug_flag_t_RTP_BUG_NONE: switch_rtp_bug_flag_t = 0;
pub const switch_rtp_bug_flag_t_RTP_BUG_CISCO_SKIP_MARK_BIT_2833: switch_rtp_bug_flag_t = 1;
pub const switch_rtp_bug_flag_t_RTP_BUG_SONUS_SEND_INVALID_TIMESTAMP_2833: switch_rtp_bug_flag_t =
    2;
pub const switch_rtp_bug_flag_t_RTP_BUG_IGNORE_MARK_BIT: switch_rtp_bug_flag_t = 4;
pub const switch_rtp_bug_flag_t_RTP_BUG_SEND_LINEAR_TIMESTAMPS: switch_rtp_bug_flag_t = 8;
pub const switch_rtp_bug_flag_t_RTP_BUG_START_SEQ_AT_ZERO: switch_rtp_bug_flag_t = 16;
pub const switch_rtp_bug_flag_t_RTP_BUG_NEVER_SEND_MARKER: switch_rtp_bug_flag_t = 32;
pub const switch_rtp_bug_flag_t_RTP_BUG_IGNORE_DTMF_DURATION: switch_rtp_bug_flag_t = 64;
pub const switch_rtp_bug_flag_t_RTP_BUG_ACCEPT_ANY_PACKETS: switch_rtp_bug_flag_t = 128;
pub const switch_rtp_bug_flag_t_RTP_BUG_GEN_ONE_GEN_ALL: switch_rtp_bug_flag_t = 256;
pub const switch_rtp_bug_flag_t_RTP_BUG_CHANGE_SSRC_ON_MARKER: switch_rtp_bug_flag_t = 512;
pub const switch_rtp_bug_flag_t_RTP_BUG_FLUSH_JB_ON_DTMF: switch_rtp_bug_flag_t = 1024;
pub const switch_rtp_bug_flag_t_RTP_BUG_ACCEPT_ANY_PAYLOAD: switch_rtp_bug_flag_t = 2048;
pub const switch_rtp_bug_flag_t_RTP_BUG_ALWAYS_AUTO_ADJUST: switch_rtp_bug_flag_t = 4096;
pub type switch_rtp_bug_flag_t = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct switch_rtp_hdr_t {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 12usize]>,
}
#[test]
fn bindgen_test_layout_switch_rtp_hdr_t() {
    assert_eq!(
        ::std::mem::size_of::<switch_rtp_hdr_t>(),
        12usize,
        concat!("Size of: ", stringify!(switch_rtp_hdr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_rtp_hdr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(switch_rtp_hdr_t))
    );
}
impl switch_rtp_hdr_t {
    #[inline]
    pub fn cc(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_cc(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn x(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn p(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_p(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn version(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_version(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn pt(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_pt(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn m(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_m(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn seq(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_seq(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn ts(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_ts(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn ssrc(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_ssrc(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cc: ::std::os::raw::c_uint,
        x: ::std::os::raw::c_uint,
        p: ::std::os::raw::c_uint,
        version: ::std::os::raw::c_uint,
        pt: ::std::os::raw::c_uint,
        m: ::std::os::raw::c_uint,
        seq: ::std::os::raw::c_uint,
        ts: ::std::os::raw::c_uint,
        ssrc: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 12usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 12usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let cc: u32 = unsafe { ::std::mem::transmute(cc) };
            cc as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let x: u32 = unsafe { ::std::mem::transmute(x) };
            x as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let p: u32 = unsafe { ::std::mem::transmute(p) };
            p as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let version: u32 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit.set(8usize, 7u8, {
            let pt: u32 = unsafe { ::std::mem::transmute(pt) };
            pt as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let m: u32 = unsafe { ::std::mem::transmute(m) };
            m as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let seq: u32 = unsafe { ::std::mem::transmute(seq) };
            seq as u64
        });
        __bindgen_bitfield_unit.set(32usize, 32u8, {
            let ts: u32 = unsafe { ::std::mem::transmute(ts) };
            ts as u64
        });
        __bindgen_bitfield_unit.set(64usize, 32u8, {
            let ssrc: u32 = unsafe { ::std::mem::transmute(ssrc) };
            ssrc as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct switch_rtp_hdr_ext_t {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_switch_rtp_hdr_ext_t() {
    assert_eq!(
        ::std::mem::size_of::<switch_rtp_hdr_ext_t>(),
        4usize,
        concat!("Size of: ", stringify!(switch_rtp_hdr_ext_t))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_rtp_hdr_ext_t>(),
        4usize,
        concat!("Alignment of ", stringify!(switch_rtp_hdr_ext_t))
    );
}
impl switch_rtp_hdr_ext_t {
    #[inline]
    pub fn profile(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_profile(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn length(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_length(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        profile: ::std::os::raw::c_uint,
        length: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let profile: u32 = unsafe { ::std::mem::transmute(profile) };
            profile as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let length: u32 = unsafe { ::std::mem::transmute(length) };
            length as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct switch_rtcp_hdr_s {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_switch_rtcp_hdr_s() {
    assert_eq!(
        ::std::mem::size_of::<switch_rtcp_hdr_s>(),
        4usize,
        concat!("Size of: ", stringify!(switch_rtcp_hdr_s))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_rtcp_hdr_s>(),
        4usize,
        concat!("Alignment of ", stringify!(switch_rtcp_hdr_s))
    );
}
impl switch_rtcp_hdr_s {
    #[inline]
    pub fn count(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_count(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn p(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_p(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn version(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_version(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn length(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_length(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        count: ::std::os::raw::c_uint,
        p: ::std::os::raw::c_uint,
        version: ::std::os::raw::c_uint,
        type_: ::std::os::raw::c_uint,
        length: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let count: u32 = unsafe { ::std::mem::transmute(count) };
            count as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let p: u32 = unsafe { ::std::mem::transmute(p) };
            p as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let version: u32 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let length: u32 = unsafe { ::std::mem::transmute(length) };
            length as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type switch_rtcp_hdr_t = switch_rtcp_hdr_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audio_buffer_header_s {
    pub ts: u32,
    pub len: u32,
}
#[test]
fn bindgen_test_layout_audio_buffer_header_s() {
    const UNINIT: ::std::mem::MaybeUninit<audio_buffer_header_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<audio_buffer_header_s>(),
        8usize,
        concat!("Size of: ", stringify!(audio_buffer_header_s))
    );
    assert_eq!(
        ::std::mem::align_of::<audio_buffer_header_s>(),
        4usize,
        concat!("Alignment of ", stringify!(audio_buffer_header_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ts) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(audio_buffer_header_s),
            "::",
            stringify!(ts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(audio_buffer_header_s),
            "::",
            stringify!(len)
        )
    );
}
pub type audio_buffer_header_t = audio_buffer_header_s;
pub const switch_priority_t_SWITCH_PRIORITY_NORMAL: switch_priority_t = 0;
pub const switch_priority_t_SWITCH_PRIORITY_LOW: switch_priority_t = 1;
pub const switch_priority_t_SWITCH_PRIORITY_HIGH: switch_priority_t = 2;
#[doc = "\\enum switch_priority_t\n\\brief Priority Indication\n<pre>\nSWITCH_PRIORITY_NORMAL  - Normal Priority\nSWITCH_PRIORITY_LOW     - Low Priority\nSWITCH_PRIORITY_HIGH    - High Priority\n</pre>"]
pub type switch_priority_t = ::std::os::raw::c_uint;
pub const switch_ivr_option_enum_t_SWITCH_IVR_OPTION_NONE: switch_ivr_option_enum_t = 0;
pub const switch_ivr_option_enum_t_SWITCH_IVR_OPTION_ASYNC: switch_ivr_option_enum_t = 1;
pub const switch_ivr_option_enum_t_SWITCH_IVR_OPTION_FILE: switch_ivr_option_enum_t = 2;
#[doc = "\\enum switch_ivr_option_t\n\\brief Possible options related to ivr functions\n<pre>\nSWITCH_IVR_OPTION_NONE  - nothing whatsoever\nSWITCH_IVR_OPTION_ASYNC - Asynchronous (do things in the background when applicable)\nSWITCH_IVR_OPTION_FILE  - string argument implies a filename\n</pre>"]
pub type switch_ivr_option_enum_t = ::std::os::raw::c_uint;
pub type switch_ivr_option_t = u32;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_REDIRECT_AUDIO:
    switch_core_session_message_types_t = 0;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_TRANSMIT_TEXT:
    switch_core_session_message_types_t = 1;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_ANSWER:
    switch_core_session_message_types_t = 2;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_ACKNOWLEDGE_CALL:
    switch_core_session_message_types_t = 3;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_PROGRESS:
    switch_core_session_message_types_t = 4;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_BRIDGE:
    switch_core_session_message_types_t = 5;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_UNBRIDGE:
    switch_core_session_message_types_t = 6;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_TRANSFER:
    switch_core_session_message_types_t = 7;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_RINGING:
    switch_core_session_message_types_t = 8;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_ALERTING:
    switch_core_session_message_types_t = 9;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_MEDIA:
    switch_core_session_message_types_t = 10;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_3P_MEDIA:
    switch_core_session_message_types_t = 11;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_NOMEDIA:
    switch_core_session_message_types_t = 12;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_3P_NOMEDIA:
    switch_core_session_message_types_t = 13;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_HOLD:
    switch_core_session_message_types_t = 14;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_UNHOLD:
    switch_core_session_message_types_t = 15;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_REDIRECT:
    switch_core_session_message_types_t = 16;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_RESPOND:
    switch_core_session_message_types_t = 17;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_BROADCAST:
    switch_core_session_message_types_t = 18;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_MEDIA_REDIRECT:
    switch_core_session_message_types_t = 19;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_DEFLECT:
    switch_core_session_message_types_t = 20;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_VIDEO_REFRESH_REQ:
    switch_core_session_message_types_t = 21;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_DISPLAY:
    switch_core_session_message_types_t = 22;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_MEDIA_PARAMS:
    switch_core_session_message_types_t = 23;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_TRANSCODING_NECESSARY:
    switch_core_session_message_types_t = 24;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_AUDIO_SYNC:
    switch_core_session_message_types_t = 25;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_VIDEO_SYNC:
    switch_core_session_message_types_t = 26;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_REQUEST_IMAGE_MEDIA:
    switch_core_session_message_types_t = 27;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_UUID_CHANGE:
    switch_core_session_message_types_t = 28;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_SIMPLIFY:
    switch_core_session_message_types_t = 29;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_DEBUG_MEDIA:
    switch_core_session_message_types_t = 30;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_PROXY_MEDIA:
    switch_core_session_message_types_t = 31;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_APPLICATION_EXEC:
    switch_core_session_message_types_t = 32;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_APPLICATION_EXEC_COMPLETE:
    switch_core_session_message_types_t = 33;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_PHONE_EVENT:
    switch_core_session_message_types_t = 34;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_T38_DESCRIPTION:
    switch_core_session_message_types_t = 35;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_UDPTL_MODE:
    switch_core_session_message_types_t = 36;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_CLEAR_PROGRESS:
    switch_core_session_message_types_t = 37;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_JITTER_BUFFER:
    switch_core_session_message_types_t = 38;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_RECOVERY_REFRESH:
    switch_core_session_message_types_t = 39;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_SIGNAL_DATA:
    switch_core_session_message_types_t = 40;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_MESSAGE:
    switch_core_session_message_types_t = 41;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_INFO:
    switch_core_session_message_types_t = 42;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_AUDIO_DATA:
    switch_core_session_message_types_t = 43;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_BLIND_TRANSFER_RESPONSE:
    switch_core_session_message_types_t = 44;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_STUN_ERROR:
    switch_core_session_message_types_t = 45;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_MEDIA_RENEG:
    switch_core_session_message_types_t = 46;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_KEEPALIVE:
    switch_core_session_message_types_t = 47;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_HARD_MUTE:
    switch_core_session_message_types_t = 48;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_BITRATE_REQ:
    switch_core_session_message_types_t = 49;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_BITRATE_ACK:
    switch_core_session_message_types_t = 50;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_CODEC_DEBUG_REQ:
    switch_core_session_message_types_t = 51;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_CODEC_SPECIFIC_REQ:
    switch_core_session_message_types_t = 52;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_REFER_EVENT:
    switch_core_session_message_types_t = 53;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_ANSWER_EVENT:
    switch_core_session_message_types_t = 54;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_PROGRESS_EVENT:
    switch_core_session_message_types_t = 55;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_RING_EVENT:
    switch_core_session_message_types_t = 56;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_RESAMPLE_EVENT:
    switch_core_session_message_types_t = 57;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_HEARTBEAT_EVENT:
    switch_core_session_message_types_t = 58;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_SESSION_ID:
    switch_core_session_message_types_t = 59;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INDICATE_PROMPT:
    switch_core_session_message_types_t = 60;
pub const switch_core_session_message_types_t_SWITCH_MESSAGE_INVALID:
    switch_core_session_message_types_t = 61;
#[doc = "\\enum switch_core_session_message_types_t\n\\brief Possible types of messages for inter-session communication\n<pre>\nSWITCH_MESSAGE_REDIRECT_AUDIO     - Indication to redirect audio to another location if possible\nSWITCH_MESSAGE_TRANSMIT_TEXT      - A text message\nSWITCH_MESSAGE_INDICATE_ANSWER    - indicate answer\nSWITCH_MESSAGE_INDICATE_PROGRESS  - indicate progress\nSWITCH_MESSAGE_INDICATE_BRIDGE    - indicate a bridge starting\nSWITCH_MESSAGE_INDICATE_UNBRIDGE  - indicate a bridge ending\nSWITCH_MESSAGE_INDICATE_TRANSFER  - indicate a transfer is taking place\nSWITCH_MESSAGE_INDICATE_MEDIA\t  - indicate media is required\nSWITCH_MESSAGE_INDICATE_NOMEDIA\t  - indicate no-media is required\nSWITCH_MESSAGE_INDICATE_HOLD      - indicate hold\nSWITCH_MESSAGE_INDICATE_UNHOLD    - indicate unhold\nSWITCH_MESSAGE_INDICATE_REDIRECT  - indicate redirect\nSWITCH_MESSAGE_INDICATE_RESPOND    - indicate reject\nSWITCH_MESSAGE_INDICATE_BROADCAST - indicate media broadcast\nSWITCH_MESSAGE_INDICATE_MEDIA_REDIRECT - indicate media broadcast\nSWITCH_MESSAGE_INDICATE_DEFLECT - indicate deflect\nSWITCH_MESSAGE_INDICATE_VIDEO_REFRESH_REQ - indicate video refresh request\n</pre>"]
pub type switch_core_session_message_types_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_t38_options_t {
    pub T38FaxVersion: u16,
    pub T38MaxBitRate: u32,
    pub T38FaxFillBitRemoval: switch_bool_t,
    pub T38FaxTranscodingMMR: switch_bool_t,
    pub T38FaxTranscodingJBIG: switch_bool_t,
    pub T38FaxRateManagement: *const ::std::os::raw::c_char,
    pub T38FaxMaxBuffer: u32,
    pub T38FaxMaxDatagram: u32,
    pub T38FaxUdpEC: *const ::std::os::raw::c_char,
    pub T38VendorInfo: *const ::std::os::raw::c_char,
    pub remote_ip: *const ::std::os::raw::c_char,
    pub remote_port: u16,
    pub local_ip: *const ::std::os::raw::c_char,
    pub local_port: u16,
    pub sdp_o_line: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_switch_t38_options_t() {
    const UNINIT: ::std::mem::MaybeUninit<switch_t38_options_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_t38_options_t>(),
        96usize,
        concat!("Size of: ", stringify!(switch_t38_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_t38_options_t>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_t38_options_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).T38FaxVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_t38_options_t),
            "::",
            stringify!(T38FaxVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).T38MaxBitRate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_t38_options_t),
            "::",
            stringify!(T38MaxBitRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).T38FaxFillBitRemoval) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_t38_options_t),
            "::",
            stringify!(T38FaxFillBitRemoval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).T38FaxTranscodingMMR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_t38_options_t),
            "::",
            stringify!(T38FaxTranscodingMMR)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).T38FaxTranscodingJBIG) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_t38_options_t),
            "::",
            stringify!(T38FaxTranscodingJBIG)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).T38FaxRateManagement) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_t38_options_t),
            "::",
            stringify!(T38FaxRateManagement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).T38FaxMaxBuffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_t38_options_t),
            "::",
            stringify!(T38FaxMaxBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).T38FaxMaxDatagram) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_t38_options_t),
            "::",
            stringify!(T38FaxMaxDatagram)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).T38FaxUdpEC) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_t38_options_t),
            "::",
            stringify!(T38FaxUdpEC)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).T38VendorInfo) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_t38_options_t),
            "::",
            stringify!(T38VendorInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_ip) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_t38_options_t),
            "::",
            stringify!(remote_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_port) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_t38_options_t),
            "::",
            stringify!(remote_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_ip) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_t38_options_t),
            "::",
            stringify!(local_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_port) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_t38_options_t),
            "::",
            stringify!(local_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sdp_o_line) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_t38_options_t),
            "::",
            stringify!(sdp_o_line)
        )
    );
}
pub const switch_stack_t_SWITCH_STACK_BOTTOM: switch_stack_t = 1;
pub const switch_stack_t_SWITCH_STACK_TOP: switch_stack_t = 2;
pub const switch_stack_t_SWITCH_STACK_UNSHIFT: switch_stack_t = 4;
pub const switch_stack_t_SWITCH_STACK_PUSH: switch_stack_t = 8;
#[doc = "\\enum switch_stack_t\n\\brief Expression of how to stack a list\n<pre>\nSWITCH_STACK_BOTTOM - Stack on the bottom\nSWITCH_STACK_TOP\t- Stack on the top\n</pre>"]
pub type switch_stack_t = ::std::os::raw::c_uint;
pub const switch_status_t_SWITCH_STATUS_SUCCESS: switch_status_t = 0;
pub const switch_status_t_SWITCH_STATUS_FALSE: switch_status_t = 1;
pub const switch_status_t_SWITCH_STATUS_TIMEOUT: switch_status_t = 2;
pub const switch_status_t_SWITCH_STATUS_RESTART: switch_status_t = 3;
pub const switch_status_t_SWITCH_STATUS_INTR: switch_status_t = 4;
pub const switch_status_t_SWITCH_STATUS_NOTIMPL: switch_status_t = 5;
pub const switch_status_t_SWITCH_STATUS_MEMERR: switch_status_t = 6;
pub const switch_status_t_SWITCH_STATUS_NOOP: switch_status_t = 7;
pub const switch_status_t_SWITCH_STATUS_RESAMPLE: switch_status_t = 8;
pub const switch_status_t_SWITCH_STATUS_GENERR: switch_status_t = 9;
pub const switch_status_t_SWITCH_STATUS_INUSE: switch_status_t = 10;
pub const switch_status_t_SWITCH_STATUS_BREAK: switch_status_t = 11;
pub const switch_status_t_SWITCH_STATUS_SOCKERR: switch_status_t = 12;
pub const switch_status_t_SWITCH_STATUS_MORE_DATA: switch_status_t = 13;
pub const switch_status_t_SWITCH_STATUS_NOTFOUND: switch_status_t = 14;
pub const switch_status_t_SWITCH_STATUS_UNLOAD: switch_status_t = 15;
pub const switch_status_t_SWITCH_STATUS_NOUNLOAD: switch_status_t = 16;
pub const switch_status_t_SWITCH_STATUS_IGNORE: switch_status_t = 17;
pub const switch_status_t_SWITCH_STATUS_TOO_SMALL: switch_status_t = 18;
pub const switch_status_t_SWITCH_STATUS_FOUND: switch_status_t = 19;
pub const switch_status_t_SWITCH_STATUS_CONTINUE: switch_status_t = 20;
pub const switch_status_t_SWITCH_STATUS_TERM: switch_status_t = 21;
pub const switch_status_t_SWITCH_STATUS_NOT_INITALIZED: switch_status_t = 22;
pub const switch_status_t_SWITCH_STATUS_TOO_LATE: switch_status_t = 23;
pub const switch_status_t_SWITCH_STATUS_XBREAK: switch_status_t = 35;
pub const switch_status_t_SWITCH_STATUS_WINBREAK: switch_status_t = 730035;
#[doc = "\\enum switch_status_t\n\\brief Common return values\n<pre>\nSWITCH_STATUS_SUCCESS\t- General Success (common return value for most functions)\nSWITCH_STATUS_FALSE\t\t- General Falsehood\nSWITCH_STATUS_TIMEOUT\t- A Timeout has occured\nSWITCH_STATUS_RESTART\t- An indication to restart the previous operation\nSWITCH_STATUS_TERM\t\t- An indication to terminate\nSWITCH_STATUS_NOTIMPL\t- An indication that requested resource is not impelemented\nSWITCH_STATUS_MEMERR\t- General memory error\nSWITCH_STATUS_NOOP\t\t- NOTHING\nSWITCH_STATUS_RESAMPLE\t- An indication that a resample has occured\nSWITCH_STATUS_GENERR\t- A general Error\nSWITCH_STATUS_INUSE\t\t- An indication that requested resource is in use\nSWITCH_STATUS_BREAK     - A non-fatal break of an operation\nSWITCH_STATUS_SOCKERR   - A socket error\nSWITCH_STATUS_MORE_DATA - Need More Data\nSWITCH_STATUS_NOTFOUND  - Not Found\nSWITCH_STATUS_UNLOAD    - Unload\nSWITCH_STATUS_NOUNLOAD  - Never Unload\n</pre>"]
pub type switch_status_t = ::std::os::raw::c_uint;
pub const switch_log_level_t_SWITCH_LOG_DEBUG10: switch_log_level_t = 110;
pub const switch_log_level_t_SWITCH_LOG_DEBUG9: switch_log_level_t = 109;
pub const switch_log_level_t_SWITCH_LOG_DEBUG8: switch_log_level_t = 108;
pub const switch_log_level_t_SWITCH_LOG_DEBUG7: switch_log_level_t = 107;
pub const switch_log_level_t_SWITCH_LOG_DEBUG6: switch_log_level_t = 106;
pub const switch_log_level_t_SWITCH_LOG_DEBUG5: switch_log_level_t = 105;
pub const switch_log_level_t_SWITCH_LOG_DEBUG4: switch_log_level_t = 104;
pub const switch_log_level_t_SWITCH_LOG_DEBUG3: switch_log_level_t = 103;
pub const switch_log_level_t_SWITCH_LOG_DEBUG2: switch_log_level_t = 102;
pub const switch_log_level_t_SWITCH_LOG_DEBUG1: switch_log_level_t = 101;
pub const switch_log_level_t_SWITCH_LOG_DEBUG: switch_log_level_t = 7;
pub const switch_log_level_t_SWITCH_LOG_INFO: switch_log_level_t = 6;
pub const switch_log_level_t_SWITCH_LOG_NOTICE: switch_log_level_t = 5;
pub const switch_log_level_t_SWITCH_LOG_WARNING: switch_log_level_t = 4;
pub const switch_log_level_t_SWITCH_LOG_ERROR: switch_log_level_t = 3;
pub const switch_log_level_t_SWITCH_LOG_CRIT: switch_log_level_t = 2;
pub const switch_log_level_t_SWITCH_LOG_ALERT: switch_log_level_t = 1;
pub const switch_log_level_t_SWITCH_LOG_CONSOLE: switch_log_level_t = 0;
pub const switch_log_level_t_SWITCH_LOG_DISABLE: switch_log_level_t = -1;
pub const switch_log_level_t_SWITCH_LOG_INVALID: switch_log_level_t = 64;
pub const switch_log_level_t_SWITCH_LOG_UNINIT: switch_log_level_t = 1000;
#[doc = "\\enum switch_log_level_t\n\\brief Log Level Enumeration\n<pre>\nSWITCH_LOG_DEBUG            - Debug\nSWITCH_LOG_INFO             - Info\nSWITCH_LOG_NOTICE           - Notice\nSWITCH_LOG_WARNING          - Warning\nSWITCH_LOG_ERROR            - Error\nSWITCH_LOG_CRIT             - Critical\nSWITCH_LOG_ALERT            - Alert\nSWITCH_LOG_CONSOLE          - Console\n</pre>"]
pub type switch_log_level_t = ::std::os::raw::c_int;
pub const switch_text_channel_t_SWITCH_CHANNEL_ID_LOG: switch_text_channel_t = 0;
pub const switch_text_channel_t_SWITCH_CHANNEL_ID_LOG_CLEAN: switch_text_channel_t = 1;
pub const switch_text_channel_t_SWITCH_CHANNEL_ID_EVENT: switch_text_channel_t = 2;
pub const switch_text_channel_t_SWITCH_CHANNEL_ID_SESSION: switch_text_channel_t = 3;
#[doc = "\\enum switch_text_channel_t\n\\brief A target to write log/debug info to\n<pre>\nSWITCH_CHANNEL_ID_LOG\t\t\t- Write to the currently defined log\nSWITCH_CHANNEL_ID_LOG_CLEAN\t\t- Write to the currently defined log with no extra file/line/date information\nSWITCH_CHANNEL_ID_EVENT\t\t\t- Write to the event engine as a LOG event\n</pre>"]
pub type switch_text_channel_t = ::std::os::raw::c_uint;
pub const switch_core_session_message_flag_enum_t_SCSMF_DYNAMIC:
    switch_core_session_message_flag_enum_t = 1;
pub const switch_core_session_message_flag_enum_t_SCSMF_FREE_STRING_REPLY:
    switch_core_session_message_flag_enum_t = 2;
pub const switch_core_session_message_flag_enum_t_SCSMF_FREE_POINTER_REPLY:
    switch_core_session_message_flag_enum_t = 4;
pub type switch_core_session_message_flag_enum_t = ::std::os::raw::c_uint;
pub type switch_core_session_message_flag_t = u32;
#[doc = " \\brief A core session representing a call and all of it's resources"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_core_session {
    _unused: [u8; 0],
}
pub type switch_core_session_t = switch_core_session;
pub const switch_channel_callstate_t_CCS_DOWN: switch_channel_callstate_t = 0;
pub const switch_channel_callstate_t_CCS_DIALING: switch_channel_callstate_t = 1;
pub const switch_channel_callstate_t_CCS_RINGING: switch_channel_callstate_t = 2;
pub const switch_channel_callstate_t_CCS_EARLY: switch_channel_callstate_t = 3;
pub const switch_channel_callstate_t_CCS_ACTIVE: switch_channel_callstate_t = 4;
pub const switch_channel_callstate_t_CCS_HELD: switch_channel_callstate_t = 5;
pub const switch_channel_callstate_t_CCS_RING_WAIT: switch_channel_callstate_t = 6;
pub const switch_channel_callstate_t_CCS_HANGUP: switch_channel_callstate_t = 7;
pub const switch_channel_callstate_t_CCS_UNHELD: switch_channel_callstate_t = 8;
pub type switch_channel_callstate_t = ::std::os::raw::c_uint;
pub const switch_device_state_t_SDS_DOWN: switch_device_state_t = 0;
pub const switch_device_state_t_SDS_RINGING: switch_device_state_t = 1;
pub const switch_device_state_t_SDS_ACTIVE: switch_device_state_t = 2;
pub const switch_device_state_t_SDS_ACTIVE_MULTI: switch_device_state_t = 3;
pub const switch_device_state_t_SDS_HELD: switch_device_state_t = 4;
pub const switch_device_state_t_SDS_UNHELD: switch_device_state_t = 5;
pub const switch_device_state_t_SDS_HANGUP: switch_device_state_t = 6;
pub type switch_device_state_t = ::std::os::raw::c_uint;
pub const switch_channel_state_t_CS_NEW: switch_channel_state_t = 0;
pub const switch_channel_state_t_CS_INIT: switch_channel_state_t = 1;
pub const switch_channel_state_t_CS_ROUTING: switch_channel_state_t = 2;
pub const switch_channel_state_t_CS_SOFT_EXECUTE: switch_channel_state_t = 3;
pub const switch_channel_state_t_CS_EXECUTE: switch_channel_state_t = 4;
pub const switch_channel_state_t_CS_EXCHANGE_MEDIA: switch_channel_state_t = 5;
pub const switch_channel_state_t_CS_PARK: switch_channel_state_t = 6;
pub const switch_channel_state_t_CS_CONSUME_MEDIA: switch_channel_state_t = 7;
pub const switch_channel_state_t_CS_HIBERNATE: switch_channel_state_t = 8;
pub const switch_channel_state_t_CS_RESET: switch_channel_state_t = 9;
pub const switch_channel_state_t_CS_HANGUP: switch_channel_state_t = 10;
pub const switch_channel_state_t_CS_REPORTING: switch_channel_state_t = 11;
pub const switch_channel_state_t_CS_DESTROY: switch_channel_state_t = 12;
pub const switch_channel_state_t_CS_NONE: switch_channel_state_t = 13;
#[doc = "\\enum switch_channel_state_t\n\\brief Channel States (these are the defaults, CS_SOFT_EXECUTE, CS_EXCHANGE_MEDIA, and CS_CONSUME_MEDIA are often overridden by specific apps)\n<pre>\nCS_NEW       - Channel is newly created.\nCS_INIT      - Channel has been initialized.\nCS_ROUTING   - Channel is looking for an extension to execute.\nCS_SOFT_EXECUTE  - Channel is ready to execute from 3rd party control.\nCS_EXECUTE   - Channel is executing it's dialplan.\nCS_EXCHANGE_MEDIA  - Channel is exchanging media with another channel.\nCS_PARK      - Channel is accepting media awaiting commands.\nCS_CONSUME_MEDIA\t\t - Channel is consuming all media and dropping it.\nCS_HIBERNATE - Channel is in a sleep state.\nCS_RESET \t - Channel is in a reset state.\nCS_HANGUP    - Channel is flagged for hangup and ready to end.\nCS_REPORTING - Channel is ready to collect call detail.\nCS_DESTROY      - Channel is ready to be destroyed and out of the state machine.\n</pre>"]
pub type switch_channel_state_t = ::std::os::raw::c_uint;
pub const switch_ring_ready_t_SWITCH_RING_READY_NONE: switch_ring_ready_t = 0;
pub const switch_ring_ready_t_SWITCH_RING_READY_RINGING: switch_ring_ready_t = 1;
pub const switch_ring_ready_t_SWITCH_RING_READY_QUEUED: switch_ring_ready_t = 2;
pub type switch_ring_ready_t = ::std::os::raw::c_uint;
pub const switch_channel_cap_t_CC_MEDIA_ACK: switch_channel_cap_t = 1;
pub const switch_channel_cap_t_CC_BYPASS_MEDIA: switch_channel_cap_t = 2;
pub const switch_channel_cap_t_CC_PROXY_MEDIA: switch_channel_cap_t = 3;
pub const switch_channel_cap_t_CC_JITTERBUFFER: switch_channel_cap_t = 4;
pub const switch_channel_cap_t_CC_FS_RTP: switch_channel_cap_t = 5;
pub const switch_channel_cap_t_CC_QUEUEABLE_DTMF_DELAY: switch_channel_cap_t = 6;
pub const switch_channel_cap_t_CC_IO_OVERRIDE: switch_channel_cap_t = 7;
pub const switch_channel_cap_t_CC_RTP_RTT: switch_channel_cap_t = 8;
pub const switch_channel_cap_t_CC_MSRP: switch_channel_cap_t = 9;
pub const switch_channel_cap_t_CC_MUTE_VIA_MEDIA_STREAM: switch_channel_cap_t = 10;
pub const switch_channel_cap_t_CC_FLAG_MAX: switch_channel_cap_t = 11;
#[doc = "\\enum switch_channel_flag_t\n\\brief Channel Flags\n\n<pre>\nCF_ANSWERED\t\t\t- Channel is answered\nCF_OUTBOUND\t\t\t- Channel is an outbound channel\nCF_EARLY_MEDIA\t\t- Channel is ready for audio before answer\nCF_ORIGINATOR\t\t- Channel is an originator\nCF_TRANSFER\t\t\t- Channel is being transfered\nCF_ACCEPT_CNG\t\t- Channel will accept CNG frames\nCF_REDIRECT \t\t- Channel is being redirected\nCF_BRIDGED\t\t\t- Channel in a bridge\nCF_HOLD\t\t\t\t- Channel is on hold\nCF_HOLD_BLEG        - B leg is on hold\nCF_SERVICE\t\t\t- Channel has a service thread\nCF_TAGGED\t\t\t- Channel is tagged\nCF_WINNER\t\t\t- Channel is the winner\nCF_REUSE_CALLER_PROFILE - Channel reuse caller profile\nCF_CONTROLLED\t\t- Channel is under control\nCF_PROXY_MODE\t\t- Channel has no media\nCF_SUSPEND\t\t\t- Suspend i/o\nCF_EVENT_PARSE\t\t- Suspend control events\nCF_GEN_RINGBACK\t\t- Channel is generating it's own ringback\nCF_RING_READY\t\t- Channel is ready to send ringback\nCF_BREAK\t\t\t- Channel should stop what it's doing\nCF_BROADCAST\t\t- Channel is broadcasting\nCF_UNICAST\t\t\t- Channel has a unicast connection\nCF_VIDEO\t\t\t- Channel has video\nCF_EVENT_LOCK\t\t- Don't parse events\nCF_RESET\t\t\t- Tell extension parser to reset\nCF_ORIGINATING\t\t- Channel is originating\nCF_STOP_BROADCAST\t- Signal to stop broadcast\n\nCF_AUDIO_PAUSE      - Audio is not ready to read/write\nCF_VIDEO_PAUSE      - Video is not ready to read/write\n\nCF_MEDIA_SET        - Session has read codec assigned\n\n</pre>"]
pub type switch_channel_cap_t = ::std::os::raw::c_uint;
pub const switch_channel_flag_t_CF_ANSWERED: switch_channel_flag_t = 1;
pub const switch_channel_flag_t_CF_OUTBOUND: switch_channel_flag_t = 2;
pub const switch_channel_flag_t_CF_EARLY_MEDIA: switch_channel_flag_t = 3;
pub const switch_channel_flag_t_CF_BRIDGE_ORIGINATOR: switch_channel_flag_t = 4;
pub const switch_channel_flag_t_CF_UUID_BRIDGE_ORIGINATOR: switch_channel_flag_t = 5;
pub const switch_channel_flag_t_CF_TRANSFER: switch_channel_flag_t = 6;
pub const switch_channel_flag_t_CF_ACCEPT_CNG: switch_channel_flag_t = 7;
pub const switch_channel_flag_t_CF_REDIRECT: switch_channel_flag_t = 8;
pub const switch_channel_flag_t_CF_BRIDGED: switch_channel_flag_t = 9;
pub const switch_channel_flag_t_CF_HOLD: switch_channel_flag_t = 10;
pub const switch_channel_flag_t_CF_HOLD_BLEG: switch_channel_flag_t = 11;
pub const switch_channel_flag_t_CF_SERVICE: switch_channel_flag_t = 12;
pub const switch_channel_flag_t_CF_TAGGED: switch_channel_flag_t = 13;
pub const switch_channel_flag_t_CF_WINNER: switch_channel_flag_t = 14;
pub const switch_channel_flag_t_CF_REUSE_CALLER_PROFILE: switch_channel_flag_t = 15;
pub const switch_channel_flag_t_CF_CONTROLLED: switch_channel_flag_t = 16;
pub const switch_channel_flag_t_CF_PROXY_MODE: switch_channel_flag_t = 17;
pub const switch_channel_flag_t_CF_PROXY_OFF: switch_channel_flag_t = 18;
pub const switch_channel_flag_t_CF_SUSPEND: switch_channel_flag_t = 19;
pub const switch_channel_flag_t_CF_EVENT_PARSE: switch_channel_flag_t = 20;
pub const switch_channel_flag_t_CF_GEN_RINGBACK: switch_channel_flag_t = 21;
pub const switch_channel_flag_t_CF_RING_READY: switch_channel_flag_t = 22;
pub const switch_channel_flag_t_CF_BREAK: switch_channel_flag_t = 23;
pub const switch_channel_flag_t_CF_BROADCAST: switch_channel_flag_t = 24;
pub const switch_channel_flag_t_CF_UNICAST: switch_channel_flag_t = 25;
pub const switch_channel_flag_t_CF_VIDEO: switch_channel_flag_t = 26;
pub const switch_channel_flag_t_CF_EVENT_LOCK: switch_channel_flag_t = 27;
pub const switch_channel_flag_t_CF_EVENT_LOCK_PRI: switch_channel_flag_t = 28;
pub const switch_channel_flag_t_CF_RESET: switch_channel_flag_t = 29;
pub const switch_channel_flag_t_CF_ORIGINATING: switch_channel_flag_t = 30;
pub const switch_channel_flag_t_CF_STOP_BROADCAST: switch_channel_flag_t = 31;
pub const switch_channel_flag_t_CF_PROXY_MEDIA: switch_channel_flag_t = 32;
pub const switch_channel_flag_t_CF_INNER_BRIDGE: switch_channel_flag_t = 33;
pub const switch_channel_flag_t_CF_REQ_MEDIA: switch_channel_flag_t = 34;
pub const switch_channel_flag_t_CF_VERBOSE_EVENTS: switch_channel_flag_t = 35;
pub const switch_channel_flag_t_CF_PAUSE_BUGS: switch_channel_flag_t = 36;
pub const switch_channel_flag_t_CF_DIVERT_EVENTS: switch_channel_flag_t = 37;
pub const switch_channel_flag_t_CF_BLOCK_STATE: switch_channel_flag_t = 38;
pub const switch_channel_flag_t_CF_FS_RTP: switch_channel_flag_t = 39;
pub const switch_channel_flag_t_CF_REPORTING: switch_channel_flag_t = 40;
pub const switch_channel_flag_t_CF_PARK: switch_channel_flag_t = 41;
pub const switch_channel_flag_t_CF_TIMESTAMP_SET: switch_channel_flag_t = 42;
pub const switch_channel_flag_t_CF_ORIGINATOR: switch_channel_flag_t = 43;
pub const switch_channel_flag_t_CF_XFER_ZOMBIE: switch_channel_flag_t = 44;
pub const switch_channel_flag_t_CF_MEDIA_ACK: switch_channel_flag_t = 45;
pub const switch_channel_flag_t_CF_THREAD_SLEEPING: switch_channel_flag_t = 46;
pub const switch_channel_flag_t_CF_DISABLE_RINGBACK: switch_channel_flag_t = 47;
pub const switch_channel_flag_t_CF_NOT_READY: switch_channel_flag_t = 48;
pub const switch_channel_flag_t_CF_SIGNAL_BRIDGE_TTL: switch_channel_flag_t = 49;
pub const switch_channel_flag_t_CF_MEDIA_BRIDGE_TTL: switch_channel_flag_t = 50;
pub const switch_channel_flag_t_CF_BYPASS_MEDIA_AFTER_BRIDGE: switch_channel_flag_t = 51;
pub const switch_channel_flag_t_CF_LEG_HOLDING: switch_channel_flag_t = 52;
pub const switch_channel_flag_t_CF_BROADCAST_DROP_MEDIA: switch_channel_flag_t = 53;
pub const switch_channel_flag_t_CF_EARLY_HANGUP: switch_channel_flag_t = 54;
pub const switch_channel_flag_t_CF_MEDIA_SET: switch_channel_flag_t = 55;
pub const switch_channel_flag_t_CF_CONSUME_ON_ORIGINATE: switch_channel_flag_t = 56;
pub const switch_channel_flag_t_CF_PASSTHRU_PTIME_MISMATCH: switch_channel_flag_t = 57;
pub const switch_channel_flag_t_CF_BRIDGE_NOWRITE: switch_channel_flag_t = 58;
pub const switch_channel_flag_t_CF_RECOVERED: switch_channel_flag_t = 59;
pub const switch_channel_flag_t_CF_JITTERBUFFER: switch_channel_flag_t = 60;
pub const switch_channel_flag_t_CF_JITTERBUFFER_PLC: switch_channel_flag_t = 61;
pub const switch_channel_flag_t_CF_DIALPLAN: switch_channel_flag_t = 62;
pub const switch_channel_flag_t_CF_BLEG: switch_channel_flag_t = 63;
pub const switch_channel_flag_t_CF_BLOCK_BROADCAST_UNTIL_MEDIA: switch_channel_flag_t = 64;
pub const switch_channel_flag_t_CF_CNG_PLC: switch_channel_flag_t = 65;
pub const switch_channel_flag_t_CF_ATTENDED_TRANSFER: switch_channel_flag_t = 66;
pub const switch_channel_flag_t_CF_LAZY_ATTENDED_TRANSFER: switch_channel_flag_t = 67;
pub const switch_channel_flag_t_CF_SIGNAL_DATA: switch_channel_flag_t = 68;
pub const switch_channel_flag_t_CF_SIMPLIFY: switch_channel_flag_t = 69;
pub const switch_channel_flag_t_CF_ZOMBIE_EXEC: switch_channel_flag_t = 70;
pub const switch_channel_flag_t_CF_INTERCEPT: switch_channel_flag_t = 71;
pub const switch_channel_flag_t_CF_INTERCEPTED: switch_channel_flag_t = 72;
pub const switch_channel_flag_t_CF_VIDEO_REFRESH_REQ: switch_channel_flag_t = 73;
pub const switch_channel_flag_t_CF_MANUAL_VID_REFRESH: switch_channel_flag_t = 74;
pub const switch_channel_flag_t_CF_MANUAL_MEDIA_PARAMS: switch_channel_flag_t = 75;
pub const switch_channel_flag_t_CF_SERVICE_AUDIO: switch_channel_flag_t = 76;
pub const switch_channel_flag_t_CF_SERVICE_VIDEO: switch_channel_flag_t = 77;
pub const switch_channel_flag_t_CF_CHANNEL_SWAP: switch_channel_flag_t = 78;
pub const switch_channel_flag_t_CF_DEVICE_LEG: switch_channel_flag_t = 79;
pub const switch_channel_flag_t_CF_FINAL_DEVICE_LEG: switch_channel_flag_t = 80;
pub const switch_channel_flag_t_CF_PICKUP: switch_channel_flag_t = 81;
pub const switch_channel_flag_t_CF_CONFIRM_BLIND_TRANSFER: switch_channel_flag_t = 82;
pub const switch_channel_flag_t_CF_NO_PRESENCE: switch_channel_flag_t = 83;
pub const switch_channel_flag_t_CF_CONFERENCE: switch_channel_flag_t = 84;
pub const switch_channel_flag_t_CF_CONFERENCE_ADV: switch_channel_flag_t = 85;
pub const switch_channel_flag_t_CF_RECOVERING: switch_channel_flag_t = 86;
pub const switch_channel_flag_t_CF_RECOVERING_BRIDGE: switch_channel_flag_t = 87;
pub const switch_channel_flag_t_CF_TRACKED: switch_channel_flag_t = 88;
pub const switch_channel_flag_t_CF_TRACKABLE: switch_channel_flag_t = 89;
pub const switch_channel_flag_t_CF_NO_CDR: switch_channel_flag_t = 90;
pub const switch_channel_flag_t_CF_EARLY_OK: switch_channel_flag_t = 91;
pub const switch_channel_flag_t_CF_MEDIA_TRANS: switch_channel_flag_t = 92;
pub const switch_channel_flag_t_CF_HOLD_ON_BRIDGE: switch_channel_flag_t = 93;
pub const switch_channel_flag_t_CF_SECURE: switch_channel_flag_t = 94;
pub const switch_channel_flag_t_CF_LIBERAL_DTMF: switch_channel_flag_t = 95;
pub const switch_channel_flag_t_CF_SLA_BARGE: switch_channel_flag_t = 96;
pub const switch_channel_flag_t_CF_SLA_BARGING: switch_channel_flag_t = 97;
pub const switch_channel_flag_t_CF_PROTO_HOLD: switch_channel_flag_t = 98;
pub const switch_channel_flag_t_CF_HOLD_LOCK: switch_channel_flag_t = 99;
pub const switch_channel_flag_t_CF_VIDEO_POSSIBLE: switch_channel_flag_t = 100;
pub const switch_channel_flag_t_CF_NOTIMER_DURING_BRIDGE: switch_channel_flag_t = 101;
pub const switch_channel_flag_t_CF_PASS_RFC2833: switch_channel_flag_t = 102;
pub const switch_channel_flag_t_CF_T38_PASSTHRU: switch_channel_flag_t = 103;
pub const switch_channel_flag_t_CF_DROP_DTMF: switch_channel_flag_t = 104;
pub const switch_channel_flag_t_CF_REINVITE: switch_channel_flag_t = 105;
pub const switch_channel_flag_t_CF_NOSDP_REINVITE: switch_channel_flag_t = 106;
pub const switch_channel_flag_t_CF_AUTOFLUSH_DURING_BRIDGE: switch_channel_flag_t = 107;
pub const switch_channel_flag_t_CF_RTP_NOTIMER_DURING_BRIDGE: switch_channel_flag_t = 108;
pub const switch_channel_flag_t_CF_AVPF: switch_channel_flag_t = 109;
pub const switch_channel_flag_t_CF_AVPF_MOZ: switch_channel_flag_t = 110;
pub const switch_channel_flag_t_CF_ICE: switch_channel_flag_t = 111;
pub const switch_channel_flag_t_CF_DTLS: switch_channel_flag_t = 112;
pub const switch_channel_flag_t_CF_VERBOSE_SDP: switch_channel_flag_t = 113;
pub const switch_channel_flag_t_CF_DTLS_OK: switch_channel_flag_t = 114;
pub const switch_channel_flag_t_CF_3PCC: switch_channel_flag_t = 115;
pub const switch_channel_flag_t_CF_VIDEO_PASSIVE: switch_channel_flag_t = 116;
pub const switch_channel_flag_t_CF_NOVIDEO: switch_channel_flag_t = 117;
pub const switch_channel_flag_t_CF_VIDEO_BITRATE_UNMANAGABLE: switch_channel_flag_t = 118;
pub const switch_channel_flag_t_CF_VIDEO_ECHO: switch_channel_flag_t = 119;
pub const switch_channel_flag_t_CF_VIDEO_BLANK: switch_channel_flag_t = 120;
pub const switch_channel_flag_t_CF_VIDEO_WRITING: switch_channel_flag_t = 121;
pub const switch_channel_flag_t_CF_SLA_INTERCEPT: switch_channel_flag_t = 122;
pub const switch_channel_flag_t_CF_VIDEO_BREAK: switch_channel_flag_t = 123;
pub const switch_channel_flag_t_CF_AUDIO_PAUSE_READ: switch_channel_flag_t = 124;
pub const switch_channel_flag_t_CF_AUDIO_PAUSE_WRITE: switch_channel_flag_t = 125;
pub const switch_channel_flag_t_CF_VIDEO_PAUSE_READ: switch_channel_flag_t = 126;
pub const switch_channel_flag_t_CF_VIDEO_PAUSE_WRITE: switch_channel_flag_t = 127;
pub const switch_channel_flag_t_CF_BYPASS_MEDIA_AFTER_HOLD: switch_channel_flag_t = 128;
pub const switch_channel_flag_t_CF_HANGUP_HELD: switch_channel_flag_t = 129;
pub const switch_channel_flag_t_CF_CONFERENCE_RESET_MEDIA: switch_channel_flag_t = 130;
pub const switch_channel_flag_t_CF_VIDEO_DECODED_READ: switch_channel_flag_t = 131;
pub const switch_channel_flag_t_CF_VIDEO_DEBUG_READ: switch_channel_flag_t = 132;
pub const switch_channel_flag_t_CF_VIDEO_DEBUG_WRITE: switch_channel_flag_t = 133;
pub const switch_channel_flag_t_CF_NO_RECOVER: switch_channel_flag_t = 134;
pub const switch_channel_flag_t_CF_VIDEO_READY: switch_channel_flag_t = 135;
pub const switch_channel_flag_t_CF_VIDEO_MIRROR_INPUT: switch_channel_flag_t = 136;
pub const switch_channel_flag_t_CF_VIDEO_READ_FILE_ATTACHED: switch_channel_flag_t = 137;
pub const switch_channel_flag_t_CF_VIDEO_WRITE_FILE_ATTACHED: switch_channel_flag_t = 138;
pub const switch_channel_flag_t_CF_3P_MEDIA_REQUESTED: switch_channel_flag_t = 139;
pub const switch_channel_flag_t_CF_3P_NOMEDIA_REQUESTED: switch_channel_flag_t = 140;
pub const switch_channel_flag_t_CF_3P_NOMEDIA_REQUESTED_BLEG: switch_channel_flag_t = 141;
pub const switch_channel_flag_t_CF_IMAGE_SDP: switch_channel_flag_t = 142;
pub const switch_channel_flag_t_CF_VIDEO_SDP_RECVD: switch_channel_flag_t = 143;
pub const switch_channel_flag_t_CF_TEXT_SDP_RECVD: switch_channel_flag_t = 144;
pub const switch_channel_flag_t_CF_HAS_TEXT: switch_channel_flag_t = 145;
pub const switch_channel_flag_t_CF_TEXT_POSSIBLE: switch_channel_flag_t = 146;
pub const switch_channel_flag_t_CF_TEXT_PASSIVE: switch_channel_flag_t = 147;
pub const switch_channel_flag_t_CF_TEXT_ECHO: switch_channel_flag_t = 148;
pub const switch_channel_flag_t_CF_TEXT_ACTIVE: switch_channel_flag_t = 149;
pub const switch_channel_flag_t_CF_TEXT_IDLE: switch_channel_flag_t = 150;
pub const switch_channel_flag_t_CF_TEXT_LINE_BASED: switch_channel_flag_t = 151;
pub const switch_channel_flag_t_CF_QUEUE_TEXT_EVENTS: switch_channel_flag_t = 152;
pub const switch_channel_flag_t_CF_FIRE_TEXT_EVENTS: switch_channel_flag_t = 153;
pub const switch_channel_flag_t_CF_MSRP: switch_channel_flag_t = 154;
pub const switch_channel_flag_t_CF_MSRPS: switch_channel_flag_t = 155;
pub const switch_channel_flag_t_CF_WANT_MSRP: switch_channel_flag_t = 156;
pub const switch_channel_flag_t_CF_WANT_MSRPS: switch_channel_flag_t = 157;
pub const switch_channel_flag_t_CF_RTT: switch_channel_flag_t = 158;
pub const switch_channel_flag_t_CF_WANT_RTT: switch_channel_flag_t = 159;
pub const switch_channel_flag_t_CF_AUDIO: switch_channel_flag_t = 160;
pub const switch_channel_flag_t_CF_AWAITING_STREAM_CHANGE: switch_channel_flag_t = 161;
pub const switch_channel_flag_t_CF_PROCESSING_STREAM_CHANGE: switch_channel_flag_t = 162;
pub const switch_channel_flag_t_CF_STREAM_CHANGED: switch_channel_flag_t = 163;
pub const switch_channel_flag_t_CF_ARRANGED_BRIDGE: switch_channel_flag_t = 164;
pub const switch_channel_flag_t_CF_STATE_REPEAT: switch_channel_flag_t = 165;
pub const switch_channel_flag_t_CF_WANT_DTLSv1_2: switch_channel_flag_t = 166;
pub const switch_channel_flag_t_CF_RFC7329_COMPAT: switch_channel_flag_t = 167;
pub const switch_channel_flag_t_CF_REATTACHED: switch_channel_flag_t = 168;
pub const switch_channel_flag_t_CF_VIDEO_READ_TAPPED: switch_channel_flag_t = 169;
pub const switch_channel_flag_t_CF_VIDEO_WRITE_TAPPED: switch_channel_flag_t = 170;
pub const switch_channel_flag_t_CF_DEVICES_CHANGED: switch_channel_flag_t = 171;
pub const switch_channel_flag_t_CF_FLAG_MAX: switch_channel_flag_t = 172;
pub type switch_channel_flag_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_vid_params_s {
    pub width: u32,
    pub height: u32,
    pub fps: u32,
    pub d_width: u32,
    pub d_height: u32,
}
#[test]
fn bindgen_test_layout_switch_vid_params_s() {
    const UNINIT: ::std::mem::MaybeUninit<switch_vid_params_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_vid_params_s>(),
        20usize,
        concat!("Size of: ", stringify!(switch_vid_params_s))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_vid_params_s>(),
        4usize,
        concat!("Alignment of ", stringify!(switch_vid_params_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_vid_params_s),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_vid_params_s),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fps) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_vid_params_s),
            "::",
            stringify!(fps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_width) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_vid_params_s),
            "::",
            stringify!(d_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_height) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_vid_params_s),
            "::",
            stringify!(d_height)
        )
    );
}
pub type switch_vid_params_t = switch_vid_params_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_fps_s {
    pub fps: f32,
    pub ms: ::std::os::raw::c_int,
    pub samples: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_switch_fps_s() {
    const UNINIT: ::std::mem::MaybeUninit<switch_fps_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_fps_s>(),
        12usize,
        concat!("Size of: ", stringify!(switch_fps_s))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_fps_s>(),
        4usize,
        concat!("Alignment of ", stringify!(switch_fps_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_fps_s),
            "::",
            stringify!(fps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ms) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_fps_s),
            "::",
            stringify!(ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samples) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_fps_s),
            "::",
            stringify!(samples)
        )
    );
}
pub type switch_fps_t = switch_fps_s;
pub const switch_channel_app_flag_t_CF_APP_TAGGED: switch_channel_app_flag_t = 1;
pub const switch_channel_app_flag_t_CF_APP_T38: switch_channel_app_flag_t = 2;
pub const switch_channel_app_flag_t_CF_APP_T38_REQ: switch_channel_app_flag_t = 4;
pub const switch_channel_app_flag_t_CF_APP_T38_FAIL: switch_channel_app_flag_t = 8;
pub const switch_channel_app_flag_t_CF_APP_T38_NEGOTIATED: switch_channel_app_flag_t = 16;
pub const switch_channel_app_flag_t_CF_APP_T38_POSSIBLE: switch_channel_app_flag_t = 32;
pub type switch_channel_app_flag_t = ::std::os::raw::c_uint;
pub const switch_frame_flag_enum_t_SFF_NONE: switch_frame_flag_enum_t = 0;
pub const switch_frame_flag_enum_t_SFF_CNG: switch_frame_flag_enum_t = 1;
pub const switch_frame_flag_enum_t_SFF_RAW_RTP: switch_frame_flag_enum_t = 2;
pub const switch_frame_flag_enum_t_SFF_RTP_HEADER: switch_frame_flag_enum_t = 4;
pub const switch_frame_flag_enum_t_SFF_PLC: switch_frame_flag_enum_t = 8;
pub const switch_frame_flag_enum_t_SFF_RFC2833: switch_frame_flag_enum_t = 16;
pub const switch_frame_flag_enum_t_SFF_PROXY_PACKET: switch_frame_flag_enum_t = 32;
pub const switch_frame_flag_enum_t_SFF_DYNAMIC: switch_frame_flag_enum_t = 64;
pub const switch_frame_flag_enum_t_SFF_UDPTL_PACKET: switch_frame_flag_enum_t = 128;
pub const switch_frame_flag_enum_t_SFF_NOT_AUDIO: switch_frame_flag_enum_t = 256;
pub const switch_frame_flag_enum_t_SFF_RTCP: switch_frame_flag_enum_t = 512;
pub const switch_frame_flag_enum_t_SFF_MARKER: switch_frame_flag_enum_t = 1024;
pub const switch_frame_flag_enum_t_SFF_WAIT_KEY_FRAME: switch_frame_flag_enum_t = 2048;
pub const switch_frame_flag_enum_t_SFF_RAW_RTP_PARSE_FRAME: switch_frame_flag_enum_t = 4096;
pub const switch_frame_flag_enum_t_SFF_PICTURE_RESET: switch_frame_flag_enum_t = 8192;
pub const switch_frame_flag_enum_t_SFF_SAME_IMAGE: switch_frame_flag_enum_t = 16384;
pub const switch_frame_flag_enum_t_SFF_USE_VIDEO_TIMESTAMP: switch_frame_flag_enum_t = 32768;
pub const switch_frame_flag_enum_t_SFF_ENCODED: switch_frame_flag_enum_t = 65536;
pub const switch_frame_flag_enum_t_SFF_TEXT_LINE_BREAK: switch_frame_flag_enum_t = 131072;
pub const switch_frame_flag_enum_t_SFF_IS_KEYFRAME: switch_frame_flag_enum_t = 262144;
pub const switch_frame_flag_enum_t_SFF_EXTERNAL: switch_frame_flag_enum_t = 524288;
#[doc = "\\enum switch_frame_flag_t\n\\brief Frame Flags\n\n<pre>\nSFF_CNG        = (1 <<  0) - Frame represents comfort noise\nSFF_RAW_RTP    = (1 <<  1) - Frame has raw rtp accessible\nSFF_RTP_HEADER = (1 <<  2) - Get the rtp header from the frame header\nSFF_PLC        = (1 <<  3) - Frame has generated PLC data\nSFF_RFC2833    = (1 <<  4) - Frame has rfc2833 dtmf data\nSFF_DYNAMIC    = (1 <<  5) - Frame is dynamic and should be freed\nSFF_MARKER     = (1 << 11) - Frame flag has Marker set, only set by encoder\nSFF_WAIT_KEY_FRAME = (1 << 12) - Need a key from before could decode, or force generate a key frame on encode\n</pre>"]
pub type switch_frame_flag_enum_t = ::std::os::raw::c_uint;
pub type switch_frame_flag_t = u32;
pub const switch_application_flag_enum_t_SAF_NONE: switch_application_flag_enum_t = 0;
pub const switch_application_flag_enum_t_SAF_SUPPORT_NOMEDIA: switch_application_flag_enum_t = 1;
pub const switch_application_flag_enum_t_SAF_ROUTING_EXEC: switch_application_flag_enum_t = 2;
pub const switch_application_flag_enum_t_SAF_MEDIA_TAP: switch_application_flag_enum_t = 4;
pub const switch_application_flag_enum_t_SAF_ZOMBIE_EXEC: switch_application_flag_enum_t = 8;
pub const switch_application_flag_enum_t_SAF_NO_LOOPBACK: switch_application_flag_enum_t = 16;
pub const switch_application_flag_enum_t_SAF_SUPPORT_TEXT_ONLY: switch_application_flag_enum_t = 32;
pub type switch_application_flag_enum_t = ::std::os::raw::c_uint;
pub type switch_application_flag_t = u32;
pub const switch_chat_application_flag_enum_t_SCAF_NONE: switch_chat_application_flag_enum_t = 0;
pub type switch_chat_application_flag_enum_t = ::std::os::raw::c_uint;
pub type switch_chat_application_flag_t = u32;
pub const switch_signal_t_SWITCH_SIG_NONE: switch_signal_t = 0;
pub const switch_signal_t_SWITCH_SIG_KILL: switch_signal_t = 1;
pub const switch_signal_t_SWITCH_SIG_XFER: switch_signal_t = 2;
pub const switch_signal_t_SWITCH_SIG_BREAK: switch_signal_t = 3;
#[doc = "\\enum switch_signal_t\n\\brief Signals to send to channels\n<pre>\nSWITCH_SIG_KILL - Kill the channel\nSWITCH_SIG_XFER - Stop the current io but leave it viable\n</pre>"]
pub type switch_signal_t = ::std::os::raw::c_uint;
pub const switch_codec_flag_enum_t_SWITCH_CODEC_FLAG_ENCODE: switch_codec_flag_enum_t = 1;
pub const switch_codec_flag_enum_t_SWITCH_CODEC_FLAG_DECODE: switch_codec_flag_enum_t = 2;
pub const switch_codec_flag_enum_t_SWITCH_CODEC_FLAG_SILENCE_START: switch_codec_flag_enum_t = 4;
pub const switch_codec_flag_enum_t_SWITCH_CODEC_FLAG_SILENCE_STOP: switch_codec_flag_enum_t = 8;
pub const switch_codec_flag_enum_t_SWITCH_CODEC_FLAG_SILENCE: switch_codec_flag_enum_t = 16;
pub const switch_codec_flag_enum_t_SWITCH_CODEC_FLAG_FREE_POOL: switch_codec_flag_enum_t = 32;
pub const switch_codec_flag_enum_t_SWITCH_CODEC_FLAG_AAL2: switch_codec_flag_enum_t = 64;
pub const switch_codec_flag_enum_t_SWITCH_CODEC_FLAG_PASSTHROUGH: switch_codec_flag_enum_t = 128;
pub const switch_codec_flag_enum_t_SWITCH_CODEC_FLAG_READY: switch_codec_flag_enum_t = 256;
pub const switch_codec_flag_enum_t_SWITCH_CODEC_FLAG_HAS_ADJ_BITRATE: switch_codec_flag_enum_t =
    16384;
pub const switch_codec_flag_enum_t_SWITCH_CODEC_FLAG_HAS_PLC: switch_codec_flag_enum_t = 32768;
pub const switch_codec_flag_enum_t_SWITCH_CODEC_FLAG_VIDEO_PATCHING: switch_codec_flag_enum_t =
    65536;
#[doc = "\\enum switch_codec_flag_t\n\\brief Codec related flags\n<pre>\nSWITCH_CODEC_FLAG_ENCODE =\t\t\t(1 <<  0) - Codec can encode\nSWITCH_CODEC_FLAG_DECODE =\t\t\t(1 <<  1) - Codec can decode\nSWITCH_CODEC_FLAG_SILENCE_START =\t(1 <<  2) - Start period of silence\nSWITCH_CODEC_FLAG_SILENCE_STOP =\t(1 <<  3) - End period of silence\nSWITCH_CODEC_FLAG_SILENCE =\t\t\t(1 <<  4) - Silence\nSWITCH_CODEC_FLAG_FREE_POOL =\t\t(1 <<  5) - Free codec's pool on destruction\nSWITCH_CODEC_FLAG_AAL2 =\t\t\t(1 <<  6) - USE AAL2 Bitpacking\nSWITCH_CODEC_FLAG_PASSTHROUGH =\t\t(1 <<  7) - Passthrough only\n</pre>"]
pub type switch_codec_flag_enum_t = ::std::os::raw::c_uint;
pub type switch_codec_flag_t = u32;
pub const switch_speech_flag_enum_t_SWITCH_SPEECH_FLAG_NONE: switch_speech_flag_enum_t = 0;
pub const switch_speech_flag_enum_t_SWITCH_SPEECH_FLAG_HASTEXT: switch_speech_flag_enum_t = 1;
pub const switch_speech_flag_enum_t_SWITCH_SPEECH_FLAG_PEEK: switch_speech_flag_enum_t = 2;
pub const switch_speech_flag_enum_t_SWITCH_SPEECH_FLAG_FREE_POOL: switch_speech_flag_enum_t = 4;
pub const switch_speech_flag_enum_t_SWITCH_SPEECH_FLAG_BLOCKING: switch_speech_flag_enum_t = 8;
pub const switch_speech_flag_enum_t_SWITCH_SPEECH_FLAG_PAUSE: switch_speech_flag_enum_t = 16;
pub const switch_speech_flag_enum_t_SWITCH_SPEECH_FLAG_OPEN: switch_speech_flag_enum_t = 32;
pub const switch_speech_flag_enum_t_SWITCH_SPEECH_FLAG_DONE: switch_speech_flag_enum_t = 64;
#[doc = "\\enum switch_speech_flag_t\n\\brief Speech related flags\n<pre>\nSWITCH_SPEECH_FLAG_HASTEXT =\t\t(1 <<  0) - Interface is has text to read.\nSWITCH_SPEECH_FLAG_PEEK =\t\t\t(1 <<  1) - Read data but do not erase it.\nSWITCH_SPEECH_FLAG_FREE_POOL =\t\t(1 <<  2) - Free interface's pool on destruction.\nSWITCH_SPEECH_FLAG_BLOCKING =       (1 <<  3) - Indicate that a blocking call is desired\nSWITCH_SPEECH_FLAG_PAUSE = \t\t\t(1 <<  4) - Pause toggle for playback\n</pre>"]
pub type switch_speech_flag_enum_t = ::std::os::raw::c_uint;
pub type switch_speech_flag_t = u32;
pub const switch_asr_flag_enum_t_SWITCH_ASR_FLAG_NONE: switch_asr_flag_enum_t = 0;
pub const switch_asr_flag_enum_t_SWITCH_ASR_FLAG_DATA: switch_asr_flag_enum_t = 1;
pub const switch_asr_flag_enum_t_SWITCH_ASR_FLAG_FREE_POOL: switch_asr_flag_enum_t = 2;
pub const switch_asr_flag_enum_t_SWITCH_ASR_FLAG_CLOSED: switch_asr_flag_enum_t = 4;
pub const switch_asr_flag_enum_t_SWITCH_ASR_FLAG_FIRE_EVENTS: switch_asr_flag_enum_t = 8;
pub const switch_asr_flag_enum_t_SWITCH_ASR_FLAG_AUTO_RESUME: switch_asr_flag_enum_t = 16;
#[doc = "\\enum switch_asr_flag_t\n\\brief Asr related flags\n<pre>\nSWITCH_ASR_FLAG_DATA =\t\t\t(1 <<  0) - Interface has data\nSWITCH_ASR_FLAG_FREE_POOL =\t\t(1 <<  1) - Pool needs to be freed\nSWITCH_ASR_FLAG_CLOSED = \t\t(1 <<  2) - Interface has been closed\nSWITCH_ASR_FLAG_FIRE_EVENTS =\t(1 <<  3) - Fire all speech events\nSWITCH_ASR_FLAG_AUTO_RESUME =   (1 <<  4) - Auto Resume\n</pre>"]
pub type switch_asr_flag_enum_t = ::std::os::raw::c_uint;
pub type switch_asr_flag_t = u32;
pub const switch_directory_flag_enum_t_SWITCH_DIRECTORY_FLAG_FREE_POOL:
    switch_directory_flag_enum_t = 1;
#[doc = "\\enum switch_directory_flag_t\n\\brief Directory Handle related flags\n<pre>\nSWITCH_DIRECTORY_FLAG_FREE_POOL =\t\t(1 <<  0) - Free interface's pool on destruction.\n</pre>"]
pub type switch_directory_flag_enum_t = ::std::os::raw::c_uint;
pub type switch_directory_flag_t = u32;
pub const switch_codec_type_t_SWITCH_CODEC_TYPE_AUDIO: switch_codec_type_t = 0;
pub const switch_codec_type_t_SWITCH_CODEC_TYPE_VIDEO: switch_codec_type_t = 1;
pub const switch_codec_type_t_SWITCH_CODEC_TYPE_T38: switch_codec_type_t = 2;
pub const switch_codec_type_t_SWITCH_CODEC_TYPE_APP: switch_codec_type_t = 3;
#[doc = "\\enum switch_codec_type_t\n\\brief Codec types\n<pre>\nSWITCH_CODEC_TYPE_AUDIO - Audio Codec\nSWITCH_CODEC_TYPE_VIDEO - Video Codec\nSWITCH_CODEC_TYPE_T38   - T38 Codec\nSWITCH_CODEC_TYPE_APP   - Application Codec\n</pre>"]
pub type switch_codec_type_t = ::std::os::raw::c_uint;
pub const switch_media_type_t_SWITCH_MEDIA_TYPE_AUDIO: switch_media_type_t = 0;
pub const switch_media_type_t_SWITCH_MEDIA_TYPE_VIDEO: switch_media_type_t = 1;
pub const switch_media_type_t_SWITCH_MEDIA_TYPE_TEXT: switch_media_type_t = 2;
pub type switch_media_type_t = ::std::os::raw::c_uint;
pub const switch_timer_flag_enum_t_SWITCH_TIMER_FLAG_FREE_POOL: switch_timer_flag_enum_t = 1;
#[doc = "\\enum switch_timer_flag_t\n\\brief Timer related flags\n<pre>\nSWITCH_TIMER_FLAG_FREE_POOL =\t\t(1 <<  0) - Free timer's pool on destruction\n</pre>"]
pub type switch_timer_flag_enum_t = ::std::os::raw::c_uint;
pub type switch_timer_flag_t = u32;
pub const switch_media_bug_flag_enum_t_SMBF_BOTH: switch_media_bug_flag_enum_t = 0;
pub const switch_media_bug_flag_enum_t_SMBF_READ_STREAM: switch_media_bug_flag_enum_t = 1;
pub const switch_media_bug_flag_enum_t_SMBF_WRITE_STREAM: switch_media_bug_flag_enum_t = 2;
pub const switch_media_bug_flag_enum_t_SMBF_WRITE_REPLACE: switch_media_bug_flag_enum_t = 4;
pub const switch_media_bug_flag_enum_t_SMBF_READ_REPLACE: switch_media_bug_flag_enum_t = 8;
pub const switch_media_bug_flag_enum_t_SMBF_READ_PING: switch_media_bug_flag_enum_t = 16;
pub const switch_media_bug_flag_enum_t_SMBF_STEREO: switch_media_bug_flag_enum_t = 32;
pub const switch_media_bug_flag_enum_t_SMBF_ANSWER_REQ: switch_media_bug_flag_enum_t = 64;
pub const switch_media_bug_flag_enum_t_SMBF_BRIDGE_REQ: switch_media_bug_flag_enum_t = 128;
pub const switch_media_bug_flag_enum_t_SMBF_THREAD_LOCK: switch_media_bug_flag_enum_t = 256;
pub const switch_media_bug_flag_enum_t_SMBF_PRUNE: switch_media_bug_flag_enum_t = 512;
pub const switch_media_bug_flag_enum_t_SMBF_NO_PAUSE: switch_media_bug_flag_enum_t = 1024;
pub const switch_media_bug_flag_enum_t_SMBF_STEREO_SWAP: switch_media_bug_flag_enum_t = 2048;
pub const switch_media_bug_flag_enum_t_SMBF_LOCK: switch_media_bug_flag_enum_t = 4096;
pub const switch_media_bug_flag_enum_t_SMBF_TAP_NATIVE_READ: switch_media_bug_flag_enum_t = 8192;
pub const switch_media_bug_flag_enum_t_SMBF_TAP_NATIVE_WRITE: switch_media_bug_flag_enum_t = 16384;
pub const switch_media_bug_flag_enum_t_SMBF_ONE_ONLY: switch_media_bug_flag_enum_t = 32768;
pub const switch_media_bug_flag_enum_t_SMBF_MASK: switch_media_bug_flag_enum_t = 65536;
pub const switch_media_bug_flag_enum_t_SMBF_READ_VIDEO_PING: switch_media_bug_flag_enum_t = 131072;
pub const switch_media_bug_flag_enum_t_SMBF_WRITE_VIDEO_PING: switch_media_bug_flag_enum_t = 262144;
pub const switch_media_bug_flag_enum_t_SMBF_READ_VIDEO_STREAM: switch_media_bug_flag_enum_t =
    524288;
pub const switch_media_bug_flag_enum_t_SMBF_WRITE_VIDEO_STREAM: switch_media_bug_flag_enum_t =
    1048576;
pub const switch_media_bug_flag_enum_t_SMBF_VIDEO_PATCH: switch_media_bug_flag_enum_t = 2097152;
pub const switch_media_bug_flag_enum_t_SMBF_SPY_VIDEO_STREAM: switch_media_bug_flag_enum_t =
    4194304;
pub const switch_media_bug_flag_enum_t_SMBF_SPY_VIDEO_STREAM_BLEG: switch_media_bug_flag_enum_t =
    8388608;
pub const switch_media_bug_flag_enum_t_SMBF_READ_VIDEO_PATCH: switch_media_bug_flag_enum_t =
    16777216;
pub const switch_media_bug_flag_enum_t_SMBF_READ_TEXT_STREAM: switch_media_bug_flag_enum_t =
    33554432;
pub const switch_media_bug_flag_enum_t_SMBF_FIRST: switch_media_bug_flag_enum_t = 67108864;
pub const switch_media_bug_flag_enum_t_SMBF_PAUSE: switch_media_bug_flag_enum_t = 134217728;
#[doc = "\\enum switch_timer_flag_t\n\\brief Timer related flags\n<pre>\nSMBF_READ_STREAM - Include the Read Stream\nSMBF_WRITE_STREAM - Include the Write Stream\nSMBF_WRITE_REPLACE - Replace the Write Stream\nSMBF_READ_REPLACE - Replace the Read Stream\nSMBF_STEREO - Record in stereo\nSMBF_ANSWER_REQ - Don't record until the channel is answered\nSMBF_BRIDGE_REQ - Don't record until the channel is bridged\nSMBF_THREAD_LOCK - Only let the same thread who created the bug remove it.\nSMBF_PRUNE -\nSMBF_NO_PAUSE -\nSMBF_STEREO_SWAP - Record in stereo: Write Stream - left channel, Read Stream - right channel\n</pre>"]
pub type switch_media_bug_flag_enum_t = ::std::os::raw::c_uint;
pub type switch_media_bug_flag_t = u32;
pub const switch_file_flag_enum_t_SWITCH_FILE_FLAG_READ: switch_file_flag_enum_t = 1;
pub const switch_file_flag_enum_t_SWITCH_FILE_FLAG_WRITE: switch_file_flag_enum_t = 2;
pub const switch_file_flag_enum_t_SWITCH_FILE_FLAG_FREE_POOL: switch_file_flag_enum_t = 4;
pub const switch_file_flag_enum_t_SWITCH_FILE_DATA_SHORT: switch_file_flag_enum_t = 8;
pub const switch_file_flag_enum_t_SWITCH_FILE_DATA_INT: switch_file_flag_enum_t = 16;
pub const switch_file_flag_enum_t_SWITCH_FILE_DATA_FLOAT: switch_file_flag_enum_t = 32;
pub const switch_file_flag_enum_t_SWITCH_FILE_DATA_DOUBLE: switch_file_flag_enum_t = 64;
pub const switch_file_flag_enum_t_SWITCH_FILE_DATA_RAW: switch_file_flag_enum_t = 128;
pub const switch_file_flag_enum_t_SWITCH_FILE_PAUSE: switch_file_flag_enum_t = 256;
pub const switch_file_flag_enum_t_SWITCH_FILE_NATIVE: switch_file_flag_enum_t = 512;
pub const switch_file_flag_enum_t_SWITCH_FILE_SEEK: switch_file_flag_enum_t = 1024;
pub const switch_file_flag_enum_t_SWITCH_FILE_OPEN: switch_file_flag_enum_t = 2048;
pub const switch_file_flag_enum_t_SWITCH_FILE_CALLBACK: switch_file_flag_enum_t = 4096;
pub const switch_file_flag_enum_t_SWITCH_FILE_DONE: switch_file_flag_enum_t = 8192;
pub const switch_file_flag_enum_t_SWITCH_FILE_BUFFER_DONE: switch_file_flag_enum_t = 16384;
pub const switch_file_flag_enum_t_SWITCH_FILE_WRITE_APPEND: switch_file_flag_enum_t = 32768;
pub const switch_file_flag_enum_t_SWITCH_FILE_WRITE_OVER: switch_file_flag_enum_t = 65536;
pub const switch_file_flag_enum_t_SWITCH_FILE_NOMUX: switch_file_flag_enum_t = 131072;
pub const switch_file_flag_enum_t_SWITCH_FILE_BREAK_ON_CHANGE: switch_file_flag_enum_t = 262144;
pub const switch_file_flag_enum_t_SWITCH_FILE_FLAG_VIDEO: switch_file_flag_enum_t = 524288;
pub const switch_file_flag_enum_t_SWITCH_FILE_FLAG_VIDEO_EOF: switch_file_flag_enum_t = 1048576;
pub const switch_file_flag_enum_t_SWITCH_FILE_PRE_CLOSED: switch_file_flag_enum_t = 2097152;
#[doc = "\\enum switch_file_flag_t\n\\brief File flags\n<pre>\nSWITCH_FILE_FLAG_READ =         (1 <<  0) - Open for read\nSWITCH_FILE_FLAG_WRITE =        (1 <<  1) - Open for write\nSWITCH_FILE_FLAG_FREE_POOL =    (1 <<  2) - Free file handle's pool on destruction\nSWITCH_FILE_DATA_SHORT =        (1 <<  3) - Read data in shorts\nSWITCH_FILE_DATA_INT =          (1 <<  4) - Read data in ints\nSWITCH_FILE_DATA_FLOAT =        (1 <<  5) - Read data in floats\nSWITCH_FILE_DATA_DOUBLE =       (1 <<  6) - Read data in doubles\nSWITCH_FILE_DATA_RAW =          (1 <<  7) - Read data as is\nSWITCH_FILE_PAUSE =             (1 <<  8) - Pause\nSWITCH_FILE_NATIVE =            (1 <<  9) - File is in native format (no transcoding)\nSWITCH_FILE_SEEK = \t\t\t\t(1 << 10) - File has done a seek\nSWITCH_FILE_OPEN =              (1 << 11) - File is open\n</pre>"]
pub type switch_file_flag_enum_t = ::std::os::raw::c_uint;
pub type switch_file_flag_t = u32;
pub const switch_io_flag_enum_t_SWITCH_IO_FLAG_NONE: switch_io_flag_enum_t = 0;
pub const switch_io_flag_enum_t_SWITCH_IO_FLAG_NOBLOCK: switch_io_flag_enum_t = 1;
pub const switch_io_flag_enum_t_SWITCH_IO_FLAG_SINGLE_READ: switch_io_flag_enum_t = 2;
pub const switch_io_flag_enum_t_SWITCH_IO_FLAG_FORCE: switch_io_flag_enum_t = 4;
pub const switch_io_flag_enum_t_SWITCH_IO_FLAG_QUEUED: switch_io_flag_enum_t = 8;
pub type switch_io_flag_enum_t = ::std::os::raw::c_uint;
pub type switch_io_flag_t = u32;
pub const switch_event_types_t_SWITCH_EVENT_CUSTOM: switch_event_types_t = 0;
pub const switch_event_types_t_SWITCH_EVENT_CLONE: switch_event_types_t = 1;
pub const switch_event_types_t_SWITCH_EVENT_CHANNEL_CREATE: switch_event_types_t = 2;
pub const switch_event_types_t_SWITCH_EVENT_CHANNEL_DESTROY: switch_event_types_t = 3;
pub const switch_event_types_t_SWITCH_EVENT_CHANNEL_STATE: switch_event_types_t = 4;
pub const switch_event_types_t_SWITCH_EVENT_CHANNEL_CALLSTATE: switch_event_types_t = 5;
pub const switch_event_types_t_SWITCH_EVENT_CHANNEL_ANSWER: switch_event_types_t = 6;
pub const switch_event_types_t_SWITCH_EVENT_CHANNEL_HANGUP: switch_event_types_t = 7;
pub const switch_event_types_t_SWITCH_EVENT_CHANNEL_HANGUP_COMPLETE: switch_event_types_t = 8;
pub const switch_event_types_t_SWITCH_EVENT_CHANNEL_EXECUTE: switch_event_types_t = 9;
pub const switch_event_types_t_SWITCH_EVENT_CHANNEL_EXECUTE_COMPLETE: switch_event_types_t = 10;
pub const switch_event_types_t_SWITCH_EVENT_CHANNEL_HOLD: switch_event_types_t = 11;
pub const switch_event_types_t_SWITCH_EVENT_CHANNEL_UNHOLD: switch_event_types_t = 12;
pub const switch_event_types_t_SWITCH_EVENT_CHANNEL_BRIDGE: switch_event_types_t = 13;
pub const switch_event_types_t_SWITCH_EVENT_CHANNEL_UNBRIDGE: switch_event_types_t = 14;
pub const switch_event_types_t_SWITCH_EVENT_CHANNEL_PROGRESS: switch_event_types_t = 15;
pub const switch_event_types_t_SWITCH_EVENT_CHANNEL_PROGRESS_MEDIA: switch_event_types_t = 16;
pub const switch_event_types_t_SWITCH_EVENT_CHANNEL_OUTGOING: switch_event_types_t = 17;
pub const switch_event_types_t_SWITCH_EVENT_CHANNEL_PARK: switch_event_types_t = 18;
pub const switch_event_types_t_SWITCH_EVENT_CHANNEL_UNPARK: switch_event_types_t = 19;
pub const switch_event_types_t_SWITCH_EVENT_CHANNEL_APPLICATION: switch_event_types_t = 20;
pub const switch_event_types_t_SWITCH_EVENT_CHANNEL_ORIGINATE: switch_event_types_t = 21;
pub const switch_event_types_t_SWITCH_EVENT_CHANNEL_UUID: switch_event_types_t = 22;
pub const switch_event_types_t_SWITCH_EVENT_API: switch_event_types_t = 23;
pub const switch_event_types_t_SWITCH_EVENT_LOG: switch_event_types_t = 24;
pub const switch_event_types_t_SWITCH_EVENT_INBOUND_CHAN: switch_event_types_t = 25;
pub const switch_event_types_t_SWITCH_EVENT_OUTBOUND_CHAN: switch_event_types_t = 26;
pub const switch_event_types_t_SWITCH_EVENT_STARTUP: switch_event_types_t = 27;
pub const switch_event_types_t_SWITCH_EVENT_SHUTDOWN: switch_event_types_t = 28;
pub const switch_event_types_t_SWITCH_EVENT_PUBLISH: switch_event_types_t = 29;
pub const switch_event_types_t_SWITCH_EVENT_UNPUBLISH: switch_event_types_t = 30;
pub const switch_event_types_t_SWITCH_EVENT_TALK: switch_event_types_t = 31;
pub const switch_event_types_t_SWITCH_EVENT_NOTALK: switch_event_types_t = 32;
pub const switch_event_types_t_SWITCH_EVENT_SESSION_CRASH: switch_event_types_t = 33;
pub const switch_event_types_t_SWITCH_EVENT_MODULE_LOAD: switch_event_types_t = 34;
pub const switch_event_types_t_SWITCH_EVENT_MODULE_UNLOAD: switch_event_types_t = 35;
pub const switch_event_types_t_SWITCH_EVENT_DTMF: switch_event_types_t = 36;
pub const switch_event_types_t_SWITCH_EVENT_MESSAGE: switch_event_types_t = 37;
pub const switch_event_types_t_SWITCH_EVENT_PRESENCE_IN: switch_event_types_t = 38;
pub const switch_event_types_t_SWITCH_EVENT_NOTIFY_IN: switch_event_types_t = 39;
pub const switch_event_types_t_SWITCH_EVENT_PRESENCE_OUT: switch_event_types_t = 40;
pub const switch_event_types_t_SWITCH_EVENT_PRESENCE_PROBE: switch_event_types_t = 41;
pub const switch_event_types_t_SWITCH_EVENT_MESSAGE_WAITING: switch_event_types_t = 42;
pub const switch_event_types_t_SWITCH_EVENT_MESSAGE_QUERY: switch_event_types_t = 43;
pub const switch_event_types_t_SWITCH_EVENT_ROSTER: switch_event_types_t = 44;
pub const switch_event_types_t_SWITCH_EVENT_CODEC: switch_event_types_t = 45;
pub const switch_event_types_t_SWITCH_EVENT_BACKGROUND_JOB: switch_event_types_t = 46;
pub const switch_event_types_t_SWITCH_EVENT_DETECTED_SPEECH: switch_event_types_t = 47;
pub const switch_event_types_t_SWITCH_EVENT_DETECTED_TONE: switch_event_types_t = 48;
pub const switch_event_types_t_SWITCH_EVENT_PRIVATE_COMMAND: switch_event_types_t = 49;
pub const switch_event_types_t_SWITCH_EVENT_HEARTBEAT: switch_event_types_t = 50;
pub const switch_event_types_t_SWITCH_EVENT_TRAP: switch_event_types_t = 51;
pub const switch_event_types_t_SWITCH_EVENT_ADD_SCHEDULE: switch_event_types_t = 52;
pub const switch_event_types_t_SWITCH_EVENT_DEL_SCHEDULE: switch_event_types_t = 53;
pub const switch_event_types_t_SWITCH_EVENT_EXE_SCHEDULE: switch_event_types_t = 54;
pub const switch_event_types_t_SWITCH_EVENT_RE_SCHEDULE: switch_event_types_t = 55;
pub const switch_event_types_t_SWITCH_EVENT_RELOADXML: switch_event_types_t = 56;
pub const switch_event_types_t_SWITCH_EVENT_NOTIFY: switch_event_types_t = 57;
pub const switch_event_types_t_SWITCH_EVENT_PHONE_FEATURE: switch_event_types_t = 58;
pub const switch_event_types_t_SWITCH_EVENT_PHONE_FEATURE_SUBSCRIBE: switch_event_types_t = 59;
pub const switch_event_types_t_SWITCH_EVENT_SEND_MESSAGE: switch_event_types_t = 60;
pub const switch_event_types_t_SWITCH_EVENT_RECV_MESSAGE: switch_event_types_t = 61;
pub const switch_event_types_t_SWITCH_EVENT_REQUEST_PARAMS: switch_event_types_t = 62;
pub const switch_event_types_t_SWITCH_EVENT_CHANNEL_DATA: switch_event_types_t = 63;
pub const switch_event_types_t_SWITCH_EVENT_GENERAL: switch_event_types_t = 64;
pub const switch_event_types_t_SWITCH_EVENT_COMMAND: switch_event_types_t = 65;
pub const switch_event_types_t_SWITCH_EVENT_SESSION_HEARTBEAT: switch_event_types_t = 66;
pub const switch_event_types_t_SWITCH_EVENT_CLIENT_DISCONNECTED: switch_event_types_t = 67;
pub const switch_event_types_t_SWITCH_EVENT_SERVER_DISCONNECTED: switch_event_types_t = 68;
pub const switch_event_types_t_SWITCH_EVENT_SEND_INFO: switch_event_types_t = 69;
pub const switch_event_types_t_SWITCH_EVENT_RECV_INFO: switch_event_types_t = 70;
pub const switch_event_types_t_SWITCH_EVENT_RECV_RTCP_MESSAGE: switch_event_types_t = 71;
pub const switch_event_types_t_SWITCH_EVENT_SEND_RTCP_MESSAGE: switch_event_types_t = 72;
pub const switch_event_types_t_SWITCH_EVENT_CALL_SECURE: switch_event_types_t = 73;
pub const switch_event_types_t_SWITCH_EVENT_NAT: switch_event_types_t = 74;
pub const switch_event_types_t_SWITCH_EVENT_RECORD_START: switch_event_types_t = 75;
pub const switch_event_types_t_SWITCH_EVENT_RECORD_STOP: switch_event_types_t = 76;
pub const switch_event_types_t_SWITCH_EVENT_PLAYBACK_START: switch_event_types_t = 77;
pub const switch_event_types_t_SWITCH_EVENT_PLAYBACK_STOP: switch_event_types_t = 78;
pub const switch_event_types_t_SWITCH_EVENT_CALL_UPDATE: switch_event_types_t = 79;
pub const switch_event_types_t_SWITCH_EVENT_FAILURE: switch_event_types_t = 80;
pub const switch_event_types_t_SWITCH_EVENT_SOCKET_DATA: switch_event_types_t = 81;
pub const switch_event_types_t_SWITCH_EVENT_MEDIA_BUG_START: switch_event_types_t = 82;
pub const switch_event_types_t_SWITCH_EVENT_MEDIA_BUG_STOP: switch_event_types_t = 83;
pub const switch_event_types_t_SWITCH_EVENT_CONFERENCE_DATA_QUERY: switch_event_types_t = 84;
pub const switch_event_types_t_SWITCH_EVENT_CONFERENCE_DATA: switch_event_types_t = 85;
pub const switch_event_types_t_SWITCH_EVENT_CALL_SETUP_REQ: switch_event_types_t = 86;
pub const switch_event_types_t_SWITCH_EVENT_CALL_SETUP_RESULT: switch_event_types_t = 87;
pub const switch_event_types_t_SWITCH_EVENT_CALL_DETAIL: switch_event_types_t = 88;
pub const switch_event_types_t_SWITCH_EVENT_DEVICE_STATE: switch_event_types_t = 89;
pub const switch_event_types_t_SWITCH_EVENT_TEXT: switch_event_types_t = 90;
pub const switch_event_types_t_SWITCH_EVENT_SHUTDOWN_REQUESTED: switch_event_types_t = 91;
pub const switch_event_types_t_SWITCH_EVENT_ALL: switch_event_types_t = 92;
#[doc = "\\enum switch_event_types_t\n\\brief Built-in Events\n\n<pre>\nSWITCH_EVENT_CUSTOM\t\t\t\t- A custom event\nSWITCH_EVENT_CLONE\t\t\t\t- A cloned event\nSWITCH_EVENT_CHANNEL_CREATE\t\t- A channel has been created\nSWITCH_EVENT_CHANNEL_DESTROY\t- A channel has been destroyed\nSWITCH_EVENT_CHANNEL_STATE\t\t- A channel has changed state\nSWITCH_EVENT_CHANNEL_CALLSTATE\t- A channel has changed call state\nSWITCH_EVENT_CHANNEL_ANSWER\t\t- A channel has been answered\nSWITCH_EVENT_CHANNEL_HANGUP\t\t- A channel has been hungup\nSWITCH_EVENT_CHANNEL_HANGUP_COMPLETE\t- A channel has completed the hangup\nSWITCH_EVENT_CHANNEL_EXECUTE\t- A channel has executed a module's application\nSWITCH_EVENT_CHANNEL_EXECUTE_COMPLETE\t- A channel has finshed executing a module's application\nSWITCH_EVENT_CHANNEL_HOLD\t\t- A channel has been put on hold\nSWITCH_EVENT_CHANNEL_UNHOLD\t\t- A channel has been unheld\nSWITCH_EVENT_CHANNEL_BRIDGE     - A channel has bridged to another channel\nSWITCH_EVENT_CHANNEL_UNBRIDGE   - A channel has unbridged from another channel\nSWITCH_EVENT_CHANNEL_PROGRESS\t- A channel has started ringing\nSWITCH_EVENT_CHANNEL_PROGRESS_MEDIA\t- A channel has started early media\nSWITCH_EVENT_CHANNEL_OUTGOING\t- A channel has been unparked\nSWITCH_EVENT_CHANNEL_PARK \t\t- A channel has been parked\nSWITCH_EVENT_CHANNEL_UNPARK \t- A channel has been unparked\nSWITCH_EVENT_CHANNEL_APPLICATION- A channel has called and event from an application\nSWITCH_EVENT_CHANNEL_ORIGINATE  - A channel has been originated\nSWITCH_EVENT_CHANNEL_UUID       - A channel has changed uuid\nSWITCH_EVENT_API\t\t\t\t- An API call has been executed\nSWITCH_EVENT_LOG\t\t\t\t- A LOG event has been triggered\nSWITCH_EVENT_INBOUND_CHAN\t\t- A new inbound channel has been created\nSWITCH_EVENT_OUTBOUND_CHAN\t\t- A new outbound channel has been created\nSWITCH_EVENT_STARTUP\t\t\t- The system has been started\nSWITCH_EVENT_SHUTDOWN\t\t\t- The system has been shutdown\nSWITCH_EVENT_PUBLISH\t\t\t- Publish\nSWITCH_EVENT_UNPUBLISH\t\t\t- UnPublish\nSWITCH_EVENT_TALK\t\t\t\t- Talking Detected\nSWITCH_EVENT_NOTALK\t\t\t\t- Not Talking Detected\nSWITCH_EVENT_SESSION_CRASH\t\t- Session Crashed\nSWITCH_EVENT_MODULE_LOAD\t\t- Module was loaded\nSWITCH_EVENT_MODULE_UNLOAD\t\t- Module was unloaded\nSWITCH_EVENT_DTMF\t\t\t\t- DTMF was sent\nSWITCH_EVENT_MESSAGE\t\t\t- A Basic Message\nSWITCH_EVENT_PRESENCE_IN\t\t- Presence in\nSWITCH_EVENT_NOTIFY_IN\t\t\t- Received incoming NOTIFY from gateway subscription\nSWITCH_EVENT_PRESENCE_OUT\t\t- Presence out\nSWITCH_EVENT_PRESENCE_PROBE\t\t- Presence probe\nSWITCH_EVENT_MESSAGE_WAITING\t- A message is waiting\nSWITCH_EVENT_MESSAGE_QUERY\t\t- A query for MESSAGE_WAITING events\nSWITCH_EVENT_ROSTER\t\t\t\t- ?\nSWITCH_EVENT_CODEC\t\t\t\t- Codec Change\nSWITCH_EVENT_BACKGROUND_JOB\t\t- Background Job\nSWITCH_EVENT_DETECTED_SPEECH\t- Detected Speech\nSWITCH_EVENT_DETECTED_TONE      - Detected Tone\nSWITCH_EVENT_PRIVATE_COMMAND\t- A private command event\nSWITCH_EVENT_HEARTBEAT\t\t\t- Machine is alive\nSWITCH_EVENT_TRAP\t\t\t\t- Error Trap\nSWITCH_EVENT_ADD_SCHEDULE\t\t- Something has been scheduled\nSWITCH_EVENT_DEL_SCHEDULE\t\t- Something has been unscheduled\nSWITCH_EVENT_EXE_SCHEDULE\t\t- Something scheduled has been executed\nSWITCH_EVENT_RE_SCHEDULE\t\t- Something scheduled has been rescheduled\nSWITCH_EVENT_RELOADXML\t\t\t- XML registry has been reloaded\nSWITCH_EVENT_NOTIFY\t\t\t\t- Notification\nSWITCH_EVENT_PHONE_FEATURE\t\t- Notification (DND/CFWD/etc)\nSWITCH_EVENT_PHONE_FEATURE_SUBSCRIBE - Phone feature subscription\nSWITCH_EVENT_SEND_MESSAGE\t\t- Message\nSWITCH_EVENT_RECV_MESSAGE\t\t- Message\nSWITCH_EVENT_REQUEST_PARAMS\nSWITCH_EVENT_CHANNEL_DATA\nSWITCH_EVENT_GENERAL\nSWITCH_EVENT_COMMAND\nSWITCH_EVENT_SESSION_HEARTBEAT\nSWITCH_EVENT_CLIENT_DISCONNECTED\nSWITCH_EVENT_SERVER_DISCONNECTED\nSWITCH_EVENT_SEND_INFO\nSWITCH_EVENT_RECV_INFO\nSWITCH_EVENT_RECV_RTCP_MESSAGE\nSWITCH_EVENT_SEND_RTCP_MESSAGE\nSWITCH_EVENT_CALL_SECURE\nSWITCH_EVENT_NAT            \t- NAT Management (new/del/status)\nSWITCH_EVENT_RECORD_START\nSWITCH_EVENT_RECORD_STOP\nSWITCH_EVENT_PLAYBACK_START\nSWITCH_EVENT_PLAYBACK_STOP\nSWITCH_EVENT_CALL_UPDATE\nSWITCH_EVENT_FAILURE            - A failure occurred which might impact the normal functioning of the switch\nSWITCH_EVENT_SOCKET_DATA\nSWITCH_EVENT_MEDIA_BUG_START\nSWITCH_EVENT_MEDIA_BUG_STOP\nSWITCH_EVENT_CONFERENCE_DATA_QUERY\nSWITCH_EVENT_CONFERENCE_DATA\nSWITCH_EVENT_CALL_SETUP_REQ\nSWITCH_EVENT_CALL_SETUP_RESULT\nSWITCH_EVENT_CALL_DETAIL\nSWITCH_EVENT_DEVICE_STATE\nSWITCH_EVENT_SHUTDOWN_REQUESTED\t\t- Shutdown of the system has been requested\nSWITCH_EVENT_ALL\t\t\t\t- All events at once\n</pre>\n"]
pub type switch_event_types_t = ::std::os::raw::c_uint;
pub const switch_input_type_t_SWITCH_INPUT_TYPE_DTMF: switch_input_type_t = 0;
pub const switch_input_type_t_SWITCH_INPUT_TYPE_EVENT: switch_input_type_t = 1;
pub type switch_input_type_t = ::std::os::raw::c_uint;
pub const switch_call_cause_t_SWITCH_CAUSE_NONE: switch_call_cause_t = 0;
pub const switch_call_cause_t_SWITCH_CAUSE_UNALLOCATED_NUMBER: switch_call_cause_t = 1;
pub const switch_call_cause_t_SWITCH_CAUSE_NO_ROUTE_TRANSIT_NET: switch_call_cause_t = 2;
pub const switch_call_cause_t_SWITCH_CAUSE_NO_ROUTE_DESTINATION: switch_call_cause_t = 3;
pub const switch_call_cause_t_SWITCH_CAUSE_CHANNEL_UNACCEPTABLE: switch_call_cause_t = 6;
pub const switch_call_cause_t_SWITCH_CAUSE_CALL_AWARDED_DELIVERED: switch_call_cause_t = 7;
pub const switch_call_cause_t_SWITCH_CAUSE_NORMAL_CLEARING: switch_call_cause_t = 16;
pub const switch_call_cause_t_SWITCH_CAUSE_USER_BUSY: switch_call_cause_t = 17;
pub const switch_call_cause_t_SWITCH_CAUSE_NO_USER_RESPONSE: switch_call_cause_t = 18;
pub const switch_call_cause_t_SWITCH_CAUSE_NO_ANSWER: switch_call_cause_t = 19;
pub const switch_call_cause_t_SWITCH_CAUSE_SUBSCRIBER_ABSENT: switch_call_cause_t = 20;
pub const switch_call_cause_t_SWITCH_CAUSE_CALL_REJECTED: switch_call_cause_t = 21;
pub const switch_call_cause_t_SWITCH_CAUSE_NUMBER_CHANGED: switch_call_cause_t = 22;
pub const switch_call_cause_t_SWITCH_CAUSE_REDIRECTION_TO_NEW_DESTINATION: switch_call_cause_t = 23;
pub const switch_call_cause_t_SWITCH_CAUSE_EXCHANGE_ROUTING_ERROR: switch_call_cause_t = 25;
pub const switch_call_cause_t_SWITCH_CAUSE_DESTINATION_OUT_OF_ORDER: switch_call_cause_t = 27;
pub const switch_call_cause_t_SWITCH_CAUSE_INVALID_NUMBER_FORMAT: switch_call_cause_t = 28;
pub const switch_call_cause_t_SWITCH_CAUSE_FACILITY_REJECTED: switch_call_cause_t = 29;
pub const switch_call_cause_t_SWITCH_CAUSE_RESPONSE_TO_STATUS_ENQUIRY: switch_call_cause_t = 30;
pub const switch_call_cause_t_SWITCH_CAUSE_NORMAL_UNSPECIFIED: switch_call_cause_t = 31;
pub const switch_call_cause_t_SWITCH_CAUSE_NORMAL_CIRCUIT_CONGESTION: switch_call_cause_t = 34;
pub const switch_call_cause_t_SWITCH_CAUSE_NETWORK_OUT_OF_ORDER: switch_call_cause_t = 38;
pub const switch_call_cause_t_SWITCH_CAUSE_NORMAL_TEMPORARY_FAILURE: switch_call_cause_t = 41;
pub const switch_call_cause_t_SWITCH_CAUSE_SWITCH_CONGESTION: switch_call_cause_t = 42;
pub const switch_call_cause_t_SWITCH_CAUSE_ACCESS_INFO_DISCARDED: switch_call_cause_t = 43;
pub const switch_call_cause_t_SWITCH_CAUSE_REQUESTED_CHAN_UNAVAIL: switch_call_cause_t = 44;
pub const switch_call_cause_t_SWITCH_CAUSE_PRE_EMPTED: switch_call_cause_t = 45;
pub const switch_call_cause_t_SWITCH_CAUSE_FACILITY_NOT_SUBSCRIBED: switch_call_cause_t = 50;
pub const switch_call_cause_t_SWITCH_CAUSE_OUTGOING_CALL_BARRED: switch_call_cause_t = 52;
pub const switch_call_cause_t_SWITCH_CAUSE_INCOMING_CALL_BARRED: switch_call_cause_t = 54;
pub const switch_call_cause_t_SWITCH_CAUSE_BEARERCAPABILITY_NOTAUTH: switch_call_cause_t = 57;
pub const switch_call_cause_t_SWITCH_CAUSE_BEARERCAPABILITY_NOTAVAIL: switch_call_cause_t = 58;
pub const switch_call_cause_t_SWITCH_CAUSE_SERVICE_UNAVAILABLE: switch_call_cause_t = 63;
pub const switch_call_cause_t_SWITCH_CAUSE_BEARERCAPABILITY_NOTIMPL: switch_call_cause_t = 65;
pub const switch_call_cause_t_SWITCH_CAUSE_CHAN_NOT_IMPLEMENTED: switch_call_cause_t = 66;
pub const switch_call_cause_t_SWITCH_CAUSE_FACILITY_NOT_IMPLEMENTED: switch_call_cause_t = 69;
pub const switch_call_cause_t_SWITCH_CAUSE_SERVICE_NOT_IMPLEMENTED: switch_call_cause_t = 79;
pub const switch_call_cause_t_SWITCH_CAUSE_INVALID_CALL_REFERENCE: switch_call_cause_t = 81;
pub const switch_call_cause_t_SWITCH_CAUSE_INCOMPATIBLE_DESTINATION: switch_call_cause_t = 88;
pub const switch_call_cause_t_SWITCH_CAUSE_INVALID_MSG_UNSPECIFIED: switch_call_cause_t = 95;
pub const switch_call_cause_t_SWITCH_CAUSE_MANDATORY_IE_MISSING: switch_call_cause_t = 96;
pub const switch_call_cause_t_SWITCH_CAUSE_MESSAGE_TYPE_NONEXIST: switch_call_cause_t = 97;
pub const switch_call_cause_t_SWITCH_CAUSE_WRONG_MESSAGE: switch_call_cause_t = 98;
pub const switch_call_cause_t_SWITCH_CAUSE_IE_NONEXIST: switch_call_cause_t = 99;
pub const switch_call_cause_t_SWITCH_CAUSE_INVALID_IE_CONTENTS: switch_call_cause_t = 100;
pub const switch_call_cause_t_SWITCH_CAUSE_WRONG_CALL_STATE: switch_call_cause_t = 101;
pub const switch_call_cause_t_SWITCH_CAUSE_RECOVERY_ON_TIMER_EXPIRE: switch_call_cause_t = 102;
pub const switch_call_cause_t_SWITCH_CAUSE_MANDATORY_IE_LENGTH_ERROR: switch_call_cause_t = 103;
pub const switch_call_cause_t_SWITCH_CAUSE_PROTOCOL_ERROR: switch_call_cause_t = 111;
pub const switch_call_cause_t_SWITCH_CAUSE_INTERWORKING: switch_call_cause_t = 127;
pub const switch_call_cause_t_SWITCH_CAUSE_SUCCESS: switch_call_cause_t = 142;
pub const switch_call_cause_t_SWITCH_CAUSE_ORIGINATOR_CANCEL: switch_call_cause_t = 487;
pub const switch_call_cause_t_SWITCH_CAUSE_CRASH: switch_call_cause_t = 700;
pub const switch_call_cause_t_SWITCH_CAUSE_SYSTEM_SHUTDOWN: switch_call_cause_t = 701;
pub const switch_call_cause_t_SWITCH_CAUSE_LOSE_RACE: switch_call_cause_t = 702;
pub const switch_call_cause_t_SWITCH_CAUSE_MANAGER_REQUEST: switch_call_cause_t = 703;
pub const switch_call_cause_t_SWITCH_CAUSE_BLIND_TRANSFER: switch_call_cause_t = 800;
pub const switch_call_cause_t_SWITCH_CAUSE_ATTENDED_TRANSFER: switch_call_cause_t = 801;
pub const switch_call_cause_t_SWITCH_CAUSE_ALLOTTED_TIMEOUT: switch_call_cause_t = 802;
pub const switch_call_cause_t_SWITCH_CAUSE_USER_CHALLENGE: switch_call_cause_t = 803;
pub const switch_call_cause_t_SWITCH_CAUSE_MEDIA_TIMEOUT: switch_call_cause_t = 804;
pub const switch_call_cause_t_SWITCH_CAUSE_PICKED_OFF: switch_call_cause_t = 805;
pub const switch_call_cause_t_SWITCH_CAUSE_USER_NOT_REGISTERED: switch_call_cause_t = 806;
pub const switch_call_cause_t_SWITCH_CAUSE_PROGRESS_TIMEOUT: switch_call_cause_t = 807;
pub const switch_call_cause_t_SWITCH_CAUSE_INVALID_GATEWAY: switch_call_cause_t = 808;
pub const switch_call_cause_t_SWITCH_CAUSE_GATEWAY_DOWN: switch_call_cause_t = 809;
pub const switch_call_cause_t_SWITCH_CAUSE_INVALID_URL: switch_call_cause_t = 810;
pub const switch_call_cause_t_SWITCH_CAUSE_INVALID_PROFILE: switch_call_cause_t = 811;
pub const switch_call_cause_t_SWITCH_CAUSE_NO_PICKUP: switch_call_cause_t = 812;
pub const switch_call_cause_t_SWITCH_CAUSE_SRTP_READ_ERROR: switch_call_cause_t = 813;
pub const switch_call_cause_t_SWITCH_CAUSE_BOWOUT: switch_call_cause_t = 814;
pub const switch_call_cause_t_SWITCH_CAUSE_BUSY_EVERYWHERE: switch_call_cause_t = 815;
pub const switch_call_cause_t_SWITCH_CAUSE_DECLINE: switch_call_cause_t = 816;
pub const switch_call_cause_t_SWITCH_CAUSE_DOES_NOT_EXIST_ANYWHERE: switch_call_cause_t = 817;
pub const switch_call_cause_t_SWITCH_CAUSE_NOT_ACCEPTABLE: switch_call_cause_t = 818;
pub const switch_call_cause_t_SWITCH_CAUSE_UNWANTED: switch_call_cause_t = 819;
pub const switch_call_cause_t_SWITCH_CAUSE_NO_IDENTITY: switch_call_cause_t = 820;
pub const switch_call_cause_t_SWITCH_CAUSE_BAD_IDENTITY_INFO: switch_call_cause_t = 821;
pub const switch_call_cause_t_SWITCH_CAUSE_UNSUPPORTED_CERTIFICATE: switch_call_cause_t = 822;
pub const switch_call_cause_t_SWITCH_CAUSE_INVALID_IDENTITY: switch_call_cause_t = 823;
pub const switch_call_cause_t_SWITCH_CAUSE_STALE_DATE: switch_call_cause_t = 824;
pub const switch_call_cause_t_SWITCH_CAUSE_REJECT_ALL: switch_call_cause_t = 825;
pub type switch_call_cause_t = ::std::os::raw::c_uint;
pub const switch_session_ctl_t_SCSC_PAUSE_INBOUND: switch_session_ctl_t = 0;
pub const switch_session_ctl_t_SCSC_PAUSE_OUTBOUND: switch_session_ctl_t = 1;
pub const switch_session_ctl_t_SCSC_PAUSE_ALL: switch_session_ctl_t = 2;
pub const switch_session_ctl_t_SCSC_HUPALL: switch_session_ctl_t = 3;
pub const switch_session_ctl_t_SCSC_SHUTDOWN: switch_session_ctl_t = 4;
pub const switch_session_ctl_t_SCSC_CHECK_RUNNING: switch_session_ctl_t = 5;
pub const switch_session_ctl_t_SCSC_LOGLEVEL: switch_session_ctl_t = 6;
pub const switch_session_ctl_t_SCSC_SPS: switch_session_ctl_t = 7;
pub const switch_session_ctl_t_SCSC_LAST_SPS: switch_session_ctl_t = 8;
pub const switch_session_ctl_t_SCSC_RECLAIM: switch_session_ctl_t = 9;
pub const switch_session_ctl_t_SCSC_MAX_SESSIONS: switch_session_ctl_t = 10;
pub const switch_session_ctl_t_SCSC_SYNC_CLOCK: switch_session_ctl_t = 11;
pub const switch_session_ctl_t_SCSC_MAX_DTMF_DURATION: switch_session_ctl_t = 12;
pub const switch_session_ctl_t_SCSC_MIN_DTMF_DURATION: switch_session_ctl_t = 13;
pub const switch_session_ctl_t_SCSC_DEFAULT_DTMF_DURATION: switch_session_ctl_t = 14;
pub const switch_session_ctl_t_SCSC_SHUTDOWN_ELEGANT: switch_session_ctl_t = 15;
pub const switch_session_ctl_t_SCSC_SHUTDOWN_ASAP: switch_session_ctl_t = 16;
pub const switch_session_ctl_t_SCSC_CANCEL_SHUTDOWN: switch_session_ctl_t = 17;
pub const switch_session_ctl_t_SCSC_SEND_SIGHUP: switch_session_ctl_t = 18;
pub const switch_session_ctl_t_SCSC_DEBUG_LEVEL: switch_session_ctl_t = 19;
pub const switch_session_ctl_t_SCSC_FLUSH_DB_HANDLES: switch_session_ctl_t = 20;
pub const switch_session_ctl_t_SCSC_SHUTDOWN_NOW: switch_session_ctl_t = 21;
pub const switch_session_ctl_t_SCSC_REINCARNATE_NOW: switch_session_ctl_t = 22;
pub const switch_session_ctl_t_SCSC_CALIBRATE_CLOCK: switch_session_ctl_t = 23;
pub const switch_session_ctl_t_SCSC_SAVE_HISTORY: switch_session_ctl_t = 24;
pub const switch_session_ctl_t_SCSC_CRASH: switch_session_ctl_t = 25;
pub const switch_session_ctl_t_SCSC_MIN_IDLE_CPU: switch_session_ctl_t = 26;
pub const switch_session_ctl_t_SCSC_VERBOSE_EVENTS: switch_session_ctl_t = 27;
pub const switch_session_ctl_t_SCSC_SHUTDOWN_CHECK: switch_session_ctl_t = 28;
pub const switch_session_ctl_t_SCSC_PAUSE_INBOUND_CHECK: switch_session_ctl_t = 29;
pub const switch_session_ctl_t_SCSC_PAUSE_OUTBOUND_CHECK: switch_session_ctl_t = 30;
pub const switch_session_ctl_t_SCSC_PAUSE_CHECK: switch_session_ctl_t = 31;
pub const switch_session_ctl_t_SCSC_READY_CHECK: switch_session_ctl_t = 32;
pub const switch_session_ctl_t_SCSC_THREADED_SYSTEM_EXEC: switch_session_ctl_t = 33;
pub const switch_session_ctl_t_SCSC_SYNC_CLOCK_WHEN_IDLE: switch_session_ctl_t = 34;
pub const switch_session_ctl_t_SCSC_DEBUG_SQL: switch_session_ctl_t = 35;
pub const switch_session_ctl_t_SCSC_SQL: switch_session_ctl_t = 36;
pub const switch_session_ctl_t_SCSC_API_EXPANSION: switch_session_ctl_t = 37;
pub const switch_session_ctl_t_SCSC_RECOVER: switch_session_ctl_t = 38;
pub const switch_session_ctl_t_SCSC_SPS_PEAK: switch_session_ctl_t = 39;
pub const switch_session_ctl_t_SCSC_SPS_PEAK_FIVEMIN: switch_session_ctl_t = 40;
pub const switch_session_ctl_t_SCSC_SESSIONS_PEAK: switch_session_ctl_t = 41;
pub const switch_session_ctl_t_SCSC_SESSIONS_PEAK_FIVEMIN: switch_session_ctl_t = 42;
pub const switch_session_ctl_t_SCSC_MDNS_RESOLVE: switch_session_ctl_t = 43;
pub const switch_session_ctl_t_SCSC_SHUTDOWN_CAUSE: switch_session_ctl_t = 44;
pub type switch_session_ctl_t = ::std::os::raw::c_uint;
pub const switch_state_handler_flag_t_SSH_FLAG_STICKY: switch_state_handler_flag_t = 1;
pub const switch_state_handler_flag_t_SSH_FLAG_PRE_EXEC: switch_state_handler_flag_t = 2;
pub type switch_state_handler_flag_t = ::std::os::raw::c_uint;
pub type switch_os_socket_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fspr_pool_t {
    _unused: [u8; 0],
}
pub type switch_memory_pool_t = fspr_pool_t;
pub type switch_plc_state_t = *mut ::std::os::raw::c_void;
pub type switch_port_t = u16;
pub type switch_payload_t = u8;
pub type switch_app_log_t = switch_app_log;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_rtp {
    _unused: [u8; 0],
}
pub type switch_rtp_t = switch_rtp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_rtcp {
    _unused: [u8; 0],
}
pub type switch_rtcp_t = switch_rtcp;
#[doc = " \\brief A message object designed to allow unlike technologies to exchange data"]
pub type switch_core_session_message_t = switch_core_session_message;
#[doc = " \\brief An event Header"]
pub type switch_event_header_t = switch_event_header;
#[doc = " \\brief Representation of an event"]
pub type switch_event_t = switch_event;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_event_subclass {
    _unused: [u8; 0],
}
pub type switch_event_subclass_t = switch_event_subclass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_event_node {
    _unused: [u8; 0],
}
pub type switch_event_node_t = switch_event_node;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_loadable_module {
    _unused: [u8; 0],
}
pub type switch_loadable_module_t = switch_loadable_module;
#[doc = " \\brief An abstraction of a data frame"]
pub type switch_frame_t = switch_frame;
#[doc = " \\brief An abstraction of a rtcp frame"]
pub type switch_rtcp_frame_t = switch_rtcp_frame;
#[doc = " \\brief A channel"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_channel {
    _unused: [u8; 0],
}
pub type switch_channel_t = switch_channel;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_sql_queue_manager {
    _unused: [u8; 0],
}
pub type switch_sql_queue_manager_t = switch_sql_queue_manager;
#[doc = " an abstract representation of a file handle (some parameters based on compat with libsndfile)"]
pub type switch_file_handle_t = switch_file_handle;
#[doc = " \\brief Call Specific Data"]
pub type switch_caller_profile_t = switch_caller_profile;
#[doc = " \\brief An Abstract Representation of a dialplan extension"]
pub type switch_caller_extension_t = switch_caller_extension;
#[doc = " \\brief An Abstract Representation of a dialplan Application"]
pub type switch_caller_application_t = switch_caller_application;
pub type switch_state_handler_table_t = switch_state_handler_table;
#[doc = " \\brief Abstract handler to a timer module"]
pub type switch_timer_t = switch_timer;
#[doc = " an abstract handle to a codec module"]
pub type switch_codec_t = switch_codec;
#[doc = " \\brief A generic object to pass as a thread's session object to allow mutiple arguements and a pool"]
pub type switch_core_thread_session_t = switch_core_thread_session;
#[doc = " \\brief A table of settings and callbacks that define a paticular implementation of a codec"]
pub type switch_codec_implementation_t = switch_codec_implementation;
#[doc = " @defgroup switch_buffer Buffer Routines\n @ingroup core1\n The purpose of this module is to make a plain buffering interface that can be used for read/write buffers\n throughout the application.  The first implementation was done to provide the functionality and the interface\n and I think it can be optimized under the hood as we go using bucket brigades and/or ring buffering techniques.\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_buffer {
    _unused: [u8; 0],
}
pub type switch_buffer_t = switch_buffer;
pub type switch_codec_settings_t = switch_codec_settings;
#[doc = " an abstract handle of a fmtp parsed by codec"]
pub type switch_codec_fmtp_t = switch_codec_fmtp;
pub type switch_coredb_handle_t = switch_coredb_handle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_odbc_handle {
    _unused: [u8; 0],
}
pub type switch_odbc_handle_t = switch_odbc_handle;
#[doc = " an abstract representation of a database interface."]
pub type switch_database_interface_handle_t = switch_database_interface_handle;
#[doc = " \\brief A table of i/o routines that an endpoint interface can implement"]
pub type switch_io_routines_t = switch_io_routines;
#[doc = " an abstract representation of a tts speech interface."]
pub type switch_speech_handle_t = switch_speech_handle;
#[doc = " an abstract representation of an asr speech interface."]
pub type switch_asr_handle_t = switch_asr_handle;
#[doc = " an abstract representation of a directory interface."]
pub type switch_directory_handle_t = switch_directory_handle;
#[doc = " \\brief The abstraction of a loadable module"]
pub type switch_loadable_module_interface_t = switch_loadable_module_interface;
#[doc = " \\brief Abstraction of an module endpoint interface\nThis is the glue between the abstract idea of a \"channel\" and what is really going on under the\nhood.\t Each endpoint module fills out one of these tables and makes it available when a channel\nis created of it's paticular type."]
pub type switch_endpoint_interface_t = switch_endpoint_interface;
#[doc = " \\brief A table of functions that a timer module implements"]
pub type switch_timer_interface_t = switch_timer_interface;
#[doc = " \\brief Abstract interface to a dialplan module"]
pub type switch_dialplan_interface_t = switch_dialplan_interface;
#[doc = " \\brief Top level module interface to implement a series of codec implementations"]
pub type switch_codec_interface_t = switch_codec_interface;
#[doc = " \\brief A module interface to implement an application"]
pub type switch_application_interface_t = switch_application_interface;
#[doc = " \\brief A module interface to implement a chat application"]
pub type switch_chat_application_interface_t = switch_chat_application_interface;
#[doc = " \\brief A module interface to implement an api function"]
pub type switch_api_interface_t = switch_api_interface;
#[doc = " \\brief A module interface to implement a json api function"]
pub type switch_json_api_interface_t = switch_json_api_interface;
#[doc = " \\brief Abstract interface to a file format module"]
pub type switch_file_interface_t = switch_file_interface;
#[doc = " \\brief Abstract interface to a speech module"]
pub type switch_speech_interface_t = switch_speech_interface;
#[doc = " \\brief Abstract interface to an asr module"]
pub type switch_asr_interface_t = switch_asr_interface;
#[doc = " \\brief Abstract interface to a directory module"]
pub type switch_directory_interface_t = switch_directory_interface;
#[doc = " \\brief Abstract interface to a chat module"]
pub type switch_chat_interface_t = switch_chat_interface;
#[doc = " \\brief Abstract interface to a management module"]
pub type switch_management_interface_t = switch_management_interface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_core_port_allocator {
    _unused: [u8; 0],
}
pub type switch_core_port_allocator_t = switch_core_port_allocator;
#[doc = " \\brief An audio bug"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_media_bug {
    _unused: [u8; 0],
}
pub type switch_media_bug_t = switch_media_bug;
#[doc = " \\brief Abstract interface to a limit module"]
pub type switch_limit_interface_t = switch_limit_interface;
#[doc = " \\brief Abstract interface to a database module"]
pub type switch_database_interface_t = switch_database_interface;
pub type hashtable_destructor_t =
    ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_console_callback_match_node {
    pub val: *mut ::std::os::raw::c_char,
    pub next: *mut switch_console_callback_match_node,
}
#[test]
fn bindgen_test_layout_switch_console_callback_match_node() {
    const UNINIT: ::std::mem::MaybeUninit<switch_console_callback_match_node> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_console_callback_match_node>(),
        16usize,
        concat!("Size of: ", stringify!(switch_console_callback_match_node))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_console_callback_match_node>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(switch_console_callback_match_node)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_console_callback_match_node),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_console_callback_match_node),
            "::",
            stringify!(next)
        )
    );
}
pub type switch_console_callback_match_node_t = switch_console_callback_match_node;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_console_callback_match {
    pub head: *mut switch_console_callback_match_node,
    pub end: *mut switch_console_callback_match_node,
    pub count: ::std::os::raw::c_int,
    pub dynamic: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_switch_console_callback_match() {
    const UNINIT: ::std::mem::MaybeUninit<switch_console_callback_match> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_console_callback_match>(),
        24usize,
        concat!("Size of: ", stringify!(switch_console_callback_match))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_console_callback_match>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_console_callback_match))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_console_callback_match),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_console_callback_match),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_console_callback_match),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_console_callback_match),
            "::",
            stringify!(dynamic)
        )
    );
}
pub type switch_console_callback_match_t = switch_console_callback_match;
pub type switch_media_bug_exec_cb_t = ::std::option::Option<
    unsafe extern "C" fn(bug: *mut switch_media_bug_t, user_data: *mut ::std::os::raw::c_void),
>;
pub type switch_core_video_thread_callback_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        session: *mut switch_core_session_t,
        frame: *mut switch_frame_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> switch_status_t,
>;
pub type switch_core_text_thread_callback_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        session: *mut switch_core_session_t,
        frame: *mut switch_frame_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> switch_status_t,
>;
pub type switch_cap_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        var: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
pub type switch_console_complete_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        matches: *mut *mut switch_console_callback_match_t,
    ) -> switch_status_t,
>;
pub type switch_media_bug_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut switch_media_bug_t,
        arg2: *mut ::std::os::raw::c_void,
        arg3: switch_abc_type_t,
    ) -> switch_bool_t,
>;
pub type switch_tone_detect_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut switch_core_session_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> switch_bool_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_xml_binding {
    _unused: [u8; 0],
}
pub type switch_xml_binding_t = switch_xml_binding;
pub type switch_engine_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        session: *mut switch_core_session_t,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
pub type switch_core_codec_encode_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        codec: *mut switch_codec_t,
        other_codec: *mut switch_codec_t,
        decoded_data: *mut ::std::os::raw::c_void,
        decoded_data_len: u32,
        decoded_rate: u32,
        encoded_data: *mut ::std::os::raw::c_void,
        encoded_data_len: *mut u32,
        encoded_rate: *mut u32,
        flag: *mut ::std::os::raw::c_uint,
    ) -> switch_status_t,
>;
pub type switch_core_codec_decode_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        codec: *mut switch_codec_t,
        other_codec: *mut switch_codec_t,
        encoded_data: *mut ::std::os::raw::c_void,
        encoded_data_len: u32,
        encoded_rate: u32,
        decoded_data: *mut ::std::os::raw::c_void,
        decoded_data_len: *mut u32,
        decoded_rate: *mut u32,
        flag: *mut ::std::os::raw::c_uint,
    ) -> switch_status_t,
>;
pub type switch_core_codec_video_encode_func_t = ::std::option::Option<
    unsafe extern "C" fn(codec: *mut switch_codec_t, frame: *mut switch_frame_t) -> switch_status_t,
>;
pub type switch_core_codec_video_decode_func_t = ::std::option::Option<
    unsafe extern "C" fn(codec: *mut switch_codec_t, frame: *mut switch_frame_t) -> switch_status_t,
>;
pub const switch_codec_control_command_t_SCC_VIDEO_GEN_KEYFRAME: switch_codec_control_command_t = 0;
pub const switch_codec_control_command_t_SCC_VIDEO_BANDWIDTH: switch_codec_control_command_t = 1;
pub const switch_codec_control_command_t_SCC_VIDEO_RESET: switch_codec_control_command_t = 2;
pub const switch_codec_control_command_t_SCC_AUDIO_PACKET_LOSS: switch_codec_control_command_t = 3;
pub const switch_codec_control_command_t_SCC_AUDIO_ADJUST_BITRATE: switch_codec_control_command_t =
    4;
pub const switch_codec_control_command_t_SCC_AUDIO_VAD: switch_codec_control_command_t = 5;
pub const switch_codec_control_command_t_SCC_DEBUG: switch_codec_control_command_t = 6;
pub const switch_codec_control_command_t_SCC_CODEC_SPECIFIC: switch_codec_control_command_t = 7;
pub type switch_codec_control_command_t = ::std::os::raw::c_uint;
pub const switch_codec_control_type_t_SCCT_NONE: switch_codec_control_type_t = 0;
pub const switch_codec_control_type_t_SCCT_STRING: switch_codec_control_type_t = 1;
pub const switch_codec_control_type_t_SCCT_INT: switch_codec_control_type_t = 2;
pub type switch_codec_control_type_t = ::std::os::raw::c_uint;
pub const switch_io_type_t_SWITCH_IO_READ: switch_io_type_t = 0;
pub const switch_io_type_t_SWITCH_IO_WRITE: switch_io_type_t = 1;
pub type switch_io_type_t = ::std::os::raw::c_uint;
pub type switch_core_codec_control_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        codec: *mut switch_codec_t,
        cmd: switch_codec_control_command_t,
        ctype: switch_codec_control_type_t,
        cmd_data: *mut ::std::os::raw::c_void,
        atype: switch_codec_control_type_t,
        cmd_arg: *mut ::std::os::raw::c_void,
        rtype: *mut switch_codec_control_type_t,
        ret_data: *mut *mut ::std::os::raw::c_void,
    ) -> switch_status_t,
>;
pub type switch_core_codec_init_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut switch_codec_t,
        arg2: switch_codec_flag_t,
        codec_settings: *const switch_codec_settings_t,
    ) -> switch_status_t,
>;
pub type switch_core_codec_fmtp_parse_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        fmtp: *const ::std::os::raw::c_char,
        codec_fmtp: *mut switch_codec_fmtp_t,
    ) -> switch_status_t,
>;
pub type switch_core_codec_destroy_func_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut switch_codec_t) -> switch_status_t>;
pub type switch_chat_application_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut switch_event_t,
        arg2: *const ::std::os::raw::c_char,
    ) -> switch_status_t,
>;
pub type switch_application_function_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut switch_core_session_t, arg2: *const ::std::os::raw::c_char),
>;
pub type switch_core_recover_callback_t = ::std::option::Option<
    unsafe extern "C" fn(session: *mut switch_core_session_t) -> ::std::os::raw::c_int,
>;
pub type switch_event_callback_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut switch_event_t)>;
pub type switch_dialplan_hunt_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut switch_core_session_t,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut switch_caller_profile_t,
    ) -> *mut switch_caller_extension_t,
>;
pub type switch_hash_delete_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        key: *const ::std::os::raw::c_void,
        val: *const ::std::os::raw::c_void,
        pData: *mut ::std::os::raw::c_void,
    ) -> switch_bool_t,
>;
#[doc = "\\defgroup sched1 Scheduler\n\\ingroup core1\n\\{"]
pub type switch_scheduler_task_t = switch_scheduler_task;
pub type switch_scheduler_func_t =
    ::std::option::Option<unsafe extern "C" fn(task: *mut switch_scheduler_task_t)>;
pub type switch_state_handler_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut switch_core_session_t) -> switch_status_t,
>;
pub type switch_stream_handle_t = switch_stream_handle;
pub type switch_stream_handle_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        handle: *mut switch_stream_handle_t,
        len: *mut ::std::os::raw::c_int,
    ) -> *mut u8,
>;
pub type switch_stream_handle_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        handle: *mut switch_stream_handle_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> switch_status_t,
>;
pub type switch_stream_handle_raw_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        handle: *mut switch_stream_handle_t,
        data: *mut u8,
        datalen: switch_size_t,
    ) -> switch_status_t,
>;
pub type switch_api_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        cmd: *const ::std::os::raw::c_char,
        session: *mut switch_core_session_t,
        stream: *mut switch_stream_handle_t,
    ) -> switch_status_t,
>;
pub type switch_json_api_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        json: *const cJSON,
        session: *mut switch_core_session_t,
        json_reply: *mut *mut cJSON,
    ) -> switch_status_t,
>;
pub type switch_input_callback_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        session: *mut switch_core_session_t,
        input: *mut ::std::os::raw::c_void,
        input_type: switch_input_type_t,
        buf: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_uint,
    ) -> switch_status_t,
>;
pub type switch_read_frame_callback_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        session: *mut switch_core_session_t,
        frame: *mut switch_frame_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> switch_status_t,
>;
#[doc = " \\brief Abstract interface to a say module"]
pub type switch_say_interface_t = switch_say_interface;
pub const dm_match_type_t_DM_MATCH_POSITIVE: dm_match_type_t = 0;
pub const dm_match_type_t_DM_MATCH_NEGATIVE: dm_match_type_t = 1;
pub type dm_match_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_ivr_dmachine {
    _unused: [u8; 0],
}
pub type switch_ivr_dmachine_t = switch_ivr_dmachine;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_ivr_dmachine_match {
    pub dmachine: *mut switch_ivr_dmachine_t,
    pub match_digits: *const ::std::os::raw::c_char,
    pub match_key: i32,
    pub type_: dm_match_type_t,
    pub user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_switch_ivr_dmachine_match() {
    const UNINIT: ::std::mem::MaybeUninit<switch_ivr_dmachine_match> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_ivr_dmachine_match>(),
        32usize,
        concat!("Size of: ", stringify!(switch_ivr_dmachine_match))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_ivr_dmachine_match>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_ivr_dmachine_match))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dmachine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_ivr_dmachine_match),
            "::",
            stringify!(dmachine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).match_digits) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_ivr_dmachine_match),
            "::",
            stringify!(match_digits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).match_key) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_ivr_dmachine_match),
            "::",
            stringify!(match_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_ivr_dmachine_match),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_ivr_dmachine_match),
            "::",
            stringify!(user_data)
        )
    );
}
pub type switch_ivr_dmachine_match_t = switch_ivr_dmachine_match;
pub type switch_ivr_dmachine_callback_t = ::std::option::Option<
    unsafe extern "C" fn(match_: *mut switch_ivr_dmachine_match_t) -> switch_status_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_input_args_t {
    pub input_callback: switch_input_callback_function_t,
    pub buf: *mut ::std::os::raw::c_void,
    pub buflen: u32,
    pub read_frame_callback: switch_read_frame_callback_function_t,
    pub user_data: *mut ::std::os::raw::c_void,
    pub dmachine: *mut switch_ivr_dmachine_t,
    pub loops: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_switch_input_args_t() {
    const UNINIT: ::std::mem::MaybeUninit<switch_input_args_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_input_args_t>(),
        56usize,
        concat!("Size of: ", stringify!(switch_input_args_t))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_input_args_t>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_input_args_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_callback) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_input_args_t),
            "::",
            stringify!(input_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_input_args_t),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buflen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_input_args_t),
            "::",
            stringify!(buflen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_frame_callback) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_input_args_t),
            "::",
            stringify!(read_frame_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_input_args_t),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dmachine) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_input_args_t),
            "::",
            stringify!(dmachine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loops) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_input_args_t),
            "::",
            stringify!(loops)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_say_args_t {
    pub type_: switch_say_type_t,
    pub method: switch_say_method_t,
    pub gender: switch_say_gender_t,
    pub ext: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_switch_say_args_t() {
    const UNINIT: ::std::mem::MaybeUninit<switch_say_args_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_say_args_t>(),
        24usize,
        concat!("Size of: ", stringify!(switch_say_args_t))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_say_args_t>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_say_args_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_say_args_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_say_args_t),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gender) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_say_args_t),
            "::",
            stringify!(gender)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ext) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_say_args_t),
            "::",
            stringify!(ext)
        )
    );
}
pub type switch_say_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        session: *mut switch_core_session_t,
        tosay: *mut ::std::os::raw::c_char,
        say_args: *mut switch_say_args_t,
        args: *mut switch_input_args_t,
    ) -> switch_status_t,
>;
pub type switch_say_string_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        session: *mut switch_core_session_t,
        tosay: *mut ::std::os::raw::c_char,
        say_args: *mut switch_say_args_t,
        rstr: *mut *mut ::std::os::raw::c_char,
    ) -> switch_status_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_say_file_handle {
    _unused: [u8; 0],
}
pub type switch_say_file_handle_t = switch_say_file_handle;
pub type switch_new_say_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        sh: *mut switch_say_file_handle_t,
        tosay: *mut ::std::os::raw::c_char,
        say_args: *mut switch_say_args_t,
    ) -> switch_status_t,
>;
pub type switch_xml_t = *mut switch_xml;
pub type switch_core_time_duration_t = switch_core_time_duration;
pub type switch_xml_open_root_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        reload: u8,
        err: *mut *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ) -> switch_xml_t,
>;
pub type switch_xml_search_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        section: *const ::std::os::raw::c_char,
        tag_name: *const ::std::os::raw::c_char,
        key_name: *const ::std::os::raw::c_char,
        key_value: *const ::std::os::raw::c_char,
        params: *mut switch_event_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> switch_xml_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_hashtable {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_hashtable_iterator {
    _unused: [u8; 0],
}
pub type switch_hash_t = switch_hashtable;
pub type switch_inthash_t = switch_hashtable;
pub type switch_hash_index_t = switch_hashtable_iterator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_network_list {
    _unused: [u8; 0],
}
pub type switch_network_list_t = switch_network_list;
pub type switch_module_load_t = ::std::option::Option<
    unsafe extern "C" fn(
        module_interface: *mut *mut switch_loadable_module_interface_t,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t,
>;
pub type switch_module_runtime_t = ::std::option::Option<unsafe extern "C" fn() -> switch_status_t>;
pub type switch_module_shutdown_t =
    ::std::option::Option<unsafe extern "C" fn() -> switch_status_t>;
pub const switch_thread_priority_t_SWITCH_PRI_LOW: switch_thread_priority_t = 1;
pub const switch_thread_priority_t_SWITCH_PRI_NORMAL: switch_thread_priority_t = 10;
pub const switch_thread_priority_t_SWITCH_PRI_IMPORTANT: switch_thread_priority_t = 50;
pub const switch_thread_priority_t_SWITCH_PRI_REALTIME: switch_thread_priority_t = 99;
pub type switch_thread_priority_t = ::std::os::raw::c_uint;
pub const switch_module_flag_enum_t_SMODF_NONE: switch_module_flag_enum_t = 0;
pub const switch_module_flag_enum_t_SMODF_GLOBAL_SYMBOLS: switch_module_flag_enum_t = 1;
pub type switch_module_flag_enum_t = ::std::os::raw::c_uint;
pub type switch_module_flag_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_loadable_module_function_table {
    pub switch_api_version: ::std::os::raw::c_int,
    pub load: switch_module_load_t,
    pub shutdown: switch_module_shutdown_t,
    pub runtime: switch_module_runtime_t,
    pub flags: switch_module_flag_t,
}
#[test]
fn bindgen_test_layout_switch_loadable_module_function_table() {
    const UNINIT: ::std::mem::MaybeUninit<switch_loadable_module_function_table> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_loadable_module_function_table>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(switch_loadable_module_function_table)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<switch_loadable_module_function_table>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(switch_loadable_module_function_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).switch_api_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_loadable_module_function_table),
            "::",
            stringify!(switch_api_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).load) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_loadable_module_function_table),
            "::",
            stringify!(load)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shutdown) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_loadable_module_function_table),
            "::",
            stringify!(shutdown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).runtime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_loadable_module_function_table),
            "::",
            stringify!(runtime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_loadable_module_function_table),
            "::",
            stringify!(flags)
        )
    );
}
pub type switch_loadable_module_function_table_t = switch_loadable_module_function_table;
pub type switch_modulename_callback_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        module_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
pub type switch_slin_data_t = switch_slin_data;
#[doc = " \\brief A digit stream parser object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_ivr_digit_stream_parser {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sql_queue_manager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_media_handle_s {
    _unused: [u8; 0],
}
pub type switch_media_handle_t = switch_media_handle_s;
pub type switch_event_channel_id_t = u32;
pub type switch_event_channel_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        event_channel: *const ::std::os::raw::c_char,
        json: *mut cJSON,
        key: *const ::std::os::raw::c_char,
        id: switch_event_channel_id_t,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_live_array_s {
    _unused: [u8; 0],
}
pub type switch_live_array_t = switch_live_array_s;
pub const switch_sdp_type_t_SDP_TYPE_REQUEST: switch_sdp_type_t = 0;
pub const switch_sdp_type_t_SDP_TYPE_RESPONSE: switch_sdp_type_t = 1;
pub type switch_sdp_type_t = ::std::os::raw::c_uint;
pub const switch_rtp_crypto_key_type_t_AEAD_AES_256_GCM_8: switch_rtp_crypto_key_type_t = 0;
pub const switch_rtp_crypto_key_type_t_AEAD_AES_256_GCM: switch_rtp_crypto_key_type_t = 1;
pub const switch_rtp_crypto_key_type_t_AEAD_AES_128_GCM_8: switch_rtp_crypto_key_type_t = 2;
pub const switch_rtp_crypto_key_type_t_AEAD_AES_128_GCM: switch_rtp_crypto_key_type_t = 3;
pub const switch_rtp_crypto_key_type_t_AES_CM_256_HMAC_SHA1_80: switch_rtp_crypto_key_type_t = 4;
pub const switch_rtp_crypto_key_type_t_AES_CM_192_HMAC_SHA1_80: switch_rtp_crypto_key_type_t = 5;
pub const switch_rtp_crypto_key_type_t_AES_CM_128_HMAC_SHA1_80: switch_rtp_crypto_key_type_t = 6;
pub const switch_rtp_crypto_key_type_t_AES_CM_256_HMAC_SHA1_32: switch_rtp_crypto_key_type_t = 7;
pub const switch_rtp_crypto_key_type_t_AES_CM_192_HMAC_SHA1_32: switch_rtp_crypto_key_type_t = 8;
pub const switch_rtp_crypto_key_type_t_AES_CM_128_HMAC_SHA1_32: switch_rtp_crypto_key_type_t = 9;
pub const switch_rtp_crypto_key_type_t_AES_CM_128_NULL_AUTH: switch_rtp_crypto_key_type_t = 10;
pub const switch_rtp_crypto_key_type_t_CRYPTO_INVALID: switch_rtp_crypto_key_type_t = 11;
pub type switch_rtp_crypto_key_type_t = ::std::os::raw::c_uint;
pub const switch_rtp_crypto_key_param_method_type_t_CRYPTO_KEY_PARAM_METHOD_INLINE:
    switch_rtp_crypto_key_param_method_type_t = 0;
pub const switch_rtp_crypto_key_param_method_type_t_CRYPTO_KEY_PARAM_METHOD_INVALID:
    switch_rtp_crypto_key_param_method_type_t = 1;
pub type switch_rtp_crypto_key_param_method_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct payload_map_s {
    pub type_: switch_media_type_t,
    pub sdp_type: switch_sdp_type_t,
    pub ptime: u32,
    pub rate: u32,
    pub allocated: u8,
    pub negotiated: u8,
    pub current: u8,
    pub hash: ::std::os::raw::c_ulong,
    pub rm_encoding: *mut ::std::os::raw::c_char,
    pub iananame: *mut ::std::os::raw::c_char,
    pub modname: *mut ::std::os::raw::c_char,
    pub pt: switch_payload_t,
    pub rm_rate: ::std::os::raw::c_ulong,
    pub adv_rm_rate: ::std::os::raw::c_ulong,
    pub codec_ms: u32,
    pub bitrate: u32,
    pub rm_fmtp: *mut ::std::os::raw::c_char,
    pub recv_pt: switch_payload_t,
    pub fmtp_out: *mut ::std::os::raw::c_char,
    pub remote_sdp_ip: *mut ::std::os::raw::c_char,
    pub remote_sdp_port: switch_port_t,
    pub channels: ::std::os::raw::c_int,
    pub adv_channels: ::std::os::raw::c_int,
    pub next: *mut payload_map_s,
}
#[test]
fn bindgen_test_layout_payload_map_s() {
    const UNINIT: ::std::mem::MaybeUninit<payload_map_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<payload_map_s>(),
        144usize,
        concat!("Size of: ", stringify!(payload_map_s))
    );
    assert_eq!(
        ::std::mem::align_of::<payload_map_s>(),
        8usize,
        concat!("Alignment of ", stringify!(payload_map_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(payload_map_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sdp_type) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(payload_map_s),
            "::",
            stringify!(sdp_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(payload_map_s),
            "::",
            stringify!(ptime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(payload_map_s),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocated) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(payload_map_s),
            "::",
            stringify!(allocated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).negotiated) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(payload_map_s),
            "::",
            stringify!(negotiated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(payload_map_s),
            "::",
            stringify!(current)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(payload_map_s),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rm_encoding) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(payload_map_s),
            "::",
            stringify!(rm_encoding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iananame) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(payload_map_s),
            "::",
            stringify!(iananame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modname) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(payload_map_s),
            "::",
            stringify!(modname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pt) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(payload_map_s),
            "::",
            stringify!(pt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rm_rate) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(payload_map_s),
            "::",
            stringify!(rm_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adv_rm_rate) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(payload_map_s),
            "::",
            stringify!(adv_rm_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec_ms) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(payload_map_s),
            "::",
            stringify!(codec_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitrate) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(payload_map_s),
            "::",
            stringify!(bitrate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rm_fmtp) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(payload_map_s),
            "::",
            stringify!(rm_fmtp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recv_pt) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(payload_map_s),
            "::",
            stringify!(recv_pt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fmtp_out) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(payload_map_s),
            "::",
            stringify!(fmtp_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_sdp_ip) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(payload_map_s),
            "::",
            stringify!(remote_sdp_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_sdp_port) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(payload_map_s),
            "::",
            stringify!(remote_sdp_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(payload_map_s),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adv_channels) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(payload_map_s),
            "::",
            stringify!(adv_channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(payload_map_s),
            "::",
            stringify!(next)
        )
    );
}
pub type payload_map_t = payload_map_s;
pub const switch_media_flow_t_SWITCH_MEDIA_FLOW_SENDRECV: switch_media_flow_t = 0;
pub const switch_media_flow_t_SWITCH_MEDIA_FLOW_SENDONLY: switch_media_flow_t = 1;
pub const switch_media_flow_t_SWITCH_MEDIA_FLOW_RECVONLY: switch_media_flow_t = 2;
pub const switch_media_flow_t_SWITCH_MEDIA_FLOW_INACTIVE: switch_media_flow_t = 3;
pub const switch_media_flow_t_SWITCH_MEDIA_FLOW_DISABLED: switch_media_flow_t = 4;
pub type switch_media_flow_t = ::std::os::raw::c_uint;
pub const switch_core_media_ice_type_t_ICE_GOOGLE_JINGLE: switch_core_media_ice_type_t = 1;
pub const switch_core_media_ice_type_t_ICE_VANILLA: switch_core_media_ice_type_t = 2;
pub const switch_core_media_ice_type_t_ICE_CONTROLLED: switch_core_media_ice_type_t = 4;
pub const switch_core_media_ice_type_t_ICE_LITE: switch_core_media_ice_type_t = 8;
pub type switch_core_media_ice_type_t = ::std::os::raw::c_uint;
pub const switch_poll_t_SWITCH_POLL_READ: switch_poll_t = 1;
pub const switch_poll_t_SWITCH_POLL_WRITE: switch_poll_t = 2;
pub const switch_poll_t_SWITCH_POLL_ERROR: switch_poll_t = 4;
pub const switch_poll_t_SWITCH_POLL_HUP: switch_poll_t = 8;
pub const switch_poll_t_SWITCH_POLL_RDNORM: switch_poll_t = 16;
pub const switch_poll_t_SWITCH_POLL_RDBAND: switch_poll_t = 32;
pub const switch_poll_t_SWITCH_POLL_PRI: switch_poll_t = 64;
pub const switch_poll_t_SWITCH_POLL_INVALID: switch_poll_t = 128;
pub type switch_poll_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_waitlist_s {
    pub sock: switch_os_socket_t,
    pub events: u32,
    pub revents: u32,
}
#[test]
fn bindgen_test_layout_switch_waitlist_s() {
    const UNINIT: ::std::mem::MaybeUninit<switch_waitlist_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_waitlist_s>(),
        12usize,
        concat!("Size of: ", stringify!(switch_waitlist_s))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_waitlist_s>(),
        4usize,
        concat!("Alignment of ", stringify!(switch_waitlist_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_waitlist_s),
            "::",
            stringify!(sock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_waitlist_s),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).revents) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_waitlist_s),
            "::",
            stringify!(revents)
        )
    );
}
pub type switch_waitlist_t = switch_waitlist_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_jb_s {
    _unused: [u8; 0],
}
pub type switch_jb_t = switch_jb_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_img_txt_handle_s {
    _unused: [u8; 0],
}
pub type switch_img_txt_handle_t = switch_img_txt_handle_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_frame_buffer_s {
    _unused: [u8; 0],
}
pub type switch_frame_buffer_t = switch_frame_buffer_s;
pub const switch_video_read_flag_t_SVR_BLOCK: switch_video_read_flag_t = 1;
pub const switch_video_read_flag_t_SVR_FLUSH: switch_video_read_flag_t = 2;
pub const switch_video_read_flag_t_SVR_CHECK: switch_video_read_flag_t = 4;
pub type switch_video_read_flag_t = ::std::os::raw::c_uint;
pub const switch_vid_spy_fmt_t_SPY_LOWER_RIGHT_SMALL: switch_vid_spy_fmt_t = 0;
pub const switch_vid_spy_fmt_t_SPY_LOWER_RIGHT_LARGE: switch_vid_spy_fmt_t = 1;
pub const switch_vid_spy_fmt_t_SPY_DUAL_CROP: switch_vid_spy_fmt_t = 2;
pub type switch_vid_spy_fmt_t = ::std::os::raw::c_uint;
pub const switch_file_command_t_SCFC_FLUSH_AUDIO: switch_file_command_t = 0;
pub const switch_file_command_t_SCFC_PAUSE_READ: switch_file_command_t = 1;
pub const switch_file_command_t_SCFC_PAUSE_WRITE: switch_file_command_t = 2;
pub const switch_file_command_t_SCFC_RESUME_WRITE: switch_file_command_t = 3;
pub type switch_file_command_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_rtp_text_factory_s {
    _unused: [u8; 0],
}
pub type switch_rtp_text_factory_t = switch_rtp_text_factory_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_agc_s {
    _unused: [u8; 0],
}
pub type switch_agc_t = switch_agc_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_chromakey_s {
    _unused: [u8; 0],
}
pub type switch_chromakey_t = switch_chromakey_s;
pub const switch_video_encode_speed_t_SWITCH_VIDEO_ENCODE_SPEED_DEFAULT:
    switch_video_encode_speed_t = 0;
pub const switch_video_encode_speed_t_SWITCH_VIDEO_ENCODE_SPEED_FAST: switch_video_encode_speed_t =
    0;
pub const switch_video_encode_speed_t_SWITCH_VIDEO_ENCODE_SPEED_MEDIUM:
    switch_video_encode_speed_t = 1;
pub const switch_video_encode_speed_t_SWITCH_VIDEO_ENCODE_SPEED_SLOW: switch_video_encode_speed_t =
    2;
pub type switch_video_encode_speed_t = ::std::os::raw::c_uint;
pub const switch_video_profile_t_SWITCH_VIDEO_PROFILE_BASELINE: switch_video_profile_t = 0;
pub const switch_video_profile_t_SWITCH_VIDEO_PROFILE_MAIN: switch_video_profile_t = 1;
pub const switch_video_profile_t_SWITCH_VIDEO_PROFILE_HIGH: switch_video_profile_t = 2;
pub type switch_video_profile_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_mm_s {
    pub samplerate: ::std::os::raw::c_int,
    pub channels: ::std::os::raw::c_int,
    pub keyint: ::std::os::raw::c_int,
    pub ab: ::std::os::raw::c_int,
    pub vb: ::std::os::raw::c_int,
    pub vw: ::std::os::raw::c_int,
    pub vh: ::std::os::raw::c_int,
    pub cbr: ::std::os::raw::c_int,
    pub fps: f32,
    pub source_fps: f32,
    pub source_kps: ::std::os::raw::c_int,
    pub vbuf: ::std::os::raw::c_int,
    pub vprofile: switch_video_profile_t,
    pub vencspd: switch_video_encode_speed_t,
    pub try_hardware_encoder: u8,
    pub scale_w: ::std::os::raw::c_int,
    pub scale_h: ::std::os::raw::c_int,
    pub fmt: switch_img_fmt_t,
    pub auth_username: *mut ::std::os::raw::c_char,
    pub auth_password: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_switch_mm_s() {
    const UNINIT: ::std::mem::MaybeUninit<switch_mm_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_mm_s>(),
        88usize,
        concat!("Size of: ", stringify!(switch_mm_s))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_mm_s>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_mm_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samplerate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_mm_s),
            "::",
            stringify!(samplerate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_mm_s),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyint) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_mm_s),
            "::",
            stringify!(keyint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ab) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_mm_s),
            "::",
            stringify!(ab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vb) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_mm_s),
            "::",
            stringify!(vb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vw) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_mm_s),
            "::",
            stringify!(vw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vh) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_mm_s),
            "::",
            stringify!(vh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbr) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_mm_s),
            "::",
            stringify!(cbr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fps) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_mm_s),
            "::",
            stringify!(fps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_fps) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_mm_s),
            "::",
            stringify!(source_fps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_kps) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_mm_s),
            "::",
            stringify!(source_kps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vbuf) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_mm_s),
            "::",
            stringify!(vbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vprofile) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_mm_s),
            "::",
            stringify!(vprofile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vencspd) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_mm_s),
            "::",
            stringify!(vencspd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).try_hardware_encoder) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_mm_s),
            "::",
            stringify!(try_hardware_encoder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale_w) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_mm_s),
            "::",
            stringify!(scale_w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale_h) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_mm_s),
            "::",
            stringify!(scale_h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fmt) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_mm_s),
            "::",
            stringify!(fmt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auth_username) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_mm_s),
            "::",
            stringify!(auth_username)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auth_password) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_mm_s),
            "::",
            stringify!(auth_password)
        )
    );
}
pub type switch_mm_t = switch_mm_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_crypto_key_material_s {
    pub method: switch_rtp_crypto_key_param_method_type_t,
    pub raw_key: [::std::os::raw::c_uchar; 64usize],
    pub crypto_key: *mut ::std::os::raw::c_char,
    pub lifetime: u64,
    pub mki_id: ::std::os::raw::c_uint,
    pub mki_size: ::std::os::raw::c_uint,
    pub next: *mut switch_crypto_key_material_s,
}
#[test]
fn bindgen_test_layout_switch_crypto_key_material_s() {
    const UNINIT: ::std::mem::MaybeUninit<switch_crypto_key_material_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_crypto_key_material_s>(),
        104usize,
        concat!("Size of: ", stringify!(switch_crypto_key_material_s))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_crypto_key_material_s>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_crypto_key_material_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_crypto_key_material_s),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_key) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_crypto_key_material_s),
            "::",
            stringify!(raw_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crypto_key) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_crypto_key_material_s),
            "::",
            stringify!(crypto_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lifetime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_crypto_key_material_s),
            "::",
            stringify!(lifetime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mki_id) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_crypto_key_material_s),
            "::",
            stringify!(mki_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mki_size) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_crypto_key_material_s),
            "::",
            stringify!(mki_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_crypto_key_material_s),
            "::",
            stringify!(next)
        )
    );
}
pub type switch_crypto_key_material_t = switch_crypto_key_material_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct secure_settings_s {
    pub crypto_tag: ::std::os::raw::c_int,
    pub local_raw_key: [::std::os::raw::c_uchar; 64usize],
    pub remote_raw_key: [::std::os::raw::c_uchar; 64usize],
    pub crypto_type: switch_rtp_crypto_key_type_t,
    pub local_crypto_key: *mut ::std::os::raw::c_char,
    pub remote_crypto_key: *mut ::std::os::raw::c_char,
    pub local_key_material_next: *mut switch_crypto_key_material_s,
    pub local_key_material_n: ::std::os::raw::c_ulong,
    pub remote_key_material_next: *mut switch_crypto_key_material_s,
    pub remote_key_material_n: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_secure_settings_s() {
    const UNINIT: ::std::mem::MaybeUninit<secure_settings_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<secure_settings_s>(),
        184usize,
        concat!("Size of: ", stringify!(secure_settings_s))
    );
    assert_eq!(
        ::std::mem::align_of::<secure_settings_s>(),
        8usize,
        concat!("Alignment of ", stringify!(secure_settings_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crypto_tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(secure_settings_s),
            "::",
            stringify!(crypto_tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_raw_key) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(secure_settings_s),
            "::",
            stringify!(local_raw_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_raw_key) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(secure_settings_s),
            "::",
            stringify!(remote_raw_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crypto_type) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(secure_settings_s),
            "::",
            stringify!(crypto_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_crypto_key) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(secure_settings_s),
            "::",
            stringify!(local_crypto_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_crypto_key) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(secure_settings_s),
            "::",
            stringify!(remote_crypto_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_key_material_next) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(secure_settings_s),
            "::",
            stringify!(local_key_material_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_key_material_n) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(secure_settings_s),
            "::",
            stringify!(local_key_material_n)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_key_material_next) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(secure_settings_s),
            "::",
            stringify!(remote_key_material_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_key_material_n) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(secure_settings_s),
            "::",
            stringify!(remote_key_material_n)
        )
    );
}
pub type switch_secure_settings_t = secure_settings_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_dial_handle_s {
    _unused: [u8; 0],
}
pub type switch_dial_handle_t = switch_dial_handle_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_dial_leg_s {
    _unused: [u8; 0],
}
pub type switch_dial_leg_t = switch_dial_leg_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_dial_leg_list_s {
    _unused: [u8; 0],
}
pub type switch_dial_leg_list_t = switch_dial_leg_list_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_dial_handle_list_s {
    _unused: [u8; 0],
}
pub type switch_dial_handle_list_t = switch_dial_handle_list_s;
extern "C" {
    pub fn switch_status_is_timeup(status: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
    pub __reserved1: ::std::os::raw::c_int,
    pub __reserved2: [sched_param__bindgen_ty_1; 2usize],
    pub __reserved3: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param__bindgen_ty_1 {
    pub __reserved1: time_t,
    pub __reserved2: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_sched_param__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<sched_param__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sched_param__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(sched_param__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sched_param__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__reserved1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param__bindgen_ty_1),
            "::",
            stringify!(__reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__reserved2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param__bindgen_ty_1),
            "::",
            stringify!(__reserved2)
        )
    );
}
#[test]
fn bindgen_test_layout_sched_param() {
    const UNINIT: ::std::mem::MaybeUninit<sched_param> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        48usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        8usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__reserved1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(__reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__reserved2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(__reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__reserved3) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(__reserved3)
        )
    );
}
extern "C" {
    pub fn sched_get_priority_max(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getparam(arg1: pid_t, arg2: *mut sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(arg1: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(arg1: pid_t, arg2: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setparam(arg1: pid_t, arg2: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        arg1: pid_t,
        arg2: ::std::os::raw::c_int,
        arg3: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clone(
        arg1: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_void,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unshare(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setns(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    const UNINIT: ::std::mem::MaybeUninit<cpu_set_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(arg1: usize, arg2: *const cpu_set_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getcpu() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getaffinity(
        arg1: pid_t,
        arg2: usize,
        arg3: *mut cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setaffinity(
        arg1: pid_t,
        arg2: usize,
        arg3: *const cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_create(
        arg1: *mut pthread_t,
        arg2: *const pthread_attr_t,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(arg1: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pthread_join(
        arg1: pthread_t,
        arg2: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(arg1: pthread_t, arg2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
extern "C" {
    pub fn pthread_cancel(arg1: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        arg1: pthread_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        arg1: pthread_t,
        arg2: ::std::os::raw::c_int,
        arg3: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(
        arg1: pthread_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        arg1: *mut pthread_once_t,
        arg2: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        arg1: *mut pthread_mutex_t,
        arg2: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        arg1: *mut pthread_mutex_t,
        arg2: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        arg1: *const pthread_mutex_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        arg1: *mut pthread_mutex_t,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        arg1: *mut pthread_cond_t,
        arg2: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
        arg3: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        arg1: *mut pthread_rwlock_t,
        arg2: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        arg1: *mut pthread_rwlock_t,
        arg2: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        arg1: *mut pthread_rwlock_t,
        arg2: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_init(
        arg1: *mut pthread_spinlock_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(arg1: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(arg1: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(arg1: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(arg1: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        arg1: *mut pthread_barrier_t,
        arg2: *const pthread_barrierattr_t,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(arg1: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(arg1: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        arg1: *mut pthread_key_t,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(arg1: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(arg1: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_setspecific(
        arg1: pthread_key_t,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(arg1: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(arg1: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        arg1: *const pthread_attr_t,
        arg2: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        arg1: *mut pthread_attr_t,
        arg2: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        arg1: *const pthread_attr_t,
        arg2: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        arg1: *mut pthread_attr_t,
        arg2: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        arg1: *const pthread_attr_t,
        arg2: *mut *mut ::std::os::raw::c_void,
        arg3: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        arg1: *mut pthread_attr_t,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        arg1: *const pthread_attr_t,
        arg2: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        arg1: *mut pthread_attr_t,
        arg2: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(arg1: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(arg1: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(arg1: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(arg1: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        arg1: *mut pthread_condattr_t,
        arg2: clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        arg1: *mut pthread_condattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        arg1: *const pthread_condattr_t,
        arg2: *mut clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        arg1: *const pthread_condattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(arg1: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(arg1: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        arg1: *mut pthread_rwlockattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        arg1: *const pthread_rwlockattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(arg1: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        arg1: *const pthread_barrierattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(arg1: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        arg1: *mut pthread_barrierattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
        arg2: ::std::option::Option<unsafe extern "C" fn()>,
        arg3: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getconcurrency() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setconcurrency(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(arg1: pthread_t, arg2: *mut clockid_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __ptcb {
    pub __f: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __x: *mut ::std::os::raw::c_void,
    pub __next: *mut __ptcb,
}
#[test]
fn bindgen_test_layout___ptcb() {
    const UNINIT: ::std::mem::MaybeUninit<__ptcb> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__ptcb>(),
        24usize,
        concat!("Size of: ", stringify!(__ptcb))
    );
    assert_eq!(
        ::std::mem::align_of::<__ptcb>(),
        8usize,
        concat!("Alignment of ", stringify!(__ptcb))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__ptcb),
            "::",
            stringify!(__f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__ptcb),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__ptcb),
            "::",
            stringify!(__next)
        )
    );
}
extern "C" {
    pub fn _pthread_cleanup_push(
        arg1: *mut __ptcb,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        arg3: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn _pthread_cleanup_pop(arg1: *mut __ptcb, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn pthread_getaffinity_np(
        arg1: pthread_t,
        arg2: usize,
        arg3: *mut cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setaffinity_np(
        arg1: pthread_t,
        arg2: usize,
        arg3: *const cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getattr_np(arg1: pthread_t, arg2: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setname_np(
        arg1: pthread_t,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getname_np(
        arg1: pthread_t,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getattr_default_np(arg1: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setattr_default_np(arg1: *const pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_tryjoin_np(
        arg1: pthread_t,
        arg2: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_timedjoin_np(
        arg1: pthread_t,
        arg2: *mut *mut ::std::os::raw::c_void,
        arg3: *const timespec,
    ) -> ::std::os::raw::c_int;
}
pub type switch_thread_id_t = pthread_t;
extern "C" {
    pub fn switch_thread_self() -> switch_thread_id_t;
}
extern "C" {
    #[doc = " \\brief Compare two thread ids\n  \\param tid1 1st Thread ID to compare\n  \\param tid2 2nd Thread ID to compare"]
    pub fn switch_thread_equal(
        tid1: switch_thread_id_t,
        tid2: switch_thread_id_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Clear all memory in the pool and run all the cleanups. This also destroys all\n subpools.\n @param pool The pool to clear\n @remark This does not actually free the memory, it just allows the pool\n         to re-use this memory for the next allocation.\n @see fspr_pool_destroy()"]
    pub fn switch_pool_clear(pool: *mut switch_memory_pool_t);
}
extern "C" {
    #[doc = " @defgroup switch_string String Handling funcions\n @ingroup switch_apr\n @{"]
    pub fn switch_snprintf(
        buf: *mut ::std::os::raw::c_char,
        len: switch_size_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_vasprintf(
        buf: *mut *mut ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_vsnprintf(
        buf: *mut ::std::os::raw::c_char,
        len: switch_size_t,
        format: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_copy_string(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        dst_size: switch_size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " The default hash function.\n @param key pointer to the key.\n @param klen the key length.\n"]
    pub fn switch_hashfunc_default(
        key: *const ::std::os::raw::c_char,
        klen: *mut switch_ssize_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn switch_ci_hashfunc_default(
        char_key: *const ::std::os::raw::c_char,
        klen: *mut switch_ssize_t,
    ) -> ::std::os::raw::c_uint;
}
#[doc = " number of microseconds since 00:00:00 january 1, 1970 UTC"]
pub type switch_time_t = i64;
#[doc = " number of microseconds in the interval"]
pub type switch_interval_time_t = i64;
#[doc = " a structure similar to ANSI struct tm with the following differences:\n  - tm_usec isn't an ANSI field\n  - tm_gmtoff isn't an ANSI field (it's a bsdism)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_time_exp_t {
    #[doc = " microseconds past tm_sec"]
    pub tm_usec: i32,
    #[doc = " (0-61) seconds past tm_min"]
    pub tm_sec: i32,
    #[doc = " (0-59) minutes past tm_hour"]
    pub tm_min: i32,
    #[doc = " (0-23) hours past midnight"]
    pub tm_hour: i32,
    #[doc = " (1-31) day of the month"]
    pub tm_mday: i32,
    #[doc = " (0-11) month of the year"]
    pub tm_mon: i32,
    #[doc = " year since 1900"]
    pub tm_year: i32,
    #[doc = " (0-6) days since sunday"]
    pub tm_wday: i32,
    #[doc = " (0-365) days since jan 1"]
    pub tm_yday: i32,
    #[doc = " daylight saving time"]
    pub tm_isdst: i32,
    #[doc = " seconds east of UTC"]
    pub tm_gmtoff: i32,
}
#[test]
fn bindgen_test_layout_switch_time_exp_t() {
    const UNINIT: ::std::mem::MaybeUninit<switch_time_exp_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_time_exp_t>(),
        44usize,
        concat!("Size of: ", stringify!(switch_time_exp_t))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_time_exp_t>(),
        4usize,
        concat!("Alignment of ", stringify!(switch_time_exp_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_usec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_time_exp_t),
            "::",
            stringify!(tm_usec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_time_exp_t),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_time_exp_t),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_time_exp_t),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_time_exp_t),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_time_exp_t),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_time_exp_t),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_time_exp_t),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_time_exp_t),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_time_exp_t),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_time_exp_t),
            "::",
            stringify!(tm_gmtoff)
        )
    );
}
extern "C" {
    pub fn switch_time_make(sec: switch_time_t, usec: i32) -> switch_time_t;
}
extern "C" {
    #[doc = " @return the current time"]
    pub fn switch_time_now() -> switch_time_t;
}
extern "C" {
    #[doc = " Convert time value from human readable format to a numeric fspr_time_t that\n always represents GMT\n @param result the resulting imploded time\n @param input the input exploded time"]
    pub fn switch_time_exp_gmt_get(
        result: *mut switch_time_t,
        input: *mut switch_time_exp_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " formats the exploded time according to the format specified\n @param s string to write to\n @param retsize The length of the returned string\n @param max The maximum length of the string\n @param format The format for the time string\n @param tm The time to convert"]
    pub fn switch_strftime(
        s: *mut ::std::os::raw::c_char,
        retsize: *mut switch_size_t,
        max: switch_size_t,
        format: *const ::std::os::raw::c_char,
        tm: *mut switch_time_exp_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " formats the exploded time according to the format specified (does not validate format string)\n @param s string to write to\n @param retsize The length of the returned string\n @param max The maximum length of the string\n @param format The format for the time string\n @param tm The time to convert"]
    pub fn switch_strftime_nocheck(
        s: *mut ::std::os::raw::c_char,
        retsize: *mut switch_size_t,
        max: switch_size_t,
        format: *const ::std::os::raw::c_char,
        tm: *mut switch_time_exp_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " switch_rfc822_date formats dates in the RFC822\n format in an efficient manner.  It is a fixed length\n format which requires the indicated amount of storage,\n including the trailing NUL terminator.\n @param date_str String to write to.\n @param t the time to convert"]
    pub fn switch_rfc822_date(
        date_str: *mut ::std::os::raw::c_char,
        t: switch_time_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " convert a time to its human readable components in GMT timezone\n @param result the exploded time\n @param input the time to explode"]
    pub fn switch_time_exp_gmt(
        result: *mut switch_time_exp_t,
        input: switch_time_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Convert time value from human readable format to a numeric fspr_time_t\n e.g. elapsed usec since epoch\n @param result the resulting imploded time\n @param input the input exploded time"]
    pub fn switch_time_exp_get(
        result: *mut switch_time_t,
        input: *mut switch_time_exp_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " convert a time to its human readable components in local timezone\n @param result the exploded time\n @param input the time to explode"]
    pub fn switch_time_exp_lt(
        result: *mut switch_time_exp_t,
        input: switch_time_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " convert a time to its human readable components in a specific timezone with offset\n @param result the exploded time\n @param input the time to explode"]
    pub fn switch_time_exp_tz(
        result: *mut switch_time_exp_t,
        input: switch_time_t,
        offs: switch_int32_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Sleep for the specified number of micro-seconds.\n @param t desired amount of time to sleep.\n @warning May sleep for longer than the specified time."]
    pub fn switch_sleep(t: switch_interval_time_t);
}
extern "C" {
    pub fn switch_micro_sleep(t: switch_interval_time_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fspr_thread_mutex_t {
    _unused: [u8; 0],
}
#[doc = " Opaque thread-local mutex structure"]
pub type switch_mutex_t = fspr_thread_mutex_t;
extern "C" {
    #[doc = " Create and initialize a mutex that can be used to synchronize threads.\n @param lock the memory address where the newly created mutex will be\n        stored.\n @param flags Or'ed value of:\n <PRE>\n           SWITCH_THREAD_MUTEX_DEFAULT   platform-optimal lock behavior.\n           SWITCH_THREAD_MUTEX_NESTED    enable nested (recursive) locks.\n           SWITCH_THREAD_MUTEX_UNNESTED  disable nested locks (non-recursive).\n </PRE>\n @param pool the pool from which to allocate the mutex.\n @warning Be cautious in using SWITCH_THREAD_MUTEX_DEFAULT.  While this is the\n most optimial mutex based on a given platform's performance charateristics,\n it will behave as either a nested or an unnested lock."]
    pub fn switch_mutex_init(
        lock: *mut *mut switch_mutex_t,
        flags: ::std::os::raw::c_uint,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Destroy the mutex and free the memory associated with the lock.\n @param lock the mutex to destroy."]
    pub fn switch_mutex_destroy(lock: *mut switch_mutex_t) -> switch_status_t;
}
extern "C" {
    #[doc = " Acquire the lock for the given mutex. If the mutex is already locked,\n the current thread will be put to sleep until the lock becomes available.\n @param lock the mutex on which to acquire the lock."]
    pub fn switch_mutex_lock(lock: *mut switch_mutex_t) -> switch_status_t;
}
extern "C" {
    #[doc = " Release the lock for the given mutex.\n @param lock the mutex from which to release the lock."]
    pub fn switch_mutex_unlock(lock: *mut switch_mutex_t) -> switch_status_t;
}
extern "C" {
    #[doc = " Attempt to acquire the lock for the given mutex. If the mutex has already\n been acquired, the call returns immediately with APR_EBUSY. Note: it\n is important that the APR_STATUS_IS_EBUSY(s) macro be used to determine\n if the return value was APR_EBUSY, for portability reasons.\n @param lock the mutex on which to attempt the lock acquiring."]
    pub fn switch_mutex_trylock(lock: *mut switch_mutex_t) -> switch_status_t;
}
pub type switch_atomic_t = u32;
extern "C" {
    #[doc = " Some architectures require atomic operations internal structures to be\n initialized before use.\n @param pool The memory pool to use when initializing the structures."]
    pub fn switch_atomic_init(pool: *mut switch_memory_pool_t) -> switch_status_t;
}
extern "C" {
    #[doc = " Uses an atomic operation to read the uint32 value at the location specified\n by mem.\n @param mem The location of memory which stores the value to read."]
    pub fn switch_atomic_read(mem: *mut switch_atomic_t) -> u32;
}
extern "C" {
    #[doc = " Uses an atomic operation to set a uint32 value at a specified location of\n memory.\n @param mem The location of memory to set.\n @param val The uint32 value to set at the memory location."]
    pub fn switch_atomic_set(mem: *mut switch_atomic_t, val: u32);
}
extern "C" {
    #[doc = " Uses an atomic operation to add the uint32 value to the value at the\n specified location of memory.\n @param mem The location of the value to add to.\n @param val The uint32 value to add to the value at the memory location."]
    pub fn switch_atomic_add(mem: *mut switch_atomic_t, val: u32);
}
extern "C" {
    #[doc = " Uses an atomic operation to increment the value at the specified memroy\n location.\n @param mem The location of the value to increment."]
    pub fn switch_atomic_inc(mem: *mut switch_atomic_t);
}
extern "C" {
    #[doc = " Uses an atomic operation to decrement the value at the specified memroy\n location.\n @param mem The location of the value to decrement."]
    pub fn switch_atomic_dec(mem: *mut switch_atomic_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fspr_thread_rwlock_t {
    _unused: [u8; 0],
}
#[doc = " Opaque structure used for the rwlock"]
pub type switch_thread_rwlock_t = fspr_thread_rwlock_t;
extern "C" {
    pub fn switch_thread_rwlock_create(
        rwlock: *mut *mut switch_thread_rwlock_t,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_thread_rwlock_destroy(rwlock: *mut switch_thread_rwlock_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_thread_rwlock_pool_get(
        rwlock: *mut switch_thread_rwlock_t,
    ) -> *mut switch_memory_pool_t;
}
extern "C" {
    pub fn switch_thread_rwlock_rdlock(rwlock: *mut switch_thread_rwlock_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_thread_rwlock_tryrdlock(rwlock: *mut switch_thread_rwlock_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_thread_rwlock_wrlock(rwlock: *mut switch_thread_rwlock_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_thread_rwlock_trywrlock(rwlock: *mut switch_thread_rwlock_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_thread_rwlock_trywrlock_timeout(
        rwlock: *mut switch_thread_rwlock_t,
        timeout: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_thread_rwlock_unlock(rwlock: *mut switch_thread_rwlock_t) -> switch_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fspr_thread_cond_t {
    _unused: [u8; 0],
}
#[doc = " Opaque structure for thread condition variables"]
pub type switch_thread_cond_t = fspr_thread_cond_t;
extern "C" {
    #[doc = " Create and initialize a condition variable that can be used to signal\n and schedule threads in a single process.\n @param cond the memory address where the newly created condition variable\n        will be stored.\n @param pool the pool from which to allocate the mutex."]
    pub fn switch_thread_cond_create(
        cond: *mut *mut switch_thread_cond_t,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Put the active calling thread to sleep until signaled to wake up. Each\n condition variable must be associated with a mutex, and that mutex must\n be locked before  calling this function, or the behavior will be\n undefined. As the calling thread is put to sleep, the given mutex\n will be simultaneously released; and as this thread wakes up the lock\n is again simultaneously acquired.\n @param cond the condition variable on which to block.\n @param mutex the mutex that must be locked upon entering this function,\n        is released while the thread is asleep, and is again acquired before\n        returning from this function."]
    pub fn switch_thread_cond_wait(
        cond: *mut switch_thread_cond_t,
        mutex: *mut switch_mutex_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Put the active calling thread to sleep until signaled to wake up or\n the timeout is reached. Each condition variable must be associated\n with a mutex, and that mutex must be locked before calling this\n function, or the behavior will be undefined. As the calling thread\n is put to sleep, the given mutex will be simultaneously released;\n and as this thread wakes up the lock is again simultaneously acquired.\n @param cond the condition variable on which to block.\n @param mutex the mutex that must be locked upon entering this function,\n        is released while the thread is asleep, and is again acquired before\n        returning from this function.\n @param timeout The amount of time in microseconds to wait. This is\n        a maximum, not a minimum. If the condition is signaled, we\n        will wake up before this time, otherwise the error APR_TIMEUP\n        is returned."]
    pub fn switch_thread_cond_timedwait(
        cond: *mut switch_thread_cond_t,
        mutex: *mut switch_mutex_t,
        timeout: switch_interval_time_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Signals a single thread, if one exists, that is blocking on the given\n condition variable. That thread is then scheduled to wake up and acquire\n the associated mutex. Although it is not required, if predictable scheduling\n is desired, that mutex must be locked while calling this function.\n @param cond the condition variable on which to produce the signal."]
    pub fn switch_thread_cond_signal(cond: *mut switch_thread_cond_t) -> switch_status_t;
}
extern "C" {
    #[doc = " Signals all threads blocking on the given condition variable.\n Each thread that was signaled is then scheduled to wake up and acquire\n the associated mutex. This will happen in a serialized manner.\n @param cond the condition variable on which to produce the broadcast."]
    pub fn switch_thread_cond_broadcast(cond: *mut switch_thread_cond_t) -> switch_status_t;
}
extern "C" {
    #[doc = " Destroy the condition variable and free the associated memory.\n @param cond the condition variable to destroy."]
    pub fn switch_thread_cond_destroy(cond: *mut switch_thread_cond_t) -> switch_status_t;
}
#[doc = " we represent a UUID as a block of 16 bytes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_uuid_t {
    pub data: [::std::os::raw::c_uchar; 16usize],
}
#[test]
fn bindgen_test_layout_switch_uuid_t() {
    const UNINIT: ::std::mem::MaybeUninit<switch_uuid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_uuid_t>(),
        16usize,
        concat!("Size of: ", stringify!(switch_uuid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_uuid_t>(),
        1usize,
        concat!("Alignment of ", stringify!(switch_uuid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_uuid_t),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " Format a UUID into a string, following the standard format\n @param buffer The buffer to place the formatted UUID string into. It must\n               be at least APR_UUID_FORMATTED_LENGTH + 1 bytes long to hold\n               the formatted UUID and a null terminator\n @param uuid The UUID to format"]
    pub fn switch_uuid_format(buffer: *mut ::std::os::raw::c_char, uuid: *const switch_uuid_t);
}
extern "C" {
    #[doc = " Generate and return a (new) UUID\n @param uuid The resulting UUID"]
    pub fn switch_uuid_get(uuid: *mut switch_uuid_t);
}
extern "C" {
    #[doc = " Parse a standard-format string into a UUID\n @param uuid The resulting UUID\n @param uuid_str The formatted UUID"]
    pub fn switch_uuid_parse(
        uuid: *mut switch_uuid_t,
        uuid_str: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " MD5 in one step\n @param digest The final MD5 digest\n @param input The message block to use\n @param inputLen The length of the message block"]
    pub fn switch_md5(
        digest: *mut ::std::os::raw::c_uchar,
        input: *const ::std::os::raw::c_void,
        inputLen: switch_size_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_md5_string(
        digest_str: *mut ::std::os::raw::c_char,
        input: *const ::std::os::raw::c_void,
        inputLen: switch_size_t,
    ) -> switch_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_apr_queue_t {
    _unused: [u8; 0],
}
#[doc = " Opaque structure used for queue API"]
pub type switch_queue_t = switch_apr_queue_t;
extern "C" {
    #[doc = " create a FIFO queue\n @param queue The new queue\n @param queue_capacity maximum size of the queue\n @param pool a pool to allocate queue from"]
    pub fn switch_queue_create(
        queue: *mut *mut switch_queue_t,
        queue_capacity: ::std::os::raw::c_uint,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " pop/get an object from the queue, blocking if the queue is already empty\n\n @param queue the queue\n @param data the data\n @returns APR_EINTR the blocking was interrupted (try again)\n @returns APR_EOF if the queue has been terminated\n @returns APR_SUCCESS on a successfull pop"]
    pub fn switch_queue_pop(
        queue: *mut switch_queue_t,
        data: *mut *mut ::std::os::raw::c_void,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " pop/get an object from the queue, blocking if the queue is already empty\n\n @param queue the queue\n @param data the data\n @param timeout The amount of time in microseconds to wait. This is\n        a maximum, not a minimum. If the condition is signaled, we\n        will wake up before this time, otherwise the error APR_TIMEUP\n        is returned.\n @returns APR_TIMEUP the request timed out\n @returns APR_EINTR the blocking was interrupted (try again)\n @returns APR_EOF if the queue has been terminated\n @returns APR_SUCCESS on a successfull pop"]
    pub fn switch_queue_pop_timeout(
        queue: *mut switch_queue_t,
        data: *mut *mut ::std::os::raw::c_void,
        timeout: switch_interval_time_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " push/add a object to the queue, blocking if the queue is already full\n\n @param queue the queue\n @param data the data\n @returns APR_EINTR the blocking was interrupted (try again)\n @returns APR_EOF the queue has been terminated\n @returns APR_SUCCESS on a successfull push"]
    pub fn switch_queue_push(
        queue: *mut switch_queue_t,
        data: *mut ::std::os::raw::c_void,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " returns the size of the queue.\n\n @warning this is not threadsafe, and is intended for reporting/monitoring\n of the queue.\n @param queue the queue\n @returns the size of the queue"]
    pub fn switch_queue_size(queue: *mut switch_queue_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " pop/get an object to the queue, returning immediatly if the queue is empty\n\n @param queue the queue\n @param data the data\n @returns APR_EINTR the blocking operation was interrupted (try again)\n @returns APR_EAGAIN the queue is empty\n @returns APR_EOF the queue has been terminated\n @returns APR_SUCCESS on a successfull push"]
    pub fn switch_queue_trypop(
        queue: *mut switch_queue_t,
        data: *mut *mut ::std::os::raw::c_void,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_queue_interrupt_all(queue: *mut switch_queue_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_queue_term(queue: *mut switch_queue_t) -> switch_status_t;
}
extern "C" {
    #[doc = " push/add a object to the queue, returning immediatly if the queue is full\n\n @param queue the queue\n @param data the data\n @returns APR_EINTR the blocking operation was interrupted (try again)\n @returns APR_EAGAIN the queue is full\n @returns APR_EOF the queue has been terminated\n @returns APR_SUCCESS on a successfull push"]
    pub fn switch_queue_trypush(
        queue: *mut switch_queue_t,
        data: *mut ::std::os::raw::c_void,
    ) -> switch_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fspr_file_t {
    _unused: [u8; 0],
}
#[doc = " Structure for referencing files."]
pub type switch_file_t = fspr_file_t;
pub type switch_fileperms_t = i32;
pub type switch_seek_where_t = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Open the specified file.\n @param newf The opened file descriptor.\n @param fname The full path to the file (using / on all systems)\n @param flag Or'ed value of:\n <PRE>\n         SWITCH_FOPEN_READ\t\t\t\topen for reading\n         SWITCH_FOPEN_WRITE\t\t\t\topen for writing\n         SWITCH_FOPEN_CREATE\t\t\t\tcreate the file if not there\n         SWITCH_FOPEN_APPEND\t\t\t\tfile ptr is set to end prior to all writes\n         SWITCH_FOPEN_TRUNCATE\t\t\tset length to zero if file exists\n         SWITCH_FOPEN_BINARY\t\t\t\tnot a text file (This flag is ignored on\n\t\t\t\t\t\t\t\t\t\t\tUNIX because it has no meaning)\n         SWITCH_FOPEN_BUFFERED\t\t\tbuffer the data.  Default is non-buffered\n         SWITCH_FOPEN_EXCL\t\t\t\treturn error if APR_CREATE and file exists\n         SWITCH_FOPEN_DELONCLOSE\t\t\tdelete the file after closing.\n         SWITCH_FOPEN_XTHREAD\t\t\t\tPlatform dependent tag to open the file\n\t\t\t\t\t\t\t\t\t\t\tfor use across multiple threads\n         SWITCH_FOPEN_SHARELOCK\t\t\tPlatform dependent support for higher\n\t\t\t\t\t\t\t\t\t\t\tlevel locked read/write access to support\n\t\t\t\t\t\t\t\t\t\t\twrites across process/machines\n         SWITCH_FOPEN_NOCLEANUP\t\t\tDo not register a cleanup with the pool\n\t\t\t\t\t\t\t\t\t\t\tpassed in on the <EM>pool</EM> argument (see below).\n\t\t\t\t\t\t\t\t\t\t\tThe fspr_os_file_t handle in fspr_file_t will not\n\t\t\t\t\t\t\t\t\t\t\tbe closed when the pool is destroyed.\n         SWITCH_FOPEN_SENDFILE_ENABLED\tOpen with appropriate platform semantics\n\t\t\t\t\t\t\t\t\t\t\tfor sendfile operations.  Advisory only,\n\t\t\t\t\t\t\t\t\t\t\tfspr_socket_sendfile does not check this flag.\n </PRE>\n @param perm Access permissions for file.\n @param pool The pool to use.\n @remark If perm is SWITCH_FPROT_OS_DEFAULT and the file is being created,\n appropriate default permissions will be used."]
    pub fn switch_file_open(
        newf: *mut *mut switch_file_t,
        fname: *const ::std::os::raw::c_char,
        flag: i32,
        perm: switch_fileperms_t,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_file_seek(
        thefile: *mut switch_file_t,
        where_: switch_seek_where_t,
        offset: *mut i64,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_file_copy(
        from_path: *const ::std::os::raw::c_char,
        to_path: *const ::std::os::raw::c_char,
        perms: switch_fileperms_t,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Close the specified file.\n @param thefile The file descriptor to close."]
    pub fn switch_file_close(thefile: *mut switch_file_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_file_trunc(thefile: *mut switch_file_t, offset: i64) -> switch_status_t;
}
extern "C" {
    pub fn switch_file_lock(
        thefile: *mut switch_file_t,
        type_: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Delete the specified file.\n @param path The full path to the file (using / on all systems)\n @param pool The pool to use.\n @remark If the file is open, it won't be removed until all\n instances are closed."]
    pub fn switch_file_remove(
        path: *const ::std::os::raw::c_char,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_file_rename(
        from_path: *const ::std::os::raw::c_char,
        to_path: *const ::std::os::raw::c_char,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Read data from the specified file.\n @param thefile The file descriptor to read from.\n @param buf The buffer to store the data to.\n @param nbytes On entry, the number of bytes to read; on exit, the number\n of bytes read.\n\n @remark fspr_file_read will read up to the specified number of\n bytes, but never more.  If there isn't enough data to fill that\n number of bytes, all of the available data is read.  The third\n argument is modified to reflect the number of bytes read.  If a\n char was put back into the stream via ungetc, it will be the first\n character returned.\n\n @remark It is not possible for both bytes to be read and an APR_EOF\n or other error to be returned.  APR_EINTR is never returned."]
    pub fn switch_file_read(
        thefile: *mut switch_file_t,
        buf: *mut ::std::os::raw::c_void,
        nbytes: *mut switch_size_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Write data to the specified file.\n @param thefile The file descriptor to write to.\n @param buf The buffer which contains the data.\n @param nbytes On entry, the number of bytes to write; on exit, the number\n               of bytes written.\n\n @remark fspr_file_write will write up to the specified number of\n bytes, but never more.  If the OS cannot write that many bytes, it\n will write as many as it can.  The third argument is modified to\n reflect the * number of bytes written.\n\n @remark It is possible for both bytes to be written and an error to\n be returned.  APR_EINTR is never returned."]
    pub fn switch_file_write(
        thefile: *mut switch_file_t,
        buf: *const ::std::os::raw::c_void,
        nbytes: *mut switch_size_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_file_printf(
        thefile: *mut switch_file_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_file_mktemp(
        thefile: *mut *mut switch_file_t,
        templ: *mut ::std::os::raw::c_char,
        flags: i32,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_file_get_size(thefile: *mut switch_file_t) -> switch_size_t;
}
extern "C" {
    pub fn switch_file_exists(
        filename: *const ::std::os::raw::c_char,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_directory_exists(
        dirname: *const ::std::os::raw::c_char,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Create a new directory on the file system.\n @param path the path for the directory to be created. (use / on all systems)\n @param perm Permissions for the new direcoty.\n @param pool the pool to use."]
    pub fn switch_dir_make(
        path: *const ::std::os::raw::c_char,
        perm: switch_fileperms_t,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Creates a new directory on the file system, but behaves like\n 'mkdir -p'. Creates intermediate directories as required. No error\n will be reported if PATH already exists.\n @param path the path for the directory to be created. (use / on all systems)\n @param perm Permissions for the new direcoty.\n @param pool the pool to use."]
    pub fn switch_dir_make_recursive(
        path: *const ::std::os::raw::c_char,
        perm: switch_fileperms_t,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_dir {
    _unused: [u8; 0],
}
pub type switch_dir_t = switch_dir;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_array_header_t {
    #[doc = " The pool the array is allocated out of"]
    pub pool: *mut switch_memory_pool_t,
    #[doc = " The amount of memory allocated for each element of the array"]
    pub elt_size: ::std::os::raw::c_int,
    #[doc = " The number of active elements in the array"]
    pub nelts: ::std::os::raw::c_int,
    #[doc = " The number of elements allocated in the array"]
    pub nalloc: ::std::os::raw::c_int,
    #[doc = " The elements in the array"]
    pub elts: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_switch_array_header_t() {
    const UNINIT: ::std::mem::MaybeUninit<switch_array_header_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_array_header_t>(),
        32usize,
        concat!("Size of: ", stringify!(switch_array_header_t))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_array_header_t>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_array_header_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_array_header_t),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elt_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_array_header_t),
            "::",
            stringify!(elt_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nelts) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_array_header_t),
            "::",
            stringify!(nelts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nalloc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_array_header_t),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elts) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_array_header_t),
            "::",
            stringify!(elts)
        )
    );
}
extern "C" {
    pub fn switch_dir_open(
        new_dir: *mut *mut switch_dir_t,
        dirname: *const ::std::os::raw::c_char,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_dir_close(thedir: *mut switch_dir_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_dir_next_file(
        thedir: *mut switch_dir_t,
        buf: *mut ::std::os::raw::c_char,
        len: switch_size_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_dir_count(thedir: *mut switch_dir_t) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fspr_thread_t {
    _unused: [u8; 0],
}
#[doc = " Opaque Thread structure."]
pub type switch_thread_t = fspr_thread_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fspr_threadattr_t {
    _unused: [u8; 0],
}
#[doc = " Opaque Thread attributes structure."]
pub type switch_threadattr_t = fspr_threadattr_t;
#[doc = " The prototype for any APR thread worker functions.\n typedef void *(SWITCH_THREAD_FUNC *switch_thread_start_t)(switch_thread_t*, void*);"]
pub type switch_thread_start_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut switch_thread_t,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    pub fn switch_threadattr_stacksize_set(
        attr: *mut switch_threadattr_t,
        stacksize: switch_size_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_threadattr_priority_set(
        attr: *mut switch_threadattr_t,
        priority: switch_thread_priority_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Create and initialize a new threadattr variable\n @param new_attr The newly created threadattr.\n @param pool The pool to use"]
    pub fn switch_threadattr_create(
        new_attr: *mut *mut switch_threadattr_t,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Set if newly created threads should be created in detached state.\n @param attr The threadattr to affect\n @param on Non-zero if detached threads should be created."]
    pub fn switch_threadattr_detach_set(attr: *mut switch_threadattr_t, on: i32)
        -> switch_status_t;
}
extern "C" {
    #[doc = " Create a new thread of execution\n @param new_thread The newly created thread handle.\n @param attr The threadattr to use to determine how to create the thread\n @param func The function to start the new thread in\n @param data Any data to be passed to the starting function\n @param cont The pool to use"]
    pub fn switch_thread_create(
        new_thread: *mut *mut switch_thread_t,
        attr: *mut switch_threadattr_t,
        func: switch_thread_start_t,
        data: *mut ::std::os::raw::c_void,
        cont: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fspr_socket_t {
    _unused: [u8; 0],
}
#[doc = " A structure to represent sockets"]
pub type switch_socket_t = fspr_socket_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fspr_sockaddr_t {
    _unused: [u8; 0],
}
#[doc = " Freeswitch's socket address type, used to ensure protocol independence"]
pub type switch_sockaddr_t = fspr_sockaddr_t;
#[doc = "< no longer allow read request"]
pub const switch_shutdown_how_e_SWITCH_SHUTDOWN_READ: switch_shutdown_how_e = 0;
#[doc = "< no longer allow write requests"]
pub const switch_shutdown_how_e_SWITCH_SHUTDOWN_WRITE: switch_shutdown_how_e = 1;
#[doc = "< no longer allow read or write requests"]
pub const switch_shutdown_how_e_SWITCH_SHUTDOWN_READWRITE: switch_shutdown_how_e = 2;
pub type switch_shutdown_how_e = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Create a socket.\n @param new_sock The new socket that has been set up.\n @param family The address family of the socket (e.g., SWITCH_INET).\n @param type The type of the socket (e.g., SOCK_STREAM).\n @param protocol The protocol of the socket (e.g., SWITCH_PROTO_TCP).\n @param pool The pool to use"]
    pub fn switch_socket_create(
        new_sock: *mut *mut switch_socket_t,
        family: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        protocol: ::std::os::raw::c_int,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Shutdown either reading, writing, or both sides of a socket.\n @param sock The socket to close\n @param how How to shutdown the socket.  One of:\n <PRE>\n            SWITCH_SHUTDOWN_READ         no longer allow read requests\n            SWITCH_SHUTDOWN_WRITE        no longer allow write requests\n            SWITCH_SHUTDOWN_READWRITE    no longer allow read or write requests\n </PRE>\n @see switch_shutdown_how_e\n @remark This does not actually close the socket descriptor, it just\n      controls which calls are still valid on the socket."]
    pub fn switch_socket_shutdown(
        sock: *mut switch_socket_t,
        how: switch_shutdown_how_e,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Close a socket.\n @param sock The socket to close"]
    pub fn switch_socket_close(sock: *mut switch_socket_t) -> switch_status_t;
}
extern "C" {
    #[doc = " Bind the socket to its associated port\n @param sock The socket to bind\n @param sa The socket address to bind to\n @remark This may be where we will find out if there is any other process\n      using the selected port."]
    pub fn switch_socket_bind(
        sock: *mut switch_socket_t,
        sa: *mut switch_sockaddr_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Listen to a bound socket for connections.\n @param sock The socket to listen on\n @param backlog The number of outstanding connections allowed in the sockets\n                listen queue.  If this value is less than zero, the listen\n                queue size is set to zero."]
    pub fn switch_socket_listen(sock: *mut switch_socket_t, backlog: i32) -> switch_status_t;
}
extern "C" {
    #[doc = " Accept a new connection request\n @param new_sock A copy of the socket that is connected to the socket that\n                 made the connection request.  This is the socket which should\n                 be used for all future communication.\n @param sock The socket we are listening on.\n @param pool The pool for the new socket."]
    pub fn switch_socket_accept(
        new_sock: *mut *mut switch_socket_t,
        sock: *mut switch_socket_t,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Issue a connection request to a socket either on the same machine\n or a different one.\n @param sock The socket we wish to use for our side of the connection\n @param sa The address of the machine we wish to connect to."]
    pub fn switch_socket_connect(
        sock: *mut switch_socket_t,
        sa: *mut switch_sockaddr_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Get socket fd for the switch socket passed\n @param sock The socket we wish to have fd"]
    pub fn switch_socket_fd_get(sock: *mut switch_socket_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_sockaddr_get_port(sa: *mut switch_sockaddr_t) -> u16;
}
extern "C" {
    pub fn switch_get_addr(
        buf: *mut ::std::os::raw::c_char,
        len: switch_size_t,
        in_: *mut switch_sockaddr_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_getnameinfo(
        hostname: *mut *mut ::std::os::raw::c_char,
        sa: *mut switch_sockaddr_t,
        flags: i32,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_sockaddr_get_family(sa: *mut switch_sockaddr_t) -> i32;
}
extern "C" {
    pub fn switch_sockaddr_ip_get(
        addr: *mut *mut ::std::os::raw::c_char,
        sa: *mut switch_sockaddr_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_sockaddr_equal(
        sa1: *const switch_sockaddr_t,
        sa2: *const switch_sockaddr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create fspr_sockaddr_t from hostname, address family, and port.\n @param sa The new fspr_sockaddr_t.\n @param hostname The hostname or numeric address string to resolve/parse, or\n               NULL to build an address that corresponds to 0.0.0.0 or ::\n @param family The address family to use, or SWITCH_UNSPEC if the system should\n               decide.\n @param port The port number.\n @param flags Special processing flags:\n <PRE>\n       APR_IPV4_ADDR_OK          first query for IPv4 addresses; only look\n                                 for IPv6 addresses if the first query failed;\n                                 only valid if family is APR_UNSPEC and hostname\n                                 isn't NULL; mutually exclusive with\n                                 APR_IPV6_ADDR_OK\n       APR_IPV6_ADDR_OK          first query for IPv6 addresses; only look\n                                 for IPv4 addresses if the first query failed;\n                                 only valid if family is APR_UNSPEC and hostname\n                                 isn't NULL and APR_HAVE_IPV6; mutually exclusive\n                                 with APR_IPV4_ADDR_OK\n </PRE>\n @param pool The pool for the fspr_sockaddr_t and associated storage."]
    pub fn switch_sockaddr_info_get(
        sa: *mut *mut switch_sockaddr_t,
        hostname: *const ::std::os::raw::c_char,
        family: i32,
        port: switch_port_t,
        flags: i32,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_sockaddr_create(
        sa: *mut *mut switch_sockaddr_t,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_sockaddr_new(
        sa: *mut *mut switch_sockaddr_t,
        ip: *const ::std::os::raw::c_char,
        port: switch_port_t,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Send data over a network.\n @param sock The socket to send the data over.\n @param buf The buffer which contains the data to be sent.\n @param len On entry, the number of bytes to send; on exit, the number\n            of bytes sent.\n @remark\n <PRE>\n This functions acts like a blocking write by default.  To change\n this behavior, use fspr_socket_timeout_set() or the APR_SO_NONBLOCK\n socket option.\n\n It is possible for both bytes to be sent and an error to be returned.\n\n APR_EINTR is never returned.\n </PRE>"]
    pub fn switch_socket_send(
        sock: *mut switch_socket_t,
        buf: *const ::std::os::raw::c_char,
        len: *mut switch_size_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " @param sock The socket to send from\n @param where The fspr_sockaddr_t describing where to send the data\n @param flags The flags to use\n @param buf  The data to send\n @param len  The length of the data to send"]
    pub fn switch_socket_sendto(
        sock: *mut switch_socket_t,
        where_: *mut switch_sockaddr_t,
        flags: i32,
        buf: *const ::std::os::raw::c_char,
        len: *mut switch_size_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_socket_send_nonblock(
        sock: *mut switch_socket_t,
        buf: *const ::std::os::raw::c_char,
        len: *mut switch_size_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " @param from The fspr_sockaddr_t to fill in the recipient info\n @param sock The socket to use\n @param flags The flags to use\n @param buf  The buffer to use\n @param len  The length of the available buffer\n"]
    pub fn switch_socket_recvfrom(
        from: *mut switch_sockaddr_t,
        sock: *mut switch_socket_t,
        flags: i32,
        buf: *mut ::std::os::raw::c_char,
        len: *mut usize,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_socket_atmark(
        sock: *mut switch_socket_t,
        atmark: *mut ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Read data from a network.\n @param sock The socket to read the data from.\n @param buf The buffer to store the data in.\n @param len On entry, the number of bytes to receive; on exit, the number\n            of bytes received.\n @remark\n <PRE>\n This functions acts like a blocking read by default.  To change\n this behavior, use fspr_socket_timeout_set() or the APR_SO_NONBLOCK\n socket option.\n The number of bytes actually received is stored in argument 3.\n\n It is possible for both bytes to be received and an APR_EOF or\n other error to be returned.\n\n APR_EINTR is never returned.\n </PRE>"]
    pub fn switch_socket_recv(
        sock: *mut switch_socket_t,
        buf: *mut ::std::os::raw::c_char,
        len: *mut switch_size_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Setup socket options for the specified socket\n @param sock The socket to set up.\n @param opt The option we would like to configure.  One of:\n <PRE>\n            APR_SO_DEBUG      --  turn on debugging information\n            APR_SO_KEEPALIVE  --  keep connections active\n            APR_SO_LINGER     --  lingers on close if data is present\n            APR_SO_NONBLOCK   --  Turns blocking on/off for socket\n                                  When this option is enabled, use\n                                  the APR_STATUS_IS_EAGAIN() macro to\n                                  see if a send or receive function\n                                  could not transfer data without\n                                  blocking.\n            APR_SO_REUSEADDR  --  The rules used in validating addresses\n                                  supplied to bind should allow reuse\n                                  of local addresses.\n            APR_SO_SNDBUF     --  Set the SendBufferSize\n            APR_SO_RCVBUF     --  Set the ReceiveBufferSize\n </PRE>\n @param on Value for the option."]
    pub fn switch_socket_opt_set(sock: *mut switch_socket_t, opt: i32, on: i32) -> switch_status_t;
}
extern "C" {
    #[doc = " Query socket timeout for the specified socket\n @param sock The socket to query\n @param t Socket timeout returned from the query.\n <PRE>\n   t > 0  -- read and write calls return APR_TIMEUP if specified time\n             elapsess with no data read or written\n   t == 0 -- read and write calls never block\n   t < 0  -- read and write calls block\n </PRE>"]
    pub fn switch_socket_timeout_get(
        sock: *mut switch_socket_t,
        t: *mut switch_interval_time_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Setup socket timeout for the specified socket\n @param sock The socket to set up.\n @param t Value for the timeout.\n <PRE>\n   t > 0  -- read and write calls return APR_TIMEUP if specified time\n             elapsess with no data read or written\n   t == 0 -- read and write calls never block\n   t < 0  -- read and write calls block\n </PRE>"]
    pub fn switch_socket_timeout_set(
        sock: *mut switch_socket_t,
        t: switch_interval_time_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Join a Multicast Group\n @param sock The socket to join a multicast group\n @param join The address of the multicast group to join\n @param iface Address of the interface to use.  If NULL is passed, the\n              default multicast interface will be used. (OS Dependent)\n @param source Source Address to accept transmissions from (non-NULL\n               implies Source-Specific Multicast)"]
    pub fn switch_mcast_join(
        sock: *mut switch_socket_t,
        join: *mut switch_sockaddr_t,
        iface: *mut switch_sockaddr_t,
        source: *mut switch_sockaddr_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Set the Multicast Time to Live (ttl) for a multicast transmission.\n @param sock The socket to set the multicast ttl\n @param ttl Time to live to Assign. 0-255, default=1\n @remark If the TTL is 0, packets will only be seen by sockets on the local machine,\n     and only when multicast loopback is enabled."]
    pub fn switch_mcast_hops(sock: *mut switch_socket_t, ttl: u8) -> switch_status_t;
}
extern "C" {
    pub fn switch_mcast_loopback(sock: *mut switch_socket_t, opt: u8) -> switch_status_t;
}
extern "C" {
    pub fn switch_mcast_interface(
        sock: *mut switch_socket_t,
        iface: *mut switch_sockaddr_t,
    ) -> switch_status_t;
}
#[doc = "< nothing here"]
pub const switch_pollset_type_t_SWITCH_NO_DESC: switch_pollset_type_t = 0;
#[doc = "< descriptor refers to a socket"]
pub const switch_pollset_type_t_SWITCH_POLL_SOCKET: switch_pollset_type_t = 1;
#[doc = "< descriptor refers to a file"]
pub const switch_pollset_type_t_SWITCH_POLL_FILE: switch_pollset_type_t = 2;
#[doc = "< descriptor is the last one in the list"]
pub const switch_pollset_type_t_SWITCH_POLL_LASTDESC: switch_pollset_type_t = 3;
#[doc = " @}"]
pub type switch_pollset_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union switch_descriptor_t {
    #[doc = "< file"]
    pub f: *mut switch_file_t,
    #[doc = "< socket"]
    pub s: *mut switch_socket_t,
}
#[test]
fn bindgen_test_layout_switch_descriptor_t() {
    const UNINIT: ::std::mem::MaybeUninit<switch_descriptor_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_descriptor_t>(),
        8usize,
        concat!("Size of: ", stringify!(switch_descriptor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_descriptor_t>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_descriptor_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_descriptor_t),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_descriptor_t),
            "::",
            stringify!(s)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct switch_pollfd {
    #[doc = "< associated pool"]
    pub p: *mut switch_memory_pool_t,
    pub desc_type: switch_pollset_type_t,
    #[doc = "< requested events"]
    pub reqevents: i16,
    #[doc = "< returned events"]
    pub rtnevents: i16,
    #[doc = "< @see fspr_descriptor"]
    pub desc: switch_descriptor_t,
    #[doc = "< allows app to associate context"]
    pub client_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_switch_pollfd() {
    const UNINIT: ::std::mem::MaybeUninit<switch_pollfd> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_pollfd>(),
        32usize,
        concat!("Size of: ", stringify!(switch_pollfd))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_pollfd>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_pollfd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_pollfd),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desc_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_pollfd),
            "::",
            stringify!(desc_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reqevents) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_pollfd),
            "::",
            stringify!(reqevents)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rtnevents) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_pollfd),
            "::",
            stringify!(rtnevents)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_pollfd),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_pollfd),
            "::",
            stringify!(client_data)
        )
    );
}
#[doc = " @defgroup fspr_poll Poll Routines\n @ingroup switch_apr\n @{\n/\n/** Poll descriptor set."]
pub type switch_pollfd_t = switch_pollfd;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fspr_pollset_t {
    _unused: [u8; 0],
}
#[doc = " Opaque structure used for pollset API"]
pub type switch_pollset_t = fspr_pollset_t;
extern "C" {
    #[doc = " Setup a pollset object\n @param pollset  The pointer in which to return the newly created object\n @param size The maximum number of descriptors that this pollset can hold\n @param pool The pool from which to allocate the pollset\n @param flags Optional flags to modify the operation of the pollset.\n\n @remark If flags equals APR_POLLSET_THREADSAFE, then a pollset is\n created on which it is safe to make concurrent calls to\n fspr_pollset_add(), fspr_pollset_remove() and fspr_pollset_poll() from\n separate threads.  This feature is only supported on some\n platforms; the fspr_pollset_create() call will fail with\n APR_ENOTIMPL on platforms where it is not supported."]
    pub fn switch_pollset_create(
        pollset: *mut *mut switch_pollset_t,
        size: u32,
        pool: *mut switch_memory_pool_t,
        flags: u32,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Add a socket or file descriptor to a pollset\n @param pollset The pollset to which to add the descriptor\n @param descriptor The descriptor to add\n @remark If you set client_data in the descriptor, that value\n         will be returned in the client_data field whenever this\n         descriptor is signalled in fspr_pollset_poll().\n @remark If the pollset has been created with APR_POLLSET_THREADSAFE\n         and thread T1 is blocked in a call to fspr_pollset_poll() for\n         this same pollset that is being modified via fspr_pollset_add()\n         in thread T2, the currently executing fspr_pollset_poll() call in\n         T1 will either: (1) automatically include the newly added descriptor\n         in the set of descriptors it is watching or (2) return immediately\n         with APR_EINTR.  Option (1) is recommended, but option (2) is\n         allowed for implementations where option (1) is impossible\n         or impractical."]
    pub fn switch_pollset_add(
        pollset: *mut switch_pollset_t,
        descriptor: *const switch_pollfd_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Remove a descriptor from a pollset\n @param pollset The pollset from which to remove the descriptor\n @param descriptor The descriptor to remove\n @remark If the pollset has been created with APR_POLLSET_THREADSAFE\n         and thread T1 is blocked in a call to fspr_pollset_poll() for\n         this same pollset that is being modified via fspr_pollset_remove()\n         in thread T2, the currently executing fspr_pollset_poll() call in\n         T1 will either: (1) automatically exclude the newly added descriptor\n         in the set of descriptors it is watching or (2) return immediately\n         with APR_EINTR.  Option (1) is recommended, but option (2) is\n         allowed for implementations where option (1) is impossible\n         or impractical."]
    pub fn switch_pollset_remove(
        pollset: *mut switch_pollset_t,
        descriptor: *const switch_pollfd_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Poll the sockets in the poll structure\n @param aprset The poll structure we will be using.\n @param numsock The number of sockets we are polling\n @param nsds The number of sockets signalled.\n @param timeout The amount of time in microseconds to wait.  This is\n                a maximum, not a minimum.  If a socket is signalled, we\n                will wake up before this time.  A negative number means\n                wait until a socket is signalled.\n @remark The number of sockets signalled is returned in the third argument.\n         This is a blocking call, and it will not return until either a\n         socket has been signalled, or the timeout has expired."]
    pub fn switch_poll(
        aprset: *mut switch_pollfd_t,
        numsock: i32,
        nsds: *mut i32,
        timeout: switch_interval_time_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Block for activity on the descriptor(s) in a pollset\n @param pollset The pollset to use\n @param timeout Timeout in microseconds\n @param num Number of signalled descriptors (output parameter)\n @param descriptors Array of signalled descriptors (output parameter)"]
    pub fn switch_pollset_poll(
        pollset: *mut switch_pollset_t,
        timeout: switch_interval_time_t,
        num: *mut i32,
        descriptors: *mut *const switch_pollfd_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Create a set of file descriptors to poll from a socket\n\\param poll the polfd to create\n\\param sock the socket to add\n\\param flags the flags to modify the behaviour\n\\param pool the memory pool to use\n\\return SWITCH_STATUS_SUCCESS when successful"]
    pub fn switch_socket_create_pollset(
        poll: *mut *mut switch_pollfd_t,
        sock: *mut switch_socket_t,
        flags: i16,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_interval_time_from_timeval(tvp: *mut timeval) -> switch_interval_time_t;
}
extern "C" {
    #[doc = "\\brief Create a pollfd out of a socket\n\\param pollfd the pollfd to create\n\\param sock the socket to add\n\\param flags the flags to modify the behaviour\n\\param client_data custom user data\n\\param pool the memory pool to use\n\\return SWITCH_STATUS_SUCCESS when successful"]
    pub fn switch_socket_create_pollfd(
        pollfd: *mut *mut switch_pollfd_t,
        sock: *mut switch_socket_t,
        flags: i16,
        client_data: *mut ::std::os::raw::c_void,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_match_glob(
        pattern: *const ::std::os::raw::c_char,
        result: *mut *mut switch_array_header_t,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_os_sock_get(
        thesock: *mut switch_os_socket_t,
        sock: *mut switch_socket_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_os_sock_put(
        sock: *mut *mut switch_socket_t,
        thesock: *mut switch_os_socket_t,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_socket_addr_get(
        sa: *mut *mut switch_sockaddr_t,
        remote: switch_bool_t,
        sock: *mut switch_socket_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Create an anonymous pipe.\n @param in The file descriptor to use as input to the pipe.\n @param out The file descriptor to use as output from the pipe.\n @param pool The pool to operate on."]
    pub fn switch_file_pipe_create(
        in_: *mut *mut switch_file_t,
        out: *mut *mut switch_file_t,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Get the timeout value for a pipe or manipulate the blocking state.\n @param thepipe The pipe we are getting a timeout for.\n @param timeout The current timeout value in microseconds."]
    pub fn switch_file_pipe_timeout_get(
        thepipe: *mut switch_file_t,
        timeout: *mut switch_interval_time_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Set the timeout value for a pipe or manipulate the blocking state.\n @param thepipe The pipe we are setting a timeout on.\n @param timeout The timeout value in microseconds.  Values < 0 mean wait\n        forever, 0 means do not wait at all."]
    pub fn switch_file_pipe_timeout_set(
        thepipe: *mut switch_file_t,
        timeout: switch_interval_time_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " stop the current thread\n @param thd The thread to stop\n @param retval The return value to pass back to any thread that cares"]
    pub fn switch_thread_exit(
        thd: *mut switch_thread_t,
        retval: switch_status_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " block until the desired thread stops executing.\n @param retval The return value from the dead thread.\n @param thd The thread to join"]
    pub fn switch_thread_join(
        retval: *mut switch_status_t,
        thd: *mut switch_thread_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " Return a human readable string describing the specified error.\n @param statcode The error code the get a string for.\n @param buf A buffer to hold the error string.\n @bufsize Size of the buffer to hold the string."]
    pub fn switch_strerror(
        statcode: switch_status_t,
        buf: *mut ::std::os::raw::c_char,
        bufsize: switch_size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_plc_init(s: *mut switch_plc_state_t) -> *mut switch_plc_state_t;
}
extern "C" {
    pub fn switch_plc_free(s: *mut switch_plc_state_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_plc_rx(
        s: *mut switch_plc_state_t,
        amp: *mut i16,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_plc_fillin(
        s: *mut switch_plc_state_t,
        amp: *mut i16,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This routine is a variant of the \"sprintf()\" from the\n standard C library.  The resulting string is written into memory\n obtained from malloc() so that there is never a possiblity of buffer\n overflow.  This routine also implement some additional formatting\n options that are useful for constructing SQL statements.\n\n The strings returned by this routine should be freed by calling\n free().\n\n All of the usual printf formatting options apply.  In addition, there\n is a \"%q\" option.  %q works like %s in that it substitutes a null-terminated\n string from the argument list.  But %q also doubles every '\\'' character.\n %q is designed for use inside a string literal.  By doubling each '\\''\n character it escapes that character and allows it to be inserted into\n the string.\n\n For example, so some string variable contains text as follows:\n\n      char *zText = \"It's a happy day!\";\n\n We can use this text in an SQL statement as follows:\n\n      char *z = switch_mprintf(\"INSERT INTO TABLES('%q')\", zText);\n      switch_core_db_exec(db, z, callback1, 0, 0);\n      free(z);\n\n Because the %q format string is used, the '\\'' character in zText\n is escaped and the SQL generated is as follows:\n\n      INSERT INTO table1 VALUES('It''s a happy day!')\n\n This is correct.  Had we used %s instead of %q, the generated SQL\n would have looked like this:\n\n      INSERT INTO table1 VALUES('It's a happy day!');\n\n This second example is an SQL syntax error.  As a general rule you\n should always use %q instead of %s when inserting text into a string\n literal."]
    pub fn switch_mprintf(
        zFormat: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_vmprintf(
        zFormat: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_snprintfv(
        zBuf: *mut ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
        zFormat: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3 {
    _unused: [u8; 0],
}
#[doc = " @defgroup switch_sqlite_top Brought To You By SQLite\n @ingroup FREESWITCH\n @{\n/\n/**\n @defgroup switch_core_db Database Routines\n @ingroup switch_sqlite_top\n @{\n/\n/**\n Each open database is represented by an instance of the\n following opaque structure."]
pub type switch_core_db_t = sqlite3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_coredb_handle {
    pub in_memory: switch_bool_t,
    pub handle: *mut switch_core_db_t,
}
#[test]
fn bindgen_test_layout_switch_coredb_handle() {
    const UNINIT: ::std::mem::MaybeUninit<switch_coredb_handle> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_coredb_handle>(),
        16usize,
        concat!("Size of: ", stringify!(switch_coredb_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_coredb_handle>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_coredb_handle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).in_memory) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_coredb_handle),
            "::",
            stringify!(in_memory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_coredb_handle),
            "::",
            stringify!(handle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sqlite3_stmt {
    _unused: [u8; 0],
}
pub type switch_core_db_stmt_t = sqlite3_stmt;
pub type switch_core_db_callback_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        pArg: *mut ::std::os::raw::c_void,
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
        columnNames: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
pub type switch_core_db_err_callback_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        pArg: *mut ::std::os::raw::c_void,
        errmsg: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
pub type switch_core_db_destructor_type_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " A function to close the database.\n\n Call this function with a pointer to a structure that was previously\n returned from switch_core_db_open() and the corresponding database will by closed.\n\n All SQL statements prepared using switch_core_db_prepare()\n must be deallocated using switch_core_db_finalize() before\n this routine is called. Otherwise, SWITCH_CORE_DB_BUSY is returned and the\n database connection remains open."]
    pub fn switch_core_db_close(db: *mut switch_core_db_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Open the database file \"filename\".  The \"filename\" is UTF-8\n encoded.  A switch_core_db_t* handle is returned in *Db, even\n if an error occurs. If the database is opened (or created) successfully,\n then SWITCH_CORE_DB_OK is returned. Otherwise an error code is returned. The\n switch_core_db_errmsg() routine can be used to obtain\n an English language description of the error.\n\n If the database file does not exist, then a new database is created.\n The encoding for the database is UTF-8.\n\n Whether or not an error occurs when it is opened, resources associated\n with the switch_core_db_t* handle should be released by passing it to\n switch_core_db_close() when it is no longer required."]
    pub fn switch_core_db_open(
        filename: *const ::std::os::raw::c_char,
        ppDb: *mut *mut switch_core_db_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Same as switch_core_db_open() but additionally allows SQLITE_OPEN_URI"]
    pub fn switch_core_db_open_v2(
        filename: *const ::std::os::raw::c_char,
        ppDb: *mut *mut switch_core_db_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ^Strings returned by sqlite3_column_text() and sqlite3_column_text16(),\n even empty strings, are always zero-terminated.  ^The return\n value from sqlite3_column_blob() for a zero-length BLOB is a NULL pointer.\n\n ^The object returned by [sqlite3_column_value()] is an\n [unprotected sqlite3_value] object.  An unprotected sqlite3_value object\n may only be used with [sqlite3_bind_value()] and [sqlite3_result_value()].\n If the [unprotected sqlite3_value] object returned by\n [sqlite3_column_value()] is used in any other way, including calls\n to routines like [sqlite3_value_int()], [sqlite3_value_text()],\n or [sqlite3_value_bytes()], then the behavior is undefined.\n\n These routines attempt to convert the value where appropriate.  ^For\n example, if the internal representation is FLOAT and a text result\n is requested, [sqlite3_snprintf()] is used internally to perform the\n conversion automatically.  ^(The following table details the conversions\n that are applied:\n\n    Internal Type    Requested Type     Conversion\n    -------------    --------------    --------------------------\n       NULL             INTEGER         Result is 0\n       NULL             FLOAT           Result is 0.0\n       NULL             TEXT            Result is a NULL pointer\n       NULL             BLOB            Result is a NULL pointer\n       INTEGER          FLOAT           Convert from integer to float\n       INTEGER          TEXT            ASCII rendering of the integer\n       INTEGER          BLOB            Same as INTEGER->TEXT\n       FLOAT            INTEGER         [CAST] to INTEGER\n       FLOAT            TEXT            ASCII rendering of the float\n       FLOAT            BLOB            [CAST] to BLOB\n       TEXT             INTEGER         [CAST] to INTEGER\n       TEXT             FLOAT           [CAST] to REAL\n       TEXT             BLOB            No change\n       BLOB             INTEGER         [CAST] to INTEGER\n       BLOB             FLOAT           [CAST] to REAL\n       BLOB             TEXT            Add a zero terminator if needed\n\n  Return the value as UTF-8 text."]
    pub fn switch_core_db_column_text(
        stmt: *mut switch_core_db_stmt_t,
        iCol: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = " The first parameter is a compiled SQL statement. This function returns\n the column heading for the Nth column of that statement, where N is the\n second function parameter.  The string returned is UTF-8."]
    pub fn switch_core_db_column_name(
        stmt: *mut switch_core_db_stmt_t,
        N: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the number of columns in the result set returned by the compiled\n SQL statement. This routine returns 0 if pStmt is an SQL statement\n that does not return data (for example an UPDATE)."]
    pub fn switch_core_db_column_count(pStmt: *mut switch_core_db_stmt_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return a pointer to a UTF-8 encoded string describing in english the\n error condition for the most recent switch_core_db_* API call. The returned\n string is always terminated by an 0x00 byte.\n\n The string \"not an error\" is returned when the most recent API call was\n successful."]
    pub fn switch_core_db_errmsg(db: *mut switch_core_db_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " A function to executes one or more statements of SQL.\n\n If one or more of the SQL statements are queries, then\n the callback function specified by the 3rd parameter is\n invoked once for each row of the query result.  This callback\n should normally return 0.  If the callback returns a non-zero\n value then the query is aborted, all subsequent SQL statements\n are skipped and the switch_core_db_exec() function returns the SWITCH_CORE_DB_ABORT.\n\n The 4th parameter is an arbitrary pointer that is passed\n to the callback function as its first parameter.\n\n The 2nd parameter to the callback function is the number of\n columns in the query result.  The 3rd parameter to the callback\n is an array of strings holding the values for each column.\n The 4th parameter to the callback is an array of strings holding\n the names of each column.\n\n The callback function may be NULL, even for queries.  A NULL\n callback is not an error.  It just means that no callback\n will be invoked.\n\n If an error occurs while parsing or evaluating the SQL (but\n not while executing the callback) then an appropriate error\n message is written into memory obtained from malloc() and\n *errmsg is made to point to that message.  The calling function\n is responsible for freeing the memory that holds the error\n message.   Use switch_core_db_free() for this.  If errmsg==NULL,\n then no error message is ever written.\n\n The return value is is SWITCH_CORE_DB_OK if there are no errors and\n some other return code if there is an error.  The particular\n return value depends on the type of error.\n\n If the query could not be executed because a database file is\n locked or busy, then this function returns SWITCH_CORE_DB_BUSY.  (This\n behavior can be modified somewhat using the sswitch_core_db_busy_handler()\n and switch_core_db_busy_timeout() functions below.)"]
    pub fn switch_core_db_exec(
        db: *mut switch_core_db_t,
        sql: *const ::std::os::raw::c_char,
        callback: switch_core_db_callback_func_t,
        data: *mut ::std::os::raw::c_void,
        errmsg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function is called to delete a compiled\n SQL statement obtained by a previous call to switch_core_db_prepare().\n If the statement was executed successfully, or\n not executed at all, then SWITCH_CORE_DB_OK is returned. If execution of the\n statement failed then an error code is returned.\n\n This routine can be called at any point during the execution of the\n virtual machine.  If the virtual machine has not completed execution\n when this routine is called, that is like encountering an error or\n an interrupt.  (See switch_core_db_interrupt().)  Incomplete updates may be\n rolled back and transactions cancelled,  depending on the circumstances,\n and the result code returned will be SWITCH_CORE_DB_ABORT."]
    pub fn switch_core_db_finalize(pStmt: *mut switch_core_db_stmt_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " To execute an SQL query, it must first be compiled into a byte-code\n program using the following routine.\n\n The first parameter \"db\" is an SQLite database handle. The second\n parameter \"zSql\" is the statement to be compiled, encoded as\n UTF-8. If the next parameter, \"nBytes\", is less\n than zero, then zSql is read up to the first nul terminator.  If\n \"nBytes\" is not less than zero, then it is the length of the string zSql\n in bytes (not characters).\n\n *pzTail is made to point to the first byte past the end of the first\n SQL statement in zSql.  This routine only compiles the first statement\n in zSql, so *pzTail is left pointing to what remains uncompiled.\n\n *ppStmt is left pointing to a compiled SQL statement that can be\n executed using switch_core_db_step().  Or if there is an error, *ppStmt may be\n set to NULL.  If the input text contained no SQL (if the input is and\n empty string or a comment) then *ppStmt is set to NULL.\n\n On success, SWITCH_CORE_DB_OK is returned.  Otherwise an error code is returned."]
    pub fn switch_core_db_prepare(
        db: *mut switch_core_db_t,
        zSql: *const ::std::os::raw::c_char,
        nBytes: ::std::os::raw::c_int,
        ppStmt: *mut *mut switch_core_db_stmt_t,
        pzTail: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " After an SQL query has been compiled with a call to either\n switch_core_db_prepare(), then this function must be\n called one or more times to execute the statement.\n\n The return value will be either SWITCH_CORE_DB_BUSY, SWITCH_CORE_DB_DONE,\n SWITCH_CORE_DB_ROW, SWITCH_CORE_DB_ERROR, or SWITCH_CORE_DB_MISUSE.\n\n SWITCH_CORE_DB_BUSY means that the database engine attempted to open\n a locked database and there is no busy callback registered.\n Call switch_core_db_step() again to retry the open.\n\n SWITCH_CORE_DB_DONE means that the statement has finished executing\n successfully.  switch_core_db_step() should not be called again on this virtual\n machine.\n\n If the SQL statement being executed returns any data, then\n SWITCH_CORE_DB_ROW is returned each time a new row of data is ready\n for processing by the caller. The values may be accessed using\n the switch_core_db_column_*() functions described below. switch_core_db_step()\n is called again to retrieve the next row of data.\n\n SWITCH_CORE_DB_ERROR means that a run-time error (such as a constraint\n violation) has occurred.  switch_core_db_step() should not be called again on\n the VM. More information may be found by calling switch_core_db_errmsg().\n\n SWITCH_CORE_DB_MISUSE means that the this routine was called inappropriately.\n Perhaps it was called on a virtual machine that had already been\n finalized or on one that had previously returned SWITCH_CORE_DB_ERROR or\n SWITCH_CORE_DB_DONE.  Or it could be the case the the same database connection\n is being used simulataneously by two or more threads."]
    pub fn switch_core_db_step(stmt: *mut switch_core_db_stmt_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The switch_core_db_reset() function is called to reset a compiled SQL\n statement obtained by a previous call to switch_core_db_prepare()\n back to it's initial state, ready to be re-executed.\n Any SQL statement variables that had values bound to them using\n the switch_core_db_bind_*() API retain their values."]
    pub fn switch_core_db_reset(pStmt: *mut switch_core_db_stmt_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " In the SQL strings input to switch_core_db_prepare(),\n one or more literals can be replace by parameters \"?\" or \":AAA\" or\n \"$VVV\" where AAA is an identifer and VVV is a variable name according\n to the syntax rules of the TCL programming language.\n The value of these parameters (also called \"host parameter names\") can\n be set using the routines listed below.\n\n In every case, the first parameter is a pointer to the sqlite3_stmt\n structure returned from switch_core_db_prepare().  The second parameter is the\n index of the parameter.  The first parameter as an index of 1.  For\n named parameters (\":AAA\" or \"$VVV\") you can use\n switch_core_db_bind_parameter_index() to get the correct index value given\n the parameters name.  If the same named parameter occurs more than\n once, it is assigned the same index each time.\n\n The switch_core_db_bind_* routine must be called before switch_core_db_step() after\n an switch_core_db_prepare() or sqlite3_reset().  Unbound parameterss are\n interpreted as NULL."]
    pub fn switch_core_db_bind_int(
        pStmt: *mut switch_core_db_stmt_t,
        i: ::std::os::raw::c_int,
        iValue: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " In the SQL strings input to switch_core_db_prepare(),\n one or more literals can be replace by parameters \"?\" or \":AAA\" or\n \"$VVV\" where AAA is an identifer and VVV is a variable name according\n to the syntax rules of the TCL programming language.\n The value of these parameters (also called \"host parameter names\") can\n be set using the routines listed below.\n\n In every case, the first parameter is a pointer to the sqlite3_stmt\n structure returned from switch_core_db_prepare().  The second parameter is the\n index of the parameter.  The first parameter as an index of 1.  For\n named parameters (\":AAA\" or \"$VVV\") you can use\n switch_core_db_bind_parameter_index() to get the correct index value given\n the parameters name.  If the same named parameter occurs more than\n once, it is assigned the same index each time.\n\n The switch_core_db_bind_* routine must be called before switch_core_db_step() after\n an switch_core_db_prepare() or sqlite3_reset().  Unbound parameterss are\n interpreted as NULL."]
    pub fn switch_core_db_bind_int64(
        pStmt: *mut switch_core_db_stmt_t,
        i: ::std::os::raw::c_int,
        iValue: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " In the SQL strings input to switch_core_db_prepare(),\n one or more literals can be replace by parameters \"?\" or \":AAA\" or\n \"$VVV\" where AAA is an identifer and VVV is a variable name according\n to the syntax rules of the TCL programming language.\n The value of these parameters (also called \"host parameter names\") can\n be set using the routines listed below.\n\n In every case, the first parameter is a pointer to the sqlite3_stmt\n structure returned from switch_core_db_prepare().  The second parameter is the\n index of the parameter.  The first parameter as an index of 1.  For\n named parameters (\":AAA\" or \"$VVV\") you can use\n switch_core_db_bind_parameter_index() to get the correct index value given\n the parameters name.  If the same named parameter occurs more than\n once, it is assigned the same index each time.\n\n The fifth parameter to switch_core_db_bind_blob(), switch_core_db_bind_text(), and\n switch_core_db_bind_text16() is a destructor used to dispose of the BLOB or\n text after SQLite has finished with it.  If the fifth argument is the\n special value SQLITE_STATIC, then the library assumes that the information\n is in static, unmanaged space and does not need to be freed.  If the\n fifth argument has the value SQLITE_TRANSIENT, then SQLite makes its\n own private copy of the data.\n\n The switch_core_db_bind_* routine must be called before switch_core_db_step() after\n an switch_core_db_prepare() or sqlite3_reset().  Unbound parameterss are\n interpreted as NULL."]
    pub fn switch_core_db_bind_text(
        pStmt: *mut switch_core_db_stmt_t,
        i: ::std::os::raw::c_int,
        zData: *const ::std::os::raw::c_char,
        nData: ::std::os::raw::c_int,
        xDel: switch_core_db_destructor_type_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " In the SQL strings input to switch_core_db_prepare(),\n one or more literals can be replace by parameters \"?\" or \":AAA\" or\n \"$VVV\" where AAA is an identifer and VVV is a variable name according\n to the syntax rules of the TCL programming language.\n The value of these parameters (also called \"host parameter names\") can\n be set using the routines listed below.\n\n In every case, the first parameter is a pointer to the sqlite3_stmt\n structure returned from switch_core_db_prepare().  The second parameter is the\n index of the parameter.  The first parameter as an index of 1.  For\n named parameters (\":AAA\" or \"$VVV\") you can use\n sqlite3_bind_parameter_index() to get the correct index value given\n the parameters name.  If the same named parameter occurs more than\n once, it is assigned the same index each time.\n\n The sqlite3_bind_* routine must be called before switch_core_db_step() after\n an switch_core_db_prepare() or switch_core_db_reset().  Unbound parameterss are\n interpreted as NULL."]
    pub fn switch_core_db_bind_double(
        pStmt: *mut switch_core_db_stmt_t,
        i: ::std::os::raw::c_int,
        dValue: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Each entry in a table has a unique integer key.  (The key is\n the value of the INTEGER PRIMARY KEY column if there is such a column,\n otherwise the key is generated at random.  The unique key is always\n available as the ROWID, OID, or _ROWID_ column.)  The following routine\n returns the integer key of the most recent insert in the database.\n\n This function is similar to the mysql_insert_id() function from MySQL."]
    pub fn switch_core_db_last_insert_rowid(db: *mut switch_core_db_t) -> i64;
}
extern "C" {
    #[doc = " This next routine is really just a wrapper around switch_core_db_exec().\n Instead of invoking a user-supplied callback for each row of the\n result, this routine remembers each row of the result in memory\n obtained from malloc(), then returns all of the result after the\n query has finished.\n\n As an example, suppose the query result where this table:\n\n        Name        | Age\n        -----------------------\n        Alice       | 43\n        Bob         | 28\n        Cindy       | 21\n\n If the 3rd argument were &azResult then after the function returns\n azResult will contain the following data:\n\n        azResult[0] = \"Name\";\n        azResult[1] = \"Age\";\n        azResult[2] = \"Alice\";\n        azResult[3] = \"43\";\n        azResult[4] = \"Bob\";\n        azResult[5] = \"28\";\n        azResult[6] = \"Cindy\";\n        azResult[7] = \"21\";\n\n Notice that there is an extra row of data containing the column\n headers.  But the *nrow return value is still 3.  *ncolumn is\n set to 2.  In general, the number of values inserted into azResult\n will be ((*nrow) + 1)*(*ncolumn).\n\n After the calling function has finished using the result, it should\n pass the result data pointer to switch_core_db_free_table() in order to\n release the memory that was malloc-ed.  Because of the way the\n malloc() happens, the calling function must not try to call\n free() directly.  Only switch_core_db_free_table() is able to release\n the memory properly and safely.\n\n The return value of this routine is the same as from switch_core_db_exec()."]
    pub fn switch_core_db_get_table(
        db: *mut switch_core_db_t,
        sql: *const ::std::os::raw::c_char,
        resultp: *mut *mut *mut ::std::os::raw::c_char,
        nrow: *mut ::std::os::raw::c_int,
        ncolumn: *mut ::std::os::raw::c_int,
        errmsg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Call this routine to free the memory that sqlite3_get_table() allocated."]
    pub fn switch_core_db_free_table(result: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Call this routine to free the memory that switch_core_db_get_table() allocated."]
    pub fn switch_core_db_free(z: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Call this routine to find the number of rows changed by the last statement."]
    pub fn switch_core_db_changes(db: *mut switch_core_db_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Call this routine to load an external extension"]
    pub fn switch_core_db_load_extension(
        db: *mut switch_core_db_t,
        extension: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @} */\n/** @} */\n/**\n This routine is a variant of the \"sprintf()\" from the\n standard C library.  The resulting string is written into memory\n obtained from malloc() so that there is never a possiblity of buffer\n overflow.  This routine also implement some additional formatting\n options that are useful for constructing SQL statements.\n\n The strings returned by this routine should be freed by calling\n switch_core_db_free().\n\n All of the usual printf formatting options apply.  In addition, there\n is a \"%q\" option.  %q works like %s in that it substitutes a null-terminated\n string from the argument list.  But %q also doubles every '\\'' character.\n %q is designed for use inside a string literal.  By doubling each '\\''\n character it escapes that character and allows it to be inserted into\n the string.\n\n For example, so some string variable contains text as follows:\n\n      char *zText = \"It's a happy day!\";\n\n We can use this text in an SQL statement as follows:\n\n      char *z = switch_core_db_mprintf(\"INSERT INTO TABLES('%q')\", zText);\n      switch_core_db_exec(db, z, callback1, 0, 0);\n      switch_core_db_free(z);\n\n Because the %q format string is used, the '\\'' character in zText\n is escaped and the SQL generated is as follows:\n\n      INSERT INTO table1 VALUES('It''s a happy day!')\n\n This is correct.  Had we used %s instead of %q, the generated SQL\n would have looked like this:\n\n      INSERT INTO table1 VALUES('It's a happy day!');\n\n This second example is an SQL syntax error.  As a general rule you\n should always use %q instead of %s when inserting text into a string\n literal."]
    pub fn switch_sql_concat() -> *mut ::std::os::raw::c_char;
}
pub type switch_dso_func_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
pub type switch_dso_lib_t = *mut ::std::os::raw::c_void;
pub type switch_dso_data_t = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn switch_dso_destroy(lib: *mut switch_dso_lib_t);
}
extern "C" {
    pub fn switch_dso_open(
        path: *const ::std::os::raw::c_char,
        global: ::std::os::raw::c_int,
        err: *mut *mut ::std::os::raw::c_char,
    ) -> switch_dso_lib_t;
}
extern "C" {
    pub fn switch_dso_func_sym(
        lib: switch_dso_lib_t,
        sym: *const ::std::os::raw::c_char,
        err: *mut *mut ::std::os::raw::c_char,
    ) -> switch_dso_func_t;
}
extern "C" {
    pub fn switch_dso_data_sym(
        lib: switch_dso_lib_t,
        sym: *const ::std::os::raw::c_char,
        err: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct real_pcre {
    _unused: [u8; 0],
}
#[doc = " @defgroup switch_regex Regular Expressions\n @ingroup FREESWITCH\n @{"]
pub type switch_regex_t = real_pcre;
extern "C" {
    pub fn switch_regex_compile(
        pattern: *const ::std::os::raw::c_char,
        options: ::std::os::raw::c_int,
        errorptr: *mut *const ::std::os::raw::c_char,
        erroroffset: *mut ::std::os::raw::c_int,
        tables: *const ::std::os::raw::c_uchar,
    ) -> *mut switch_regex_t;
}
extern "C" {
    pub fn switch_regex_copy_substring(
        subject: *const ::std::os::raw::c_char,
        ovector: *mut ::std::os::raw::c_int,
        stringcount: ::std::os::raw::c_int,
        stringnumber: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_regex_free(data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn switch_regex_perform(
        field: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
        new_re: *mut *mut switch_regex_t,
        ovector: *mut ::std::os::raw::c_int,
        olen: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_perform_substitution(
        re: *mut switch_regex_t,
        match_count: ::std::os::raw::c_int,
        data: *const ::std::os::raw::c_char,
        field_data: *const ::std::os::raw::c_char,
        substituted: *mut ::std::os::raw::c_char,
        len: switch_size_t,
        ovector: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "\\brief Function to evaluate an expression against a string\n\\param target The string to find a match in\n\\param expression The regular expression to run against the string\n\\return Boolean if a match was found or not"]
    pub fn switch_regex_match(
        target: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Function to evaluate an expression against a string\n\\param target The string to find a match in\n\\param expression The regular expression to run against the string\n\\param partial_match If non-zero returns SUCCESS if the target is a partial match, on successful return, this is set to non-zero if the match was partial and zero if it was a full match\n\\return Boolean if a match was found or not"]
    pub fn switch_regex_match_partial(
        target: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
        partial_match: *mut ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_capture_regex(
        re: *mut switch_regex_t,
        match_count: ::std::os::raw::c_int,
        field_data: *const ::std::os::raw::c_char,
        ovector: *mut ::std::os::raw::c_int,
        var: *const ::std::os::raw::c_char,
        callback: switch_cap_callback_t,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn switch_regex_set_var_callback(
        var: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn switch_regex_set_event_header_callback(
        var: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_core_time_duration {
    pub mms: u32,
    pub ms: u32,
    pub sec: u32,
    pub min: u32,
    pub hr: u32,
    pub day: u32,
    pub yr: u32,
}
#[test]
fn bindgen_test_layout_switch_core_time_duration() {
    const UNINIT: ::std::mem::MaybeUninit<switch_core_time_duration> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_core_time_duration>(),
        28usize,
        concat!("Size of: ", stringify!(switch_core_time_duration))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_core_time_duration>(),
        4usize,
        concat!("Alignment of ", stringify!(switch_core_time_duration))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mms) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_time_duration),
            "::",
            stringify!(mms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ms) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_time_duration),
            "::",
            stringify!(ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_time_duration),
            "::",
            stringify!(sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_time_duration),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_time_duration),
            "::",
            stringify!(hr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).day) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_time_duration),
            "::",
            stringify!(day)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_time_duration),
            "::",
            stringify!(yr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_app_log {
    pub app: *mut ::std::os::raw::c_char,
    pub arg: *mut ::std::os::raw::c_char,
    pub stamp: switch_time_t,
    pub next: *mut switch_app_log,
}
#[test]
fn bindgen_test_layout_switch_app_log() {
    const UNINIT: ::std::mem::MaybeUninit<switch_app_log> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_app_log>(),
        32usize,
        concat!("Size of: ", stringify!(switch_app_log))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_app_log>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_app_log))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).app) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_app_log),
            "::",
            stringify!(app)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_app_log),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stamp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_app_log),
            "::",
            stringify!(stamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_app_log),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_thread_data_s {
    pub func: switch_thread_start_t,
    pub obj: *mut ::std::os::raw::c_void,
    pub alloc: ::std::os::raw::c_int,
    pub running: ::std::os::raw::c_int,
    pub pool: *mut switch_memory_pool_t,
}
#[test]
fn bindgen_test_layout_switch_thread_data_s() {
    const UNINIT: ::std::mem::MaybeUninit<switch_thread_data_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_thread_data_s>(),
        32usize,
        concat!("Size of: ", stringify!(switch_thread_data_s))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_thread_data_s>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_thread_data_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_thread_data_s),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).obj) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_thread_data_s),
            "::",
            stringify!(obj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_thread_data_s),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).running) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_thread_data_s),
            "::",
            stringify!(running)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_thread_data_s),
            "::",
            stringify!(pool)
        )
    );
}
pub type switch_thread_data_t = switch_thread_data_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_hold_record_s {
    pub on: switch_time_t,
    pub off: switch_time_t,
    pub uuid: *mut ::std::os::raw::c_char,
    pub next: *mut switch_hold_record_s,
}
#[test]
fn bindgen_test_layout_switch_hold_record_s() {
    const UNINIT: ::std::mem::MaybeUninit<switch_hold_record_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_hold_record_s>(),
        32usize,
        concat!("Size of: ", stringify!(switch_hold_record_s))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_hold_record_s>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_hold_record_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_hold_record_s),
            "::",
            stringify!(on)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).off) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_hold_record_s),
            "::",
            stringify!(off)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uuid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_hold_record_s),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_hold_record_s),
            "::",
            stringify!(next)
        )
    );
}
pub type switch_hold_record_t = switch_hold_record_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_uuid_node_s {
    pub uuid: *mut ::std::os::raw::c_char,
    pub xml_cdr: switch_xml_t,
    pub event: *mut switch_event_t,
    pub callstate: switch_channel_callstate_t,
    pub hold_record: *mut switch_hold_record_t,
    pub hup_profile: *mut switch_caller_profile_t,
    pub direction: switch_call_direction_t,
    pub parent: *mut switch_device_record_s,
    pub next: *mut device_uuid_node_s,
}
#[test]
fn bindgen_test_layout_device_uuid_node_s() {
    const UNINIT: ::std::mem::MaybeUninit<device_uuid_node_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<device_uuid_node_s>(),
        72usize,
        concat!("Size of: ", stringify!(device_uuid_node_s))
    );
    assert_eq!(
        ::std::mem::align_of::<device_uuid_node_s>(),
        8usize,
        concat!("Alignment of ", stringify!(device_uuid_node_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(device_uuid_node_s),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xml_cdr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(device_uuid_node_s),
            "::",
            stringify!(xml_cdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(device_uuid_node_s),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callstate) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(device_uuid_node_s),
            "::",
            stringify!(callstate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hold_record) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(device_uuid_node_s),
            "::",
            stringify!(hold_record)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hup_profile) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(device_uuid_node_s),
            "::",
            stringify!(hup_profile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).direction) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(device_uuid_node_s),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(device_uuid_node_s),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(device_uuid_node_s),
            "::",
            stringify!(next)
        )
    );
}
pub type switch_device_node_t = device_uuid_node_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_device_stats_s {
    pub total: u32,
    pub total_in: u32,
    pub total_out: u32,
    pub offhook: u32,
    pub offhook_in: u32,
    pub offhook_out: u32,
    pub active: u32,
    pub active_in: u32,
    pub active_out: u32,
    pub held: u32,
    pub held_in: u32,
    pub held_out: u32,
    pub unheld: u32,
    pub unheld_in: u32,
    pub unheld_out: u32,
    pub hup: u32,
    pub hup_in: u32,
    pub hup_out: u32,
    pub ringing: u32,
    pub ringing_in: u32,
    pub ringing_out: u32,
    pub early: u32,
    pub early_in: u32,
    pub early_out: u32,
    pub ring_wait: u32,
}
#[test]
fn bindgen_test_layout_switch_device_stats_s() {
    const UNINIT: ::std::mem::MaybeUninit<switch_device_stats_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_device_stats_s>(),
        100usize,
        concat!("Size of: ", stringify!(switch_device_stats_s))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_device_stats_s>(),
        4usize,
        concat!("Alignment of ", stringify!(switch_device_stats_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_stats_s),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_in) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_stats_s),
            "::",
            stringify!(total_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_out) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_stats_s),
            "::",
            stringify!(total_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offhook) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_stats_s),
            "::",
            stringify!(offhook)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offhook_in) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_stats_s),
            "::",
            stringify!(offhook_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offhook_out) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_stats_s),
            "::",
            stringify!(offhook_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).active) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_stats_s),
            "::",
            stringify!(active)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).active_in) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_stats_s),
            "::",
            stringify!(active_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).active_out) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_stats_s),
            "::",
            stringify!(active_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).held) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_stats_s),
            "::",
            stringify!(held)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).held_in) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_stats_s),
            "::",
            stringify!(held_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).held_out) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_stats_s),
            "::",
            stringify!(held_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unheld) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_stats_s),
            "::",
            stringify!(unheld)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unheld_in) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_stats_s),
            "::",
            stringify!(unheld_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unheld_out) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_stats_s),
            "::",
            stringify!(unheld_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hup) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_stats_s),
            "::",
            stringify!(hup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hup_in) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_stats_s),
            "::",
            stringify!(hup_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hup_out) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_stats_s),
            "::",
            stringify!(hup_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ringing) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_stats_s),
            "::",
            stringify!(ringing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ringing_in) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_stats_s),
            "::",
            stringify!(ringing_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ringing_out) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_stats_s),
            "::",
            stringify!(ringing_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).early) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_stats_s),
            "::",
            stringify!(early)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).early_in) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_stats_s),
            "::",
            stringify!(early_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).early_out) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_stats_s),
            "::",
            stringify!(early_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ring_wait) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_stats_s),
            "::",
            stringify!(ring_wait)
        )
    );
}
pub type switch_device_stats_t = switch_device_stats_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_device_record_s {
    pub device_id: *mut ::std::os::raw::c_char,
    pub uuid: *mut ::std::os::raw::c_char,
    pub refs: ::std::os::raw::c_int,
    pub stats: switch_device_stats_t,
    pub last_stats: switch_device_stats_t,
    pub state: switch_device_state_t,
    pub last_state: switch_device_state_t,
    pub active_start: switch_time_t,
    pub active_stop: switch_time_t,
    pub last_call_time: switch_time_t,
    pub ring_start: switch_time_t,
    pub ring_stop: switch_time_t,
    pub hold_start: switch_time_t,
    pub hold_stop: switch_time_t,
    pub call_start: switch_time_t,
    pub uuid_list: *mut device_uuid_node_s,
    pub uuid_tail: *mut device_uuid_node_s,
    pub mutex: *mut switch_mutex_t,
    pub pool: *mut switch_memory_pool_t,
    pub user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_switch_device_record_s() {
    const UNINIT: ::std::mem::MaybeUninit<switch_device_record_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_device_record_s>(),
        336usize,
        concat!("Size of: ", stringify!(switch_device_record_s))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_device_record_s>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_device_record_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_record_s),
            "::",
            stringify!(device_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uuid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_record_s),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_record_s),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stats) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_record_s),
            "::",
            stringify!(stats)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_stats) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_record_s),
            "::",
            stringify!(last_stats)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_record_s),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_state) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_record_s),
            "::",
            stringify!(last_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).active_start) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_record_s),
            "::",
            stringify!(active_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).active_stop) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_record_s),
            "::",
            stringify!(active_stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_call_time) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_record_s),
            "::",
            stringify!(last_call_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ring_start) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_record_s),
            "::",
            stringify!(ring_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ring_stop) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_record_s),
            "::",
            stringify!(ring_stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hold_start) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_record_s),
            "::",
            stringify!(hold_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hold_stop) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_record_s),
            "::",
            stringify!(hold_stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).call_start) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_record_s),
            "::",
            stringify!(call_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uuid_list) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_record_s),
            "::",
            stringify!(uuid_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uuid_tail) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_record_s),
            "::",
            stringify!(uuid_tail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_record_s),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_record_s),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_device_record_s),
            "::",
            stringify!(user_data)
        )
    );
}
pub type switch_device_record_t = switch_device_record_s;
pub type switch_device_state_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        session: *mut switch_core_session_t,
        callstate: switch_channel_callstate_t,
        drec: *mut switch_device_record_t,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dtls_fp_s {
    pub len: u32,
    pub data: [u8; 65usize],
    pub type_: *mut ::std::os::raw::c_char,
    pub str_: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout_dtls_fp_s() {
    const UNINIT: ::std::mem::MaybeUninit<dtls_fp_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dtls_fp_s>(),
        272usize,
        concat!("Size of: ", stringify!(dtls_fp_s))
    );
    assert_eq!(
        ::std::mem::align_of::<dtls_fp_s>(),
        8usize,
        concat!("Alignment of ", stringify!(dtls_fp_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls_fp_s),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls_fp_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls_fp_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(dtls_fp_s),
            "::",
            stringify!(str_)
        )
    );
}
pub type dtls_fingerprint_t = dtls_fp_s;
pub const dtls_type_t_DTLS_TYPE_CLIENT: dtls_type_t = 1;
pub const dtls_type_t_DTLS_TYPE_SERVER: dtls_type_t = 2;
pub const dtls_type_t_DTLS_TYPE_RTP: dtls_type_t = 4;
pub const dtls_type_t_DTLS_TYPE_RTCP: dtls_type_t = 8;
pub type dtls_type_t = ::std::os::raw::c_uint;
pub const dtls_state_t_DS_OFF: dtls_state_t = 0;
pub const dtls_state_t_DS_HANDSHAKE: dtls_state_t = 1;
pub const dtls_state_t_DS_SETUP: dtls_state_t = 2;
pub const dtls_state_t_DS_READY: dtls_state_t = 3;
pub const dtls_state_t_DS_FAIL: dtls_state_t = 4;
pub const dtls_state_t_DS_INVALID: dtls_state_t = 5;
pub type dtls_state_t = ::std::os::raw::c_uint;
#[doc = " \\brief A message object designed to allow unlike technologies to exchange data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_core_session_message {
    #[doc = " uuid of the sender (for replies)"]
    pub from: *mut ::std::os::raw::c_char,
    #[doc = " enumeration of the type of message"]
    pub message_id: switch_core_session_message_types_t,
    #[doc = " optional numeric arg"]
    pub numeric_arg: ::std::os::raw::c_int,
    #[doc = " optional string arg"]
    pub string_arg: *const ::std::os::raw::c_char,
    #[doc = " optional string arg"]
    pub string_arg_size: switch_size_t,
    #[doc = " optional arbitrary pointer arg"]
    pub pointer_arg: *mut ::std::os::raw::c_void,
    #[doc = " optional arbitrary pointer arg's size"]
    pub pointer_arg_size: switch_size_t,
    #[doc = " optional numeric reply"]
    pub numeric_reply: ::std::os::raw::c_int,
    #[doc = " optional string reply"]
    pub string_reply: *mut ::std::os::raw::c_char,
    #[doc = " optional string reply"]
    pub string_reply_size: switch_size_t,
    #[doc = " optional arbitrary pointer reply"]
    pub pointer_reply: *mut ::std::os::raw::c_void,
    #[doc = " optional arbitrary pointer reply's size"]
    pub pointer_reply_size: switch_size_t,
    #[doc = " message flags"]
    pub flags: switch_core_session_message_flag_t,
    pub _file: *const ::std::os::raw::c_char,
    pub _func: *const ::std::os::raw::c_char,
    pub _line: ::std::os::raw::c_int,
    pub string_array_arg: [*const ::std::os::raw::c_char; 10usize],
    pub delivery_time: time_t,
}
#[test]
fn bindgen_test_layout_switch_core_session_message() {
    const UNINIT: ::std::mem::MaybeUninit<switch_core_session_message> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_core_session_message>(),
        208usize,
        concat!("Size of: ", stringify!(switch_core_session_message))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_core_session_message>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_core_session_message))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).from) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_session_message),
            "::",
            stringify!(from)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_session_message),
            "::",
            stringify!(message_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numeric_arg) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_session_message),
            "::",
            stringify!(numeric_arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).string_arg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_session_message),
            "::",
            stringify!(string_arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).string_arg_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_session_message),
            "::",
            stringify!(string_arg_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pointer_arg) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_session_message),
            "::",
            stringify!(pointer_arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pointer_arg_size) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_session_message),
            "::",
            stringify!(pointer_arg_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numeric_reply) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_session_message),
            "::",
            stringify!(numeric_reply)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).string_reply) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_session_message),
            "::",
            stringify!(string_reply)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).string_reply_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_session_message),
            "::",
            stringify!(string_reply_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pointer_reply) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_session_message),
            "::",
            stringify!(pointer_reply)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pointer_reply_size) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_session_message),
            "::",
            stringify!(pointer_reply_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_session_message),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._file) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_session_message),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._func) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_session_message),
            "::",
            stringify!(_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._line) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_session_message),
            "::",
            stringify!(_line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).string_array_arg) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_session_message),
            "::",
            stringify!(string_array_arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delivery_time) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_session_message),
            "::",
            stringify!(delivery_time)
        )
    );
}
#[doc = " \\brief A generic object to pass as a thread's session object to allow mutiple arguements and a pool"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_core_thread_session {
    #[doc = " status of the thread"]
    pub running: ::std::os::raw::c_int,
    #[doc = " mutex"]
    pub mutex: *mut switch_mutex_t,
    #[doc = " array of void pointers to pass mutiple data objects"]
    pub objs: [*mut ::std::os::raw::c_void; 128usize],
    #[doc = " a pointer to a memory pool if the thread has it's own pool"]
    pub input_callback: switch_input_callback_function_t,
    pub pool: *mut switch_memory_pool_t,
}
#[test]
fn bindgen_test_layout_switch_core_thread_session() {
    const UNINIT: ::std::mem::MaybeUninit<switch_core_thread_session> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_core_thread_session>(),
        1056usize,
        concat!("Size of: ", stringify!(switch_core_thread_session))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_core_thread_session>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_core_thread_session))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).running) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_thread_session),
            "::",
            stringify!(running)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_thread_session),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).objs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_thread_session),
            "::",
            stringify!(objs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_callback) as usize - ptr as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_thread_session),
            "::",
            stringify!(input_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_thread_session),
            "::",
            stringify!(pool)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_core_runtime {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "\\defgroup mb1 Media Bugs\n\\ingroup core1\n\\{"]
    pub fn switch_core_screen_size(x: *mut ::std::os::raw::c_int, y: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn switch_core_session_sched_heartbeat(session: *mut switch_core_session_t, seconds: u32);
}
extern "C" {
    pub fn switch_core_session_unsched_heartbeat(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_session_enable_heartbeat(session: *mut switch_core_session_t, seconds: u32);
}
extern "C" {
    pub fn switch_core_session_disable_heartbeat(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_media_bug_pop(
        orig_session: *mut switch_core_session_t,
        function: *const ::std::os::raw::c_char,
        pop: *mut *mut switch_media_bug_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_bug_exec_all(
        orig_session: *mut switch_core_session_t,
        function: *const ::std::os::raw::c_char,
        cb: switch_media_bug_exec_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_bug_patch_video(
        orig_session: *mut switch_core_session_t,
        frame: *mut switch_frame_t,
    ) -> u32;
}
extern "C" {
    pub fn switch_core_media_bug_count(
        orig_session: *mut switch_core_session_t,
        function: *const ::std::os::raw::c_char,
    ) -> u32;
}
extern "C" {
    pub fn switch_media_bug_set_spy_fmt(
        bug: *mut switch_media_bug_t,
        spy_fmt: switch_vid_spy_fmt_t,
    );
}
extern "C" {
    pub fn switch_core_media_bug_push_spy_frame(
        bug: *mut switch_media_bug_t,
        frame: *mut switch_frame_t,
        rw: switch_rw_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_bug_patch_spy_frame(
        bug: *mut switch_media_bug_t,
        img: *mut switch_image_t,
        rw: switch_rw_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_media_bug_parse_spy_fmt(
        name: *const ::std::os::raw::c_char,
    ) -> switch_vid_spy_fmt_t;
}
extern "C" {
    #[doc = "\\brief Add a media bug to the session\n\\param session the session to add the bug to\n\\param function user defined module/function/reason identifying this bug\n\\param target user defined identification of the target of the bug\n\\param callback a callback for events\n\\param user_data arbitrary user data\n\\param stop_time absolute time at which the bug is automatically removed (or 0)\n\\param flags flags to choose the stream\n\\param new_bug pointer to assign new bug to\n\\return SWITCH_STATUS_SUCCESS if the operation was a success"]
    pub fn switch_core_media_bug_add(
        session: *mut switch_core_session_t,
        function: *const ::std::os::raw::c_char,
        target: *const ::std::os::raw::c_char,
        callback: switch_media_bug_callback_t,
        user_data: *mut ::std::os::raw::c_void,
        stop_time: time_t,
        flags: switch_media_bug_flag_t,
        new_bug: *mut *mut switch_media_bug_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Pause a media bug on the session\n\\param session the session to pause the bug on sets CF_PAUSE_BUGS flag"]
    pub fn switch_core_media_bug_pause(session: *mut switch_core_session_t);
}
extern "C" {
    #[doc = "\\brief Resume a media bug on the session\n\\param session the session to resume the bug on, clears CF_PAUSE_BUGS flag"]
    pub fn switch_core_media_bug_resume(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_media_bug_inuse(
        bug: *mut switch_media_bug_t,
        readp: *mut switch_size_t,
        writep: *mut switch_size_t,
    );
}
extern "C" {
    #[doc = "\\brief Obtain private data from a media bug\n\\param bug the bug to get the data from\n\\return the private data"]
    pub fn switch_core_media_bug_get_user_data(
        bug: *mut switch_media_bug_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "\\brief Obtain a replace frame from a media bug\n\\param bug the bug to get the data from"]
    pub fn switch_core_media_bug_get_write_replace_frame(
        bug: *mut switch_media_bug_t,
    ) -> *mut switch_frame_t;
}
extern "C" {
    pub fn switch_core_media_bug_get_native_read_frame(
        bug: *mut switch_media_bug_t,
    ) -> *mut switch_frame_t;
}
extern "C" {
    pub fn switch_core_media_bug_get_native_write_frame(
        bug: *mut switch_media_bug_t,
    ) -> *mut switch_frame_t;
}
extern "C" {
    pub fn switch_core_media_bug_get_video_ping_frame(
        bug: *mut switch_media_bug_t,
    ) -> *mut switch_frame_t;
}
extern "C" {
    #[doc = "\\brief Set a return replace frame\n\\param bug the bug to set the frame on\n\\param frame the frame to set"]
    pub fn switch_core_media_bug_set_write_replace_frame(
        bug: *mut switch_media_bug_t,
        frame: *mut switch_frame_t,
    );
}
extern "C" {
    #[doc = "\\brief Obtain a replace frame from a media bug\n\\param bug the bug to get the data from"]
    pub fn switch_core_media_bug_get_read_replace_frame(
        bug: *mut switch_media_bug_t,
    ) -> *mut switch_frame_t;
}
extern "C" {
    pub fn switch_core_media_bug_set_read_demux_frame(
        bug: *mut switch_media_bug_t,
        frame: *mut switch_frame_t,
    );
}
extern "C" {
    #[doc = "\\brief Obtain the session from a media bug\n\\param bug the bug to get the data from"]
    pub fn switch_core_media_bug_get_session(
        bug: *mut switch_media_bug_t,
    ) -> *mut switch_core_session_t;
}
extern "C" {
    pub fn switch_core_media_bug_set_media_params(
        bug: *mut switch_media_bug_t,
        mm: *mut switch_mm_t,
    );
}
extern "C" {
    pub fn switch_core_media_bug_get_media_params(
        bug: *mut switch_media_bug_t,
        mm: *mut switch_mm_t,
    );
}
extern "C" {
    pub fn switch_core_media_bug_get_text(
        bug: *mut switch_media_bug_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Test for the existance of a flag on an media bug\n\\param bug the object to test\n\\param flag the or'd list of flags to test\n\\return true value if the object has the flags defined"]
    pub fn switch_core_media_bug_test_flag(bug: *mut switch_media_bug_t, flag: u32) -> u32;
}
extern "C" {
    pub fn switch_core_media_bug_set_flag(bug: *mut switch_media_bug_t, flag: u32) -> u32;
}
extern "C" {
    pub fn switch_core_media_bug_clear_flag(bug: *mut switch_media_bug_t, flag: u32) -> u32;
}
extern "C" {
    #[doc = "\\brief Set a return replace frame\n\\param bug the bug to set the frame on\n\\param frame the frame to set"]
    pub fn switch_core_media_bug_set_read_replace_frame(
        bug: *mut switch_media_bug_t,
        frame: *mut switch_frame_t,
    );
}
extern "C" {
    pub fn switch_core_cpu_count() -> u32;
}
extern "C" {
    #[doc = "\\brief Remove a media bug from the session\n\\param session the session to remove the bug from\n\\param bug bug to remove\n\\return SWITCH_STATUS_SUCCESS if the operation was a success"]
    pub fn switch_core_media_bug_remove(
        session: *mut switch_core_session_t,
        bug: *mut *mut switch_media_bug_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_bug_prune(session: *mut switch_core_session_t) -> u32;
}
extern "C" {
    #[doc = "\\brief Remove media bug callback\n\\param bug bug to remove\n\\param callback callback to remove\n\\return SWITCH_STATUS_SUCCESS if the operation was a success"]
    pub fn switch_core_media_bug_remove_callback(
        session: *mut switch_core_session_t,
        callback: switch_media_bug_callback_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Close and destroy a media bug\n\\param bug bug to remove\n\\return SWITCH_STATUS_SUCCESS if the operation was a success"]
    pub fn switch_core_media_bug_close(
        bug: *mut *mut switch_media_bug_t,
        destroy: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Remove all media bugs from the session\n\\param session the session to remove the bugs from\n\\return SWITCH_STATUS_SUCCESS if the operation was a success"]
    pub fn switch_core_media_bug_remove_all_function(
        session: *mut switch_core_session_t,
        function: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_bug_enumerate(
        session: *mut switch_core_session_t,
        stream: *mut switch_stream_handle_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_bug_transfer_callback(
        orig_session: *mut switch_core_session_t,
        new_session: *mut switch_core_session_t,
        callback: switch_media_bug_callback_t,
        user_data_dup_func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut switch_core_session_t,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Read a frame from the bug\n\\param bug the bug to read from\n\\param frame the frame to write the data to\n\\return SWITCH_STATUS_SUCCESS if the operation was a success"]
    pub fn switch_core_media_bug_read(
        bug: *mut switch_media_bug_t,
        frame: *mut switch_frame_t,
        fill: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Flush the read and write buffers for the bug\n\\param bug the bug to flush the read and write buffers on"]
    pub fn switch_core_media_bug_flush(bug: *mut switch_media_bug_t);
}
extern "C" {
    #[doc = "\\brief Flush the read/write buffers for all media bugs on the session\n\\param session the session to flush the read/write buffers for all media bugs on the session"]
    pub fn switch_core_media_bug_flush_all(session: *mut switch_core_session_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_bug_set_pre_buffer_framecount(
        bug: *mut switch_media_bug_t,
        framecount: u32,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Initilize the port allocator\n\\param start the starting port\n\\param end the ending port\n\\param flags flags to change allocator behaviour (e.g. only even/odd portnumbers)\n\\param new_allocator new pointer for the return value\n\\return SWITCH_STATUS_SUCCESS if the operation was a success"]
    pub fn switch_core_port_allocator_new(
        ip: *const ::std::os::raw::c_char,
        start: switch_port_t,
        end: switch_port_t,
        flags: switch_port_flag_t,
        new_allocator: *mut *mut switch_core_port_allocator_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Get a port from the port allocator\n\\param alloc the allocator object\n\\param port_ptr a pointer to the port\n\\return SUCCESS"]
    pub fn switch_core_port_allocator_request_port(
        alloc: *mut switch_core_port_allocator_t,
        port_ptr: *mut switch_port_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Return unused port to the port allocator\n\\param alloc the allocator object\n\\param port the port\n\\return SUCCESS"]
    pub fn switch_core_port_allocator_free_port(
        alloc: *mut switch_core_port_allocator_t,
        port: switch_port_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief destroythe port allocator\n\\param alloc the allocator object"]
    pub fn switch_core_port_allocator_destroy(alloc: *mut *mut switch_core_port_allocator_t);
}
extern "C" {
    #[doc = "\\}"]
    pub fn switch_core_test_flag(flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\defgroup ss Startup/Shutdown\n\\ingroup core1\n\\{\n*!\n\\brief Initilize the core\n\\param console optional FILE stream for output\n\\param flags core flags\n\\param err a pointer to set any errors to\n\\note to be called at application startup\n*/"]
    pub fn switch_core_init(
        flags: switch_core_flag_t,
        console: switch_bool_t,
        err: *mut *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Initilize the core and load modules\n\\param console optional FILE stream for output\n\\param flags core flags\n\\param err a pointer to set any errors to\n\\note to be called at application startup instead of switch_core_init.  Includes module loading."]
    pub fn switch_core_init_and_modload(
        flags: switch_core_flag_t,
        console: switch_bool_t,
        err: *mut *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Set/Get Session Limit\n\\param new_limit new value (if > 0)\n\\return the current session limit"]
    pub fn switch_core_session_limit(new_limit: u32) -> u32;
}
extern "C" {
    #[doc = "\\brief Set/Get Session Rate Limit\n\\param new_limit new value (if > 0)\n\\return the current session rate limit"]
    pub fn switch_core_sessions_per_second(new_limit: u32) -> u32;
}
extern "C" {
    #[doc = "\\brief Destroy the core\n\\note to be called at application shutdown"]
    pub fn switch_core_destroy() -> switch_status_t;
}
extern "C" {
    #[doc = "\\defgroup rwl Read/Write Locking\n\\ingroup core1\n\\{"]
    pub fn switch_core_session_io_read_lock(session: *mut switch_core_session_t)
        -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_io_write_lock(
        session: *mut switch_core_session_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_io_rwunlock(session: *mut switch_core_session_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_read_lock(session: *mut switch_core_session_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_read_lock_hangup(
        session: *mut switch_core_session_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_write_lock(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_session_rwunlock(session: *mut switch_core_session_t);
}
extern "C" {
    #[doc = "\\defgroup sh State Handlers\n\\ingroup core1\n\\{\n*!\n\\brief Add a global state handler\n\\param state_handler a state handler to add\n\\return the current index/priority of this handler\n*/"]
    pub fn switch_core_add_state_handler(
        state_handler: *const switch_state_handler_table_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Remove a global state handler\n\\param state_handler the state handler to remove"]
    pub fn switch_core_remove_state_handler(state_handler: *const switch_state_handler_table_t);
}
extern "C" {
    #[doc = "\\brief Access a state handler\n\\param index the desired index to access\n\\return the desired state handler table or NULL when it does not exist."]
    pub fn switch_core_get_state_handler(
        index: ::std::os::raw::c_int,
    ) -> *const switch_state_handler_table_t;
}
extern "C" {
    #[doc = "\\}"]
    pub fn switch_core_memory_pool_tag(
        pool: *mut switch_memory_pool_t,
        tag: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn switch_core_pool_stats(stream: *mut switch_stream_handle_t);
}
extern "C" {
    pub fn switch_core_perform_new_memory_pool(
        pool: *mut *mut switch_memory_pool_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_sync_clock() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_core_perform_destroy_memory_pool(
        pool: *mut *mut switch_memory_pool_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_memory_pool_set_data(
        pool: *mut switch_memory_pool_t,
        key: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn switch_core_memory_pool_get_data(
        pool: *mut switch_memory_pool_t,
        key: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "\\brief Start the session's state machine\n\\param session the session on which to start the state machine"]
    pub fn switch_core_session_run(session: *mut switch_core_session_t);
}
extern "C" {
    #[doc = "\\brief determine if the session's state machine is running\n\\param session the session on which to check"]
    pub fn switch_core_session_running(
        session: *mut switch_core_session_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn switch_core_session_started(
        session: *mut switch_core_session_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn switch_core_perform_permanent_alloc(
        memory: switch_size_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn switch_core_perform_alloc(
        pool: *mut switch_memory_pool_t,
        memory: switch_size_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn switch_core_perform_session_alloc(
        session: *mut switch_core_session_t,
        memory: switch_size_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn switch_core_perform_permanent_strdup(
        todup: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_core_perform_session_strdup(
        session: *mut switch_core_session_t,
        todup: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_core_perform_strdup(
        pool: *mut switch_memory_pool_t,
        todup: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_core_perform_strndup(
        pool: *mut switch_memory_pool_t,
        todup: *const ::std::os::raw::c_char,
        len: usize,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief printf-style style printing routine.  The data is output to a string allocated from the session\n\\param session a session to use for allocation\n\\param fmt The format of the string\n\\param ... The arguments to use while printing the data\n\\return The new string"]
    pub fn switch_core_session_sprintf(
        session: *mut switch_core_session_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_core_session_vsprintf(
        session: *mut switch_core_session_t,
        fmt: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief printf-style style printing routine.  The data is output to a string allocated from the pool\n\\param pool a pool to use for allocation\n\\param fmt The format of the string\n\\param ... The arguments to use while printing the data\n\\return The new string"]
    pub fn switch_core_sprintf(
        pool: *mut switch_memory_pool_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_core_vsprintf(
        pool: *mut switch_memory_pool_t,
        fmt: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Retrieve the memory pool from a session\n\\param session the session to retrieve the pool from\n\\return the session's pool\n\\note to be used sparingly"]
    pub fn switch_core_session_get_pool(
        session: *mut switch_core_session_t,
    ) -> *mut switch_memory_pool_t;
}
extern "C" {
    #[doc = "\\}"]
    pub fn switch_core_session_request_xml(
        endpoint_interface: *mut switch_endpoint_interface_t,
        pool: *mut *mut switch_memory_pool_t,
        xml: switch_xml_t,
    ) -> *mut switch_core_session_t;
}
extern "C" {
    #[doc = "\\defgroup sessm Session Creation / Management\n\\ingroup core1\n\\{\n*!\n\\brief Allocate and return a new session from the core\n\\param endpoint_interface the endpoint interface the session is to be based on\n\\param pool the pool to use for the allocation (a new one will be used if NULL)\n\\return the newly created session\n*/"]
    pub fn switch_core_session_request_uuid(
        endpoint_interface: *mut switch_endpoint_interface_t,
        direction: switch_call_direction_t,
        originate_flags: switch_originate_flag_t,
        pool: *mut *mut switch_memory_pool_t,
        use_uuid: *const ::std::os::raw::c_char,
    ) -> *mut switch_core_session_t;
}
extern "C" {
    pub fn switch_core_session_set_uuid(
        session: *mut switch_core_session_t,
        use_uuid: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_set_external_id(
        session: *mut switch_core_session_t,
        use_external_id: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_perform_destroy(
        session: *mut *mut switch_core_session_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn switch_core_session_destroy_state(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_session_reporting_state(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_session_hangup_state(
        session: *mut switch_core_session_t,
        force: switch_bool_t,
    );
}
extern "C" {
    #[doc = "\\brief Provide the total number of sessions\n\\return the total number of allocated sessions"]
    pub fn switch_core_session_count() -> u32;
}
extern "C" {
    pub fn switch_core_session_get_id(session: *mut switch_core_session_t) -> switch_size_t;
}
extern "C" {
    #[doc = "\\brief Provide the current session_id\n\\return the total number of allocated sessions since core startup"]
    pub fn switch_core_session_id() -> switch_size_t;
}
extern "C" {
    pub fn switch_core_session_id_dec() -> switch_size_t;
}
extern "C" {
    #[doc = "\\brief Allocate and return a new session from the core based on a given endpoint module name\n\\param endpoint_name the name of the endpoint module\n\\param pool the pool to use\n\\return the newly created session"]
    pub fn switch_core_session_request_by_name(
        endpoint_name: *const ::std::os::raw::c_char,
        direction: switch_call_direction_t,
        pool: *mut *mut switch_memory_pool_t,
    ) -> *mut switch_core_session_t;
}
extern "C" {
    #[doc = "\\brief Launch the session thread (state machine) on a given session\n\\param session the session to activate the state machine on\n\\return SWITCH_STATUS_SUCCESS if the thread was launched"]
    pub fn switch_core_session_thread_launch(
        session: *mut switch_core_session_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_thread_pool_launch_thread(tdp: *mut *mut switch_thread_data_t)
        -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_thread_pool_launch(
        session: *mut switch_core_session_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_thread_pool_wait(
        td: *mut switch_thread_data_t,
        ms: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Retrieve a pointer to the channel object associated with a given session\n\\param session the session to retrieve from\n\\return a pointer to the channel object"]
    pub fn switch_core_session_get_channel(
        session: *mut switch_core_session_t,
    ) -> *mut switch_channel_t;
}
extern "C" {
    #[doc = "\\brief Signal a session's state machine thread that a state change has occured"]
    pub fn switch_core_session_get_mutex(
        session: *mut switch_core_session_t,
    ) -> *mut switch_mutex_t;
}
extern "C" {
    pub fn switch_core_session_wake_session_thread(
        session: *mut switch_core_session_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_signal_state_change(session: *mut switch_core_session_t);
}
extern "C" {
    #[doc = "\\brief Retrieve the unique identifier from a session\n\\param session the session to retrieve the uuid from\n\\return a string representing the uuid"]
    pub fn switch_core_session_get_uuid(
        session: *mut switch_core_session_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Retrieve the unique external identifier from a session\n\\param session the session to retrieve the uuid from\n\\return a string representing the uuid"]
    pub fn switch_core_session_get_external_id(
        session: *mut switch_core_session_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Sets the log level for a session\n\\param session the session to set the log level on\n\\return SWITCH_STATUS_SUCCESS"]
    pub fn switch_core_session_set_loglevel(
        session: *mut switch_core_session_t,
        loglevel: switch_log_level_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Get the log level for a session\n\\param session the session to get the log level from\n\\return the log level"]
    pub fn switch_core_session_get_loglevel(
        session: *mut switch_core_session_t,
    ) -> switch_log_level_t;
}
extern "C" {
    pub fn switch_core_session_get_jb(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
    ) -> *mut switch_jb_t;
}
extern "C" {
    pub fn switch_core_session_soft_lock(session: *mut switch_core_session_t, sec: u32);
}
extern "C" {
    pub fn switch_core_session_soft_unlock(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_session_set_dmachine(
        session: *mut switch_core_session_t,
        dmachine: *mut switch_ivr_dmachine_t,
        target: switch_digit_action_target_t,
    );
}
extern "C" {
    pub fn switch_core_session_get_dmachine(
        session: *mut switch_core_session_t,
        target: switch_digit_action_target_t,
    ) -> *mut switch_ivr_dmachine_t;
}
extern "C" {
    pub fn switch_ivr_dmachine_get_target(
        dmachine: *mut switch_ivr_dmachine_t,
    ) -> switch_digit_action_target_t;
}
extern "C" {
    pub fn switch_ivr_dmachine_set_target(
        dmachine: *mut switch_ivr_dmachine_t,
        target: switch_digit_action_target_t,
    );
}
extern "C" {
    pub fn switch_ivr_dmachine_set_terminators(
        dmachine: *mut switch_ivr_dmachine_t,
        terminators: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_set_codec_slin(
        session: *mut switch_core_session_t,
        data: *mut switch_slin_data_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_raw_read(session: *mut switch_core_session_t);
}
extern "C" {
    #[doc = "\\brief Retrieve the unique identifier from the core\n\\return a string representing the uuid"]
    pub fn switch_core_get_uuid() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_core_session_perform_locate(
        uuid_str: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut switch_core_session_t;
}
extern "C" {
    pub fn switch_core_session_perform_force_locate(
        uuid_str: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut switch_core_session_t;
}
extern "C" {
    #[doc = "\\brief Retrieve a global variable from the core\n\\param varname the name of the variable\n\\return the value of the desired variable"]
    pub fn switch_core_get_variable(
        varname: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_core_get_variable_dup(
        varname: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_core_get_variable_pdup(
        varname: *const ::std::os::raw::c_char,
        pool: *mut switch_memory_pool_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_core_get_hostname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_core_get_switchname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_core_get_domain(dup: switch_bool_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Add a global variable to the core\n\\param varname the name of the variable\n\\param value the value of the variable\n\\     If \\p value is NULL, then \\p varname is deleted."]
    pub fn switch_core_set_variable(
        varname: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn switch_core_get_variables(event: *mut *mut switch_event_t) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Conditionally add a global variable to the core\n\\param varname the name of the variable\n\\param value the value of the variable\n\\param val2 the value of the variable to verify against\n\\     If the global did not exist and val2==\"\", add global with value, return true\n\\     If the global exists with the value of val2, replace it, return true\n\\     If the global exists with a value other than val2, return false"]
    pub fn switch_core_set_var_conditional(
        varname: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        val2: *const ::std::os::raw::c_char,
    ) -> switch_bool_t;
}
extern "C" {
    pub fn switch_core_dump_variables(stream: *mut switch_stream_handle_t);
}
extern "C" {
    #[doc = "\\brief Hangup all sessions\n\\param cause the hangup cause to apply to the hungup channels"]
    pub fn switch_core_session_hupall(cause: switch_call_cause_t);
}
pub const switch_hup_type_t_SHT_NONE: switch_hup_type_t = 0;
pub const switch_hup_type_t_SHT_UNANSWERED: switch_hup_type_t = 1;
pub const switch_hup_type_t_SHT_ANSWERED: switch_hup_type_t = 2;
pub type switch_hup_type_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = "\\brief Hangup all sessions which match a specific channel variable\n\\param var_name The variable name to look for\n\\param var_val The value to look for\n\\param cause the hangup cause to apply to the hungup channels"]
    pub fn switch_core_session_hupall_matching_var_ans(
        var_name: *const ::std::os::raw::c_char,
        var_val: *const ::std::os::raw::c_char,
        cause: switch_call_cause_t,
        type_: switch_hup_type_t,
    ) -> u32;
}
extern "C" {
    pub fn switch_core_session_findall_matching_var(
        var_name: *const ::std::os::raw::c_char,
        var_val: *const ::std::os::raw::c_char,
    ) -> *mut switch_console_callback_match_t;
}
extern "C" {
    pub fn switch_core_session_findall() -> *mut switch_console_callback_match_t;
}
extern "C" {
    #[doc = "\\brief Hangup all sessions which match specific channel variable(s)\n\\param var_name The variable name to look for\n\\param var_val The value to look for\n\\param cause the hangup cause to apply to the hungup channels"]
    pub fn switch_core_session_hupall_matching_vars_ans(
        vars: *mut switch_event_t,
        cause: switch_call_cause_t,
        type_: switch_hup_type_t,
    ) -> u32;
}
extern "C" {
    #[doc = "\\brief Hangup all sessions that belong to an endpoint\n\\param endpoint_interface The endpoint interface\n\\param cause the hangup cause to apply to the hungup channels"]
    pub fn switch_core_session_hupall_endpoint(
        endpoint_interface: *const switch_endpoint_interface_t,
        cause: switch_call_cause_t,
    );
}
extern "C" {
    #[doc = "\\brief Get the session's partner (the session its bridged to)\n\\param session The session we're searching with\n\\param partner [out] The session's partner, or NULL if it wasnt found\n\\return SWITCH_STATUS_SUCCESS or SWITCH_STATUS_FALSE if this session isn't bridged"]
    pub fn switch_core_session_perform_get_partner(
        session: *mut switch_core_session_t,
        partner: *mut *mut switch_core_session_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Send a message to another session using it's uuid\n\\param uuid_str the unique id of the session you want to send a message to\n\\param message the switch_core_session_message_t object to send\n\\return the status returned by the message handler"]
    pub fn switch_core_session_message_send(
        uuid_str: *const ::std::os::raw::c_char,
        message: *mut switch_core_session_message_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Queue a message on a session\n\\param session the session to queue the message to\n\\param message the message to queue\n\\return SWITCH_STATUS_SUCCESS if the message was queued"]
    pub fn switch_core_session_queue_message(
        session: *mut switch_core_session_t,
        message: *mut switch_core_session_message_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_free_message(message: *mut *mut switch_core_session_message_t);
}
extern "C" {
    pub fn switch_core_session_queue_signal_data(
        session: *mut switch_core_session_t,
        signal_data: *mut ::std::os::raw::c_void,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_dequeue_signal_data(
        session: *mut switch_core_session_t,
        signal_data: *mut *mut ::std::os::raw::c_void,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief pass an indication message on a session\n\\param session the session to pass the message across\n\\param indication the indication message to pass\n\\return SWITCH_STATUS_SUCCESS if the message was passed"]
    pub fn switch_core_session_pass_indication(
        session: *mut switch_core_session_t,
        indication: switch_core_session_message_types_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Queue an indication message on a session\n\\param session the session to queue the message to\n\\param indication the indication message to queue\n\\return SWITCH_STATUS_SUCCESS if the message was queued"]
    pub fn switch_core_session_queue_indication(
        session: *mut switch_core_session_t,
        indication: switch_core_session_message_types_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief DE-Queue an message on a given session\n\\param session the session to de-queue the message on\n\\param message the de-queued message\n\\return SWITCH_STATUS_SUCCESS if the message was de-queued"]
    pub fn switch_core_session_dequeue_message(
        session: *mut switch_core_session_t,
        message: *mut *mut switch_core_session_message_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Flush a message queue on a given session\n\\param session the session to de-queue the message on\n\\return SWITCH_STATUS_SUCCESS if the message was de-queued"]
    pub fn switch_core_session_flush_message(
        session: *mut switch_core_session_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Queue an event on another session using its uuid\n\\param uuid_str the unique id of the session you want to send a message to\n\\param event the event to send\n\\return the status returned by the message handler"]
    pub fn switch_core_session_event_send(
        uuid_str: *const ::std::os::raw::c_char,
        event: *mut *mut switch_event_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_get_app_log(
        session: *mut switch_core_session_t,
    ) -> *mut switch_app_log_t;
}
extern "C" {
    #[doc = "\\brief Execute an application on a session\n\\param session the current session\n\\param application_interface the interface of the application to execute\n\\param arg application arguments\n\\warning Has to be called from the session's thread\n\\return the application's return value"]
    pub fn switch_core_session_exec(
        session: *mut switch_core_session_t,
        application_interface: *const switch_application_interface_t,
        arg: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_video_reset(session: *mut switch_core_session_t);
}
extern "C" {
    #[doc = "\\brief Execute an application on a session\n\\param session the current session\n\\param app the application's name\n\\param arg application arguments\n\\param flags pointer to a flags variable to set the applications flags to\n\\return the application's return value"]
    pub fn switch_core_session_execute_application_get_flags(
        session: *mut switch_core_session_t,
        app: *const ::std::os::raw::c_char,
        arg: *const ::std::os::raw::c_char,
        flags: *mut i32,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_execute_application_async(
        session: *mut switch_core_session_t,
        app: *const ::std::os::raw::c_char,
        arg: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_get_app_flags(
        app: *const ::std::os::raw::c_char,
        flags: *mut i32,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_stack_count(
        session: *mut switch_core_session_t,
        x: ::std::os::raw::c_int,
    ) -> u32;
}
extern "C" {
    #[doc = "\\brief Run a dialplan and execute an extension\n\\param session the current session\n\\param exten the interface of the application to execute\n\\param arg application arguments\n\\note It does not change the channel back to CS_ROUTING, it manually calls the dialplan and executes the applications\n\\warning Has to be called from the session's thread\n\\return the application's return value"]
    pub fn switch_core_session_execute_exten(
        session: *mut switch_core_session_t,
        exten: *const ::std::os::raw::c_char,
        dialplan: *const ::std::os::raw::c_char,
        context: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Send an event to a session translating it to it's native message format\n\\param session the session to receive the event\n\\param event the event to receive\n\\return the status returned by the handler"]
    pub fn switch_core_session_receive_event(
        session: *mut switch_core_session_t,
        event: *mut *mut switch_event_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Retrieve private user data from a session\n\\param session the session to retrieve from\n\\return a pointer to the private data"]
    pub fn switch_core_session_get_private_class(
        session: *mut switch_core_session_t,
        index: switch_pvt_class_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "\\brief Add private user data to a session\n\\param session the session to add used data to\n\\param private_info the used data to add\n\\return SWITCH_STATUS_SUCCESS if data is added"]
    pub fn switch_core_session_set_private_class(
        session: *mut switch_core_session_t,
        private_info: *mut ::std::os::raw::c_void,
        index: switch_pvt_class_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Add a logical stream to a session\n\\param session the session to add the stream to\n\\param private_info an optional pointer to private data for the new stream\n\\return the stream id of the new stream"]
    pub fn switch_core_session_add_stream(
        session: *mut switch_core_session_t,
        private_info: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Retreive a logical stream from a session\n\\param session the session to add the stream to\n\\param index the index to retrieve\n\\return the stream"]
    pub fn switch_core_session_get_stream(
        session: *mut switch_core_session_t,
        index: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "\\brief Determine the number of logical streams a session has\n\\param session the session to query\n\\return the total number of logical streams"]
    pub fn switch_core_session_get_stream_count(
        session: *mut switch_core_session_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_core_session_get_text_buffer(
        session: *mut switch_core_session_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Launch a thread designed to exist within the scope of a given session\n\\param session a session to allocate the thread from\n\\param func a function to execute in the thread\n\\param obj an arguement"]
    pub fn switch_core_session_launch_thread(
        session: *mut switch_core_session_t,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut switch_thread_t,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        obj: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "\\brief Signal a thread using a thread session to terminate\n\\param session the session to indicate to"]
    pub fn switch_core_thread_session_end(session: *mut switch_core_session_t);
}
extern "C" {
    #[doc = "\\brief Launch a service thread on a session to drop inbound data\n\\param session the session the launch thread on"]
    pub fn switch_core_service_session_av(
        session: *mut switch_core_session_t,
        audio: switch_bool_t,
        video: switch_bool_t,
    );
}
extern "C" {
    #[doc = "\\brief Request an outgoing session spawned from an existing session using a desired endpoing module\n\\param session the originating session\n\\param var_event switch_event_t containing paramaters\n\\param endpoint_name the name of the module to use for the new session\n\\param caller_profile the originator's caller profile\n\\param new_session a NULL pointer to aim at the newly created session\n\\param pool optional existing memory pool to donate to the session\n\\param flags flags to use\n\\return the cause code of the attempted call"]
    pub fn switch_core_session_outgoing_channel(
        session: *mut switch_core_session_t,
        var_event: *mut switch_event_t,
        endpoint_name: *const ::std::os::raw::c_char,
        caller_profile: *mut switch_caller_profile_t,
        new_session: *mut *mut switch_core_session_t,
        pool: *mut *mut switch_memory_pool_t,
        flags: switch_originate_flag_t,
        cancel_cause: *mut switch_call_cause_t,
    ) -> switch_call_cause_t;
}
extern "C" {
    #[doc = "\\brief Receive a message on a given session\n\\param session the session to receive the message from\n\\param message the message to recieve\n\\return the status returned by the message handler"]
    pub fn switch_core_session_perform_receive_message(
        session: *mut switch_core_session_t,
        message: *mut switch_core_session_message_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Queue an event on a given session\n\\param session the session to queue the message on\n\\param event the event to queue\n\\return the status returned by the message handler"]
    pub fn switch_core_session_queue_event(
        session: *mut switch_core_session_t,
        event: *mut *mut switch_event_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Indicate the number of waiting events on a session\n\\param session the session to check\n\\return the number of events"]
    pub fn switch_core_session_event_count(session: *mut switch_core_session_t) -> u32;
}
extern "C" {
    pub fn switch_core_session_messages_waiting(session: *mut switch_core_session_t) -> u32;
}
extern "C" {
    #[doc = "\\brief DE-Queue an event on a given session\n\\param session the session to de-queue the message on\n\\param event the de-queued event\n\\param force force the dequeue\n\\return the  SWITCH_STATUS_SUCCESS if the event was de-queued"]
    pub fn switch_core_session_dequeue_event(
        session: *mut switch_core_session_t,
        event: *mut *mut switch_event_t,
        force: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Queue a private event on a given session\n\\param session the session to queue the message on\n\\param event the event to queue\n\\param priority event has high priority\n\\return the status returned by the message handler"]
    pub fn switch_core_session_queue_private_event(
        session: *mut switch_core_session_t,
        event: *mut *mut switch_event_t,
        priority: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Indicate the number of waiting private events on a session\n\\param session the session to check\n\\return the number of events"]
    pub fn switch_core_session_private_event_count(session: *mut switch_core_session_t) -> u32;
}
extern "C" {
    #[doc = "\\brief DE-Queue a private event on a given session\n\\param session the session to de-queue the message on\n\\param event the de-queued event\n\\return the  SWITCH_STATUS_SUCCESS if the event was de-queued"]
    pub fn switch_core_session_dequeue_private_event(
        session: *mut switch_core_session_t,
        event: *mut *mut switch_event_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Flush the private event queue of a session\n\\param session the session to flush\n\\return SWITCH_STATUS_SUCCESS if the events have been flushed"]
    pub fn switch_core_session_flush_private_events(session: *mut switch_core_session_t) -> u32;
}
extern "C" {
    #[doc = "\\brief Read a frame from a session\n\\param session the session to read from\n\\param frame a NULL pointer to a frame to aim at the newly read frame\n\\param flags I/O flags to modify behavior (i.e. non blocking)\n\\param stream_id which logical media channel to use\n\\return SWITCH_STATUS_SUCCESS a the frame was read"]
    pub fn switch_core_session_read_frame(
        session: *mut switch_core_session_t,
        frame: *mut *mut switch_frame_t,
        flags: switch_io_flag_t,
        stream_id: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_transcoding(
        session_a: *mut switch_core_session_t,
        session_b: *mut switch_core_session_t,
        type_: switch_media_type_t,
    ) -> switch_bool_t;
}
extern "C" {
    pub fn switch_core_session_passthru(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
        on: switch_bool_t,
    );
}
extern "C" {
    #[doc = "\\brief Read a video frame from a session\n\\param session the session to read from\n\\param frame a NULL pointer to a frame to aim at the newly read frame\n\\param flags I/O flags to modify behavior (i.e. non blocking)\n\\param stream_id which logical media channel to use\n\\return SWITCH_STATUS_SUCCESS a if the frame was read"]
    pub fn switch_core_session_read_video_frame(
        session: *mut switch_core_session_t,
        frame: *mut *mut switch_frame_t,
        flags: switch_io_flag_t,
        stream_id: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Write a video frame to a session\n\\param session the session to write to\n\\param frame a pointer to a frame to write\n\\param flags I/O flags to modify behavior (i.e. non blocking)\n\\param stream_id which logical media channel to use\n\\return SWITCH_STATUS_SUCCESS a if the frame was written"]
    pub fn switch_core_session_write_video_frame(
        session: *mut switch_core_session_t,
        frame: *mut switch_frame_t,
        flags: switch_io_flag_t,
        stream_id: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_write_encoded_video_frame(
        session: *mut switch_core_session_t,
        frame: *mut switch_frame_t,
        flags: switch_io_flag_t,
        stream_id: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_set_read_impl(
        session: *mut switch_core_session_t,
        impp: *const switch_codec_implementation_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_set_write_impl(
        session: *mut switch_core_session_t,
        impp: *const switch_codec_implementation_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_set_video_read_impl(
        session: *mut switch_core_session_t,
        impp: *const switch_codec_implementation_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_set_video_write_impl(
        session: *mut switch_core_session_t,
        impp: *const switch_codec_implementation_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Reset the buffers and resampler on a session\n\\param session the session to reset\n\\param flush_dtmf flush all queued dtmf events too"]
    pub fn switch_core_session_reset(
        session: *mut switch_core_session_t,
        flush_dtmf: switch_bool_t,
        reset_read_codec: switch_bool_t,
    );
}
extern "C" {
    #[doc = "\\brief Reset the buffers and resampler on a session, fail if can not lock codec mutexes\n\\param session the session to reset\n\\param flush_dtmf flush all queued dtmf events too\n\\return SWITCH_STATUS_SUCCESS if the session was reset"]
    pub fn switch_core_session_try_reset(
        session: *mut switch_core_session_t,
        flush_dtmf: switch_bool_t,
        reset_read_codec: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Write a frame to a session\n\\param session the session to write to\n\\param frame the frame to write\n\\param flags I/O flags to modify behavior (i.e. non blocking)\n\\param stream_id which logical media channel to use\n\\return SWITCH_STATUS_SUCCESS a the frame was written"]
    pub fn switch_core_session_write_frame(
        session: *mut switch_core_session_t,
        frame: *mut switch_frame_t,
        flags: switch_io_flag_t,
        stream_id: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_perform_kill_channel(
        session: *mut switch_core_session_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        sig: switch_signal_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Send DTMF to a session\n\\param session session to send DTMF to\n\\param dtmf dtmf to send to the session\n\\return SWITCH_STATUS_SUCCESS if the dtmf was written"]
    pub fn switch_core_session_send_dtmf(
        session: *mut switch_core_session_t,
        dtmf: *const switch_dtmf_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Send DTMF to a session\n\\param session session to send DTMF to\n\\param dtmf_string string to send to the session\n\\return SWITCH_STATUS_SUCCESS if the dtmf was written"]
    pub fn switch_core_session_send_dtmf_string(
        session: *mut switch_core_session_t,
        dtmf_string: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief RECV DTMF on a session\n\\param session session to recv DTMF from\n\\param dtmf string to recv from the session\n\\return SWITCH_STATUS_SUCCESS if the dtmf is ok to queue"]
    pub fn switch_core_session_recv_dtmf(
        session: *mut switch_core_session_t,
        dtmf: *const switch_dtmf_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\defgroup hashf Hash Functions\n\\ingroup core1\n\\{\n*!\n\\brief Initialize a hash table\n\\param hash a NULL pointer to a hash table to aim at the new hash\n\\param pool the pool to use for the new hash\n\\return SWITCH_STATUS_SUCCESS if the hash is created\n*/"]
    pub fn switch_core_hash_init_case(
        hash: *mut *mut switch_hash_t,
        case_sensitive: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Destroy an existing hash table\n\\param hash the hash to destroy\n\\return SWITCH_STATUS_SUCCESS if the hash is destroyed"]
    pub fn switch_core_hash_destroy(hash: *mut *mut switch_hash_t) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Insert data into a hash with an auto-generated key based on the data pointer\n\\param hash the hash to add data to\n\\param data unique pointer to add\n\\return SWITCH_STATUS_SUCCESS if the data is added"]
    pub fn switch_core_hash_insert_pointer(
        hash: *mut switch_hash_t,
        data: *const ::std::os::raw::c_void,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Insert data into a hash and set flags so the value is automatically freed on delete\n\\param hash the hash to add data to\n\\param key the name of the key to add the data to\n\\param data the data to add\n\\return SWITCH_STATUS_SUCCESS if the data is added\n\\note the string key must be a constant or a dynamic string"]
    pub fn switch_core_hash_insert_auto_free(
        hash: *mut switch_hash_t,
        key: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_void,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Insert strdup(str) into a hash and set flags so the value is automatically freed on delete\n\\param hash the hash to add str to\n\\param key the name of the key to add the str to\n\\param str string to strdup and add\n\\return SWITCH_STATUS_SUCCESS if the data is added\n\\note the string key must be a constant or a dynamic string"]
    pub fn switch_core_hash_insert_dup_auto_free(
        hash: *mut switch_hash_t,
        key: *const ::std::os::raw::c_char,
        str_: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Insert data into a hash\n\\param hash the hash to add data to\n\\param key the name of the key to add the data to\n\\param data the data to add\n\\return SWITCH_STATUS_SUCCESS if the data is added\n\\note the string key must be a constant or a dynamic string"]
    pub fn switch_core_hash_insert_destructor(
        hash: *mut switch_hash_t,
        key: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_void,
        destructor: hashtable_destructor_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Allocate memory and insert into a hash\n\\param hash the hash to add data to\n\\param key the name of the key to add the data to\n\\param size the size in bytes to allocate\n\\return pointer to the allocated memory\n\\note the string key must be a constant or a dynamic string"]
    pub fn switch_core_hash_insert_alloc_destructor(
        hash: *mut switch_hash_t,
        key: *const ::std::os::raw::c_char,
        size: usize,
        destructor: hashtable_destructor_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "\\brief Insert strdup(str) into a hash\n\\param hash the hash to add str to\n\\param key the name of the key to add the str to\n\\param str string to strdup and add\n\\return SWITCH_STATUS_SUCCESS if the data is added\n\\note the string key must be a constant or a dynamic string"]
    pub fn switch_core_hash_insert_dup_destructor(
        hash: *mut switch_hash_t,
        key: *const ::std::os::raw::c_char,
        str_: *const ::std::os::raw::c_char,
        destructor: hashtable_destructor_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Insert data into a hash\n\\param hash the hash to add data to\n\\param key the name of the key to add the data to\n\\param data the data to add\n\\param mutex optional mutex to lock\n\\return SWITCH_STATUS_SUCCESS if the data is added\n\\note the string key must be a constant or a dynamic string"]
    pub fn switch_core_hash_insert_locked(
        hash: *mut switch_hash_t,
        key: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_void,
        mutex: *mut switch_mutex_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Retrieve data from a given hash\n\\param hash the hash to retrieve from\n\\param key the key to retrieve\n\\param mutex optional rwlock to wrlock\n\\return a pointer to the data held in the key"]
    pub fn switch_core_hash_insert_wrlock(
        hash: *mut switch_hash_t,
        key: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_void,
        rwlock: *mut switch_thread_rwlock_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Delete data from a hash based on desired key\n\\param hash the hash to delete from\n\\param key the key from which to delete the data\n\\return The value stored if the data is deleted otherwise NULL"]
    pub fn switch_core_hash_delete(
        hash: *mut switch_hash_t,
        key: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "\\brief Delete data from a hash based on desired key\n\\param hash the hash to delete from\n\\param key the key from which to delete the data\n\\param mutex optional mutex to lock\n\\return a pointer to the deleted data"]
    pub fn switch_core_hash_delete_locked(
        hash: *mut switch_hash_t,
        key: *const ::std::os::raw::c_char,
        mutex: *mut switch_mutex_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "\\brief Delete data from a hash based on desired key\n\\param hash the hash to delete from\n\\param key the key from which to delete the data\n\\param mutex optional rwlock to wrlock\n\\return a pointer to the deleted data"]
    pub fn switch_core_hash_delete_wrlock(
        hash: *mut switch_hash_t,
        key: *const ::std::os::raw::c_char,
        rwlock: *mut switch_thread_rwlock_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "\\brief Delete data from a hash based on callback function\n\\param hash the hash to delete from\n\\param callback the function to call which returns SWITCH_TRUE to delete, SWITCH_FALSE to preserve\n\\return SWITCH_STATUS_SUCCESS if any data is deleted"]
    pub fn switch_core_hash_delete_multi(
        hash: *mut switch_hash_t,
        callback: switch_hash_delete_callback_t,
        pData: *mut ::std::os::raw::c_void,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Retrieve data from a given hash\n\\param hash the hash to retrieve from\n\\param key the key to retrieve\n\\return a pointer to the data held in the key"]
    pub fn switch_core_hash_find(
        hash: *mut switch_hash_t,
        key: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "\\brief Retrieve data from a given hash\n\\param hash the hash to retrieve from\n\\param key the key to retrieve\n\\param mutex optional mutex to lock\n\\return a pointer to the data held in the key"]
    pub fn switch_core_hash_find_locked(
        hash: *mut switch_hash_t,
        key: *const ::std::os::raw::c_char,
        mutex: *mut switch_mutex_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "\\brief Retrieve data from a given hash\n\\param hash the hash to retrieve from\n\\param key the key to retrieve\n\\param mutex optional rwlock to rdlock\n\\return a pointer to the data held in the key"]
    pub fn switch_core_hash_find_rdlock(
        hash: *mut switch_hash_t,
        key: *const ::std::os::raw::c_char,
        rwlock: *mut switch_thread_rwlock_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "\\brief Gets the first element of a hashtable\n\\param deprecate_me [deprecated] NULL\n\\param hash the hashtable to use\n\\return The element, or NULL if it wasn't found"]
    pub fn switch_core_hash_first_iter(
        hash: *mut switch_hash_t,
        hi: *mut switch_hash_index_t,
    ) -> *mut switch_hash_index_t;
}
extern "C" {
    #[doc = "\\brief tells if a hash is empty\n\\param hash the hashtable\n\\return TRUE or FALSE depending on if the hash is empty"]
    pub fn switch_core_hash_empty(hash: *mut switch_hash_t) -> switch_bool_t;
}
extern "C" {
    #[doc = "\\brief Gets the next element of a hashtable\n\\param hi The current element\n\\return The next element, or NULL if there are no more"]
    pub fn switch_core_hash_next(hi: *mut *mut switch_hash_index_t) -> *mut switch_hash_index_t;
}
extern "C" {
    #[doc = "\\brief Gets the key and value of the current hash element\n\\param hi The current element\n\\param key [out] the key\n\\param klen [out] the key's size\n\\param val [out] the value"]
    pub fn switch_core_hash_this(
        hi: *mut switch_hash_index_t,
        key: *mut *const ::std::os::raw::c_void,
        klen: *mut switch_ssize_t,
        val: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn switch_core_hash_this_val(
        hi: *mut switch_hash_index_t,
        val: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn switch_core_inthash_init(hash: *mut *mut switch_inthash_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_inthash_destroy(hash: *mut *mut switch_inthash_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_inthash_insert(
        hash: *mut switch_inthash_t,
        key: u32,
        data: *const ::std::os::raw::c_void,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_inthash_delete(
        hash: *mut switch_inthash_t,
        key: u32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn switch_core_inthash_find(
        hash: *mut switch_inthash_t,
        key: u32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "\\defgroup timer Timer Functions\n\\ingroup core1\n\\{\n*!\n\\brief Request a timer handle using given time module\n\\param timer a timer object to allocate to\n\\param timer_name the name of the timer module to use\n\\param interval desired interval\n\\param samples the number of samples to increment on each cycle\n\\param pool the memory pool to use for allocation\n\\return\n*/"]
    pub fn switch_core_timer_init(
        timer: *mut switch_timer_t,
        timer_name: *const ::std::os::raw::c_char,
        interval: ::std::os::raw::c_int,
        samples: ::std::os::raw::c_int,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_time_calibrate_clock();
}
extern "C" {
    #[doc = "\\brief Wait for one cycle on an existing timer\n\\param timer the timer to wait on\n\\return the newest sample count"]
    pub fn switch_core_timer_next(timer: *mut switch_timer_t) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Step the timer one step\n\\param timer the timer to wait on\n\\return the newest sample count"]
    pub fn switch_core_timer_step(timer: *mut switch_timer_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_timer_sync(timer: *mut switch_timer_t) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Check if the current step has been exceeded\n\\param timer the timer to wait on\n\\param step increment timer if a tick was detected\n\\return the newest sample count"]
    pub fn switch_core_timer_check(
        timer: *mut switch_timer_t,
        step: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Destroy an allocated timer\n\\param timer timer to destroy\n\\return SWITCH_STATUS_SUCCESS after destruction"]
    pub fn switch_core_timer_destroy(timer: *mut switch_timer_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_codec_init_with_bitrate(
        codec: *mut switch_codec_t,
        codec_name: *const ::std::os::raw::c_char,
        fmtp: *const ::std::os::raw::c_char,
        modname: *const ::std::os::raw::c_char,
        rate: u32,
        ms: ::std::os::raw::c_int,
        channels: ::std::os::raw::c_int,
        bitrate: u32,
        flags: u32,
        codec_settings: *const switch_codec_settings_t,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_codec_copy(
        codec: *mut switch_codec_t,
        new_codec: *mut switch_codec_t,
        codec_settings: *const switch_codec_settings_t,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_codec_parse_fmtp(
        codec_name: *const ::std::os::raw::c_char,
        fmtp: *const ::std::os::raw::c_char,
        rate: u32,
        codec_fmtp: *mut switch_codec_fmtp_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_codec_reset(codec: *mut switch_codec_t) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Encode data using a codec handle\n\\param codec the codec handle to use\n\\param other_codec the codec handle of the last codec used\n\\param decoded_data the raw data\n\\param decoded_data_len then length of the raw buffer\n\\param decoded_rate the rate of the decoded data\n\\param encoded_data the buffer to write the encoded data to\n\\param encoded_data_len the size of the encoded_data buffer\n\\param encoded_rate the new rate of the encoded data\n\\param flag flags to exchange\n\\return SWITCH_STATUS_SUCCESS if the data was encoded\n\\note encoded_data_len will be rewritten to the in-use size of encoded_data"]
    pub fn switch_core_codec_encode(
        codec: *mut switch_codec_t,
        other_codec: *mut switch_codec_t,
        decoded_data: *mut ::std::os::raw::c_void,
        decoded_data_len: u32,
        decoded_rate: u32,
        encoded_data: *mut ::std::os::raw::c_void,
        encoded_data_len: *mut u32,
        encoded_rate: *mut u32,
        flag: *mut ::std::os::raw::c_uint,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Decode data using a codec handle\n\\param codec the codec handle to use\n\\param other_codec the codec handle of the last codec used\n\\param encoded_data the buffer to read the encoded data from\n\\param encoded_data_len the size of the encoded_data buffer\n\\param encoded_rate the rate of the encoded data\n\\param decoded_data the raw data buffer\n\\param decoded_data_len then length of the raw buffer\n\\param decoded_rate the new rate of the decoded data\n\\param flag flags to exchange\n\\return SWITCH_STATUS_SUCCESS if the data was decoded\n\\note decoded_data_len will be rewritten to the in-use size of decoded_data"]
    pub fn switch_core_codec_decode(
        codec: *mut switch_codec_t,
        other_codec: *mut switch_codec_t,
        encoded_data: *mut ::std::os::raw::c_void,
        encoded_data_len: u32,
        encoded_rate: u32,
        decoded_data: *mut ::std::os::raw::c_void,
        decoded_data_len: *mut u32,
        decoded_rate: *mut u32,
        flag: *mut ::std::os::raw::c_uint,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Encode video data using a codec handle\n\\param codec the codec handle to use\n\\param frame the frame to encode"]
    pub fn switch_core_codec_encode_video(
        codec: *mut switch_codec_t,
        frame: *mut switch_frame_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief send control data using a codec handle\n\\param codec the codec handle to use\n\\param cmd the command to send\n\\param ctype the type of the arguement\n\\param cmd_data a void pointer to the data matching the passed type\n\\param atype the type of the extra arguement\n\\param cmd_arg a void pointer to the data matching the passed type\n\\param rtype the type of the response if any\n\\param ret_data a void pointer to a pointer of return data\n\\return SWITCH_STATUS_SUCCESS if the command was received"]
    pub fn switch_core_codec_control(
        codec: *mut switch_codec_t,
        cmd: switch_codec_control_command_t,
        ctype: switch_codec_control_type_t,
        cmd_data: *mut ::std::os::raw::c_void,
        atype: switch_codec_control_type_t,
        cmd_arg: *mut ::std::os::raw::c_void,
        rtype: *mut switch_codec_control_type_t,
        ret_data: *mut *mut ::std::os::raw::c_void,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Decode video data using a codec handle\n\\param codec the codec handle to use\n\\param frame the frame to be decoded\n\\param img the new image in I420 format, allocated by the codec\n\\param flag flags to exchange\n\\return SWITCH_STATUS_SUCCESS if the data was decoded, and a non-NULL img"]
    pub fn switch_core_codec_decode_video(
        codec: *mut switch_codec_t,
        frame: *mut switch_frame_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Destroy an initalized codec handle\n\\param codec the codec handle to destroy\n\\return SWITCH_STATUS_SUCCESS if the codec was destroyed"]
    pub fn switch_core_codec_destroy(codec: *mut switch_codec_t) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Assign the read codec to a given session\n\\param session session to add the codec to\n\\param codec the codec to add\n\\return SWITCH_STATUS_SUCCESS if successful"]
    pub fn switch_core_session_set_read_codec(
        session: *mut switch_core_session_t,
        codec: *mut switch_codec_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Assign the original read codec to a given session.  This is the read codec used by an endpoint.\n\\param session session to add the codec to\n\\param codec the codec to add\n\\return SWITCH_STATUS_SUCCESS if successful"]
    pub fn switch_core_session_set_real_read_codec(
        session: *mut switch_core_session_t,
        codec: *mut switch_codec_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_unset_read_codec(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_session_unset_write_codec(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_session_lock_codec_write(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_session_unlock_codec_write(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_session_lock_codec_read(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_session_unlock_codec_read(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_session_get_read_impl(
        session: *mut switch_core_session_t,
        impp: *mut switch_codec_implementation_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_get_real_read_impl(
        session: *mut switch_core_session_t,
        impp: *mut switch_codec_implementation_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_get_write_impl(
        session: *mut switch_core_session_t,
        impp: *mut switch_codec_implementation_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_get_video_read_impl(
        session: *mut switch_core_session_t,
        impp: *mut switch_codec_implementation_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_get_video_write_impl(
        session: *mut switch_core_session_t,
        impp: *mut switch_codec_implementation_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Retrieve the read codec from a given session\n\\param session session to retrieve from\n\\return a pointer to the codec"]
    pub fn switch_core_session_get_read_codec(
        session: *mut switch_core_session_t,
    ) -> *mut switch_codec_t;
}
extern "C" {
    #[doc = "\\brief Retrieve the effevtive read codec from a given session\n\\param session session to retrieve from\n\\return a pointer to the codec"]
    pub fn switch_core_session_get_effective_read_codec(
        session: *mut switch_core_session_t,
    ) -> *mut switch_codec_t;
}
extern "C" {
    #[doc = "\\brief Assign the write codec to a given session\n\\param session session to add the codec to\n\\param codec the codec to add\n\\return SWITCH_STATUS_SUCCESS if successful"]
    pub fn switch_core_session_set_write_codec(
        session: *mut switch_core_session_t,
        codec: *mut switch_codec_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Retrieve the write codec from a given session\n\\param session session to retrieve from\n\\return a pointer to the codec"]
    pub fn switch_core_session_get_write_codec(
        session: *mut switch_core_session_t,
    ) -> *mut switch_codec_t;
}
extern "C" {
    #[doc = "\\brief Retrieve the effevtive write codec from a given session\n\\param session session to retrieve from\n\\return a pointer to the codec"]
    pub fn switch_core_session_get_effective_write_codec(
        session: *mut switch_core_session_t,
    ) -> *mut switch_codec_t;
}
extern "C" {
    #[doc = "\\brief Assign the video_read codec to a given session\n\\param session session to add the codec to\n\\param codec the codec to add\n\\return SWITCH_STATUS_SUCCESS if successful"]
    pub fn switch_core_session_set_video_read_codec(
        session: *mut switch_core_session_t,
        codec: *mut switch_codec_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Retrieve the video_read codec from a given session\n\\param session session to retrieve from\n\\return a pointer to the codec"]
    pub fn switch_core_session_get_video_read_codec(
        session: *mut switch_core_session_t,
    ) -> *mut switch_codec_t;
}
extern "C" {
    #[doc = "\\brief Assign the video_write codec to a given session\n\\param session session to add the codec to\n\\param codec the codec to add\n\\return SWITCH_STATUS_SUCCESS if successful"]
    pub fn switch_core_session_set_video_write_codec(
        session: *mut switch_core_session_t,
        codec: *mut switch_codec_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Retrieve the video_write codec from a given session\n\\param session session to retrieve from\n\\return a pointer to the codec"]
    pub fn switch_core_session_get_video_write_codec(
        session: *mut switch_core_session_t,
    ) -> *mut switch_codec_t;
}
extern "C" {
    #[doc = "\\}\n\\defgroup db Database Functions\n\\ingroup core1\n\\{\n*!\n\\brief Open a core db (SQLite) file\n\\param filename the path to the db file to open\n\\return the db handle\n*/"]
    pub fn switch_core_db_open_file(
        filename: *const ::std::os::raw::c_char,
    ) -> *mut switch_core_db_t;
}
extern "C" {
    #[doc = "\\brief Open a core db (SQLite) in-memory\n\\param uri to the db to open\n\\return the db handle"]
    pub fn switch_core_db_open_in_memory(
        uri: *const ::std::os::raw::c_char,
    ) -> *mut switch_core_db_t;
}
extern "C" {
    #[doc = "\\brief Execute a sql stmt until it is accepted\n\\param db the db handle\n\\param sql the sql to execute\n\\param retries the number of retries to use\n\\return SWITCH_STATUS_SUCCESS if successful"]
    pub fn switch_core_db_persistant_execute(
        db: *mut switch_core_db_t,
        sql: *mut ::std::os::raw::c_char,
        retries: u32,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_db_persistant_execute_trans(
        db: *mut switch_core_db_t,
        sql: *mut ::std::os::raw::c_char,
        retries: u32,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief perform a test query then perform a reactive query if the first one fails\n\\param db the db handle\n\\param test_sql the test sql\n\\param drop_sql the drop sql\n\\param reactive_sql the reactive sql"]
    pub fn switch_core_db_test_reactive(
        db: *mut switch_core_db_t,
        test_sql: *mut ::std::os::raw::c_char,
        drop_sql: *mut ::std::os::raw::c_char,
        reactive_sql: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "\\defgroup Media File Functions\n\\ingroup core1\n\\{"]
    pub fn switch_core_perform_file_open(
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        fh: *mut switch_file_handle_t,
        file_path: *const ::std::os::raw::c_char,
        channels: u32,
        rate: u32,
        flags: ::std::os::raw::c_uint,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Read media from a file handle\n\\param fh the file handle to read from (must be initilized by you memset all 0 for read, fill in channels and rate for write)\n\\param data the buffer to read the data to\n\\param len the max size of the buffer\n\\return SWITCH_STATUS_SUCCESS with len adjusted to the bytes read if successful"]
    pub fn switch_core_file_read(
        fh: *mut switch_file_handle_t,
        data: *mut ::std::os::raw::c_void,
        len: *mut switch_size_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Write media to a file handle\n\\param fh the file handle to write to\n\\param data the buffer to write\n\\param len the amount of data to write from the buffer\n\\return SWITCH_STATUS_SUCCESS with len adjusted to the bytes written if successful"]
    pub fn switch_core_file_write(
        fh: *mut switch_file_handle_t,
        data: *mut ::std::os::raw::c_void,
        len: *mut switch_size_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Write media to a file handle\n\\param fh the file handle to write to\n\\param data the buffer to write\n\\param len the amount of data to write from the buffer\n\\return SWITCH_STATUS_SUCCESS with len adjusted to the bytes written if successful"]
    pub fn switch_core_file_write_video(
        fh: *mut switch_file_handle_t,
        frame: *mut switch_frame_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_file_read_video(
        fh: *mut switch_file_handle_t,
        frame: *mut switch_frame_t,
        flags: switch_video_read_flag_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Seek a position in a file\n\\param fh the file handle to seek\n\\param cur_pos the current position in the file\n\\param samples the amount of samples to seek from the beginning of the file\n\\param whence the indicator (see traditional seek)\n\\return SWITCH_STATUS_SUCCESS with cur_pos adjusted to new position"]
    pub fn switch_core_file_seek(
        fh: *mut switch_file_handle_t,
        cur_pos: *mut ::std::os::raw::c_uint,
        samples: i64,
        whence: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Set metadata to the desired string\n\\param fh the file handle to set data to\n\\param col the enum of the col name\n\\param string the string to add\n\\return SWITCH_STATUS_SUCCESS with cur_pos adjusted to new position"]
    pub fn switch_core_file_set_string(
        fh: *mut switch_file_handle_t,
        col: switch_audio_col_t,
        string: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief get metadata of the desired string\n\\param fh the file handle to get data from\n\\param col the enum of the col name\n\\param string pointer to the string to fetch\n\\return SWITCH_STATUS_SUCCESS with cur_pos adjusted to new position"]
    pub fn switch_core_file_get_string(
        fh: *mut switch_file_handle_t,
        col: switch_audio_col_t,
        string: *mut *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Pre close an open file handle, then can get file size etc., no more wirte to the file\n\\param fh the file handle to close\n\\return SWITCH_STATUS_SUCCESS if the file handle was pre closed"]
    pub fn switch_core_file_pre_close(fh: *mut switch_file_handle_t) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Duplicates a file handle using another pool\n\\param oldfh the file handle to duplicate\n\\param newfh pointer to assign new file handle to\n\\param pool the pool to use (NULL for new pool)\n\\return SWITCH_STATUS_SUCCESS if the file handle was duplicated"]
    pub fn switch_core_file_handle_dup(
        oldfh: *mut switch_file_handle_t,
        newfh: *mut *mut switch_file_handle_t,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Close an open file handle\n\\param fh the file handle to close\n\\return SWITCH_STATUS_SUCCESS if the file handle was closed"]
    pub fn switch_core_file_close(fh: *mut switch_file_handle_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_file_command(
        fh: *mut switch_file_handle_t,
        command: switch_file_command_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_file_truncate(fh: *mut switch_file_handle_t, offset: i64)
        -> switch_status_t;
}
extern "C" {
    pub fn switch_core_file_has_video(
        fh: *mut switch_file_handle_t,
        CHECK_OPEN: switch_bool_t,
    ) -> switch_bool_t;
}
extern "C" {
    #[doc = "\\defgroup speech ASR/TTS Functions\n\\ingroup core1\n\\{\n*!\n\\brief Open a speech handle\n\\param sh a speech handle to use\n\\param module_name the speech module to use\n\\param voice_name the desired voice name\n\\param rate the sampling rate\n\\param interval the sampling interval\n\\param flags tts flags\n\\param pool the pool to use (NULL for new pool)\n\\return SWITCH_STATUS_SUCCESS if the handle is opened\n*/"]
    pub fn switch_core_speech_open(
        sh: *mut switch_speech_handle_t,
        module_name: *const ::std::os::raw::c_char,
        voice_name: *const ::std::os::raw::c_char,
        rate: ::std::os::raw::c_uint,
        interval: ::std::os::raw::c_uint,
        channels: ::std::os::raw::c_uint,
        flags: *mut switch_speech_flag_t,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Feed text to the TTS module\n\\param sh the speech handle to feed\n\\param text the buffer to write\n\\param flags flags in/out for fine tuning\n\\return SWITCH_STATUS_SUCCESS with len adjusted to the bytes written if successful"]
    pub fn switch_core_speech_feed_tts(
        sh: *mut switch_speech_handle_t,
        text: *const ::std::os::raw::c_char,
        flags: *mut switch_speech_flag_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Flush TTS audio on a given handle\n\\param sh the speech handle"]
    pub fn switch_core_speech_flush_tts(sh: *mut switch_speech_handle_t);
}
extern "C" {
    #[doc = "\\brief Set a text parameter on a TTS handle\n\\param sh the speech handle\n\\param param the parameter\n\\param val the value"]
    pub fn switch_core_speech_text_param_tts(
        sh: *mut switch_speech_handle_t,
        param: *mut ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "\\brief Set a numeric parameter on a TTS handle\n\\param sh the speech handle\n\\param param the parameter\n\\param val the value"]
    pub fn switch_core_speech_numeric_param_tts(
        sh: *mut switch_speech_handle_t,
        param: *mut ::std::os::raw::c_char,
        val: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "\\brief Set a float parameter on a TTS handle\n\\param sh the speech handle\n\\param param the parameter\n\\param val the value"]
    pub fn switch_core_speech_float_param_tts(
        sh: *mut switch_speech_handle_t,
        param: *mut ::std::os::raw::c_char,
        val: f64,
    );
}
extern "C" {
    #[doc = "\\brief Read rendered audio from the TTS module\n\\param sh the speech handle to read\n\\param data the buffer to read to\n\\param datalen the max size / written size of the data\n\\param rate the rate of the read audio\n\\param flags flags in/out for fine tuning\n\\return SWITCH_STATUS_SUCCESS with len adjusted to the bytes written if successful"]
    pub fn switch_core_speech_read_tts(
        sh: *mut switch_speech_handle_t,
        data: *mut ::std::os::raw::c_void,
        datalen: *mut switch_size_t,
        flags: *mut switch_speech_flag_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Close an open speech handle\n\\param sh the speech handle to close\n\\param flags flags in/out for fine tuning\n\\return SWITCH_STATUS_SUCCESS if the file handle was closed"]
    pub fn switch_core_speech_close(
        sh: *mut switch_speech_handle_t,
        flags: *mut switch_speech_flag_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Open an asr handle\n\\param ah the asr handle to open\n\\param module_name the name of the asr module\n\\param codec the preferred codec\n\\param rate the preferred rate\n\\param dest the destination address\n\\param flags flags to influence behaviour\n\\param pool the pool to use (NULL for new pool)\n\\return SWITCH_STATUS_SUCCESS if the asr handle was opened"]
    pub fn switch_core_asr_open(
        ah: *mut switch_asr_handle_t,
        module_name: *const ::std::os::raw::c_char,
        codec: *const ::std::os::raw::c_char,
        rate: ::std::os::raw::c_int,
        dest: *const ::std::os::raw::c_char,
        flags: *mut switch_asr_flag_t,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Close an asr handle\n\\param ah the handle to close\n\\param flags flags to influence behaviour\n\\return SWITCH_STATUS_SUCCESS"]
    pub fn switch_core_asr_close(
        ah: *mut switch_asr_handle_t,
        flags: *mut switch_asr_flag_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Feed audio data to an asr handle\n\\param ah the handle to feed data to\n\\param data a pointer to the data\n\\param len the size in bytes of the data\n\\param flags flags to influence behaviour\n\\return SWITCH_STATUS_SUCCESS"]
    pub fn switch_core_asr_feed(
        ah: *mut switch_asr_handle_t,
        data: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_uint,
        flags: *mut switch_asr_flag_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Feed DTMF to an asr handle\n\\param ah the handle to feed data to\n\\param dtmf a string of DTMF digits\n\\param flags flags to influence behaviour\n\\return SWITCH_STATUS_SUCCESS"]
    pub fn switch_core_asr_feed_dtmf(
        ah: *mut switch_asr_handle_t,
        dtmf: *const switch_dtmf_t,
        flags: *mut switch_asr_flag_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Check an asr handle for results\n\\param ah the handle to check\n\\param flags flags to influence behaviour\n\\return SWITCH_STATUS_SUCCESS"]
    pub fn switch_core_asr_check_results(
        ah: *mut switch_asr_handle_t,
        flags: *mut switch_asr_flag_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Get results from an asr handle\n\\param ah the handle to get results from\n\\param xmlstr a pointer to dynamically allocate an xml result string to\n\\param flags flags to influence behaviour\n\\return SWITCH_STATUS_SUCCESS"]
    pub fn switch_core_asr_get_results(
        ah: *mut switch_asr_handle_t,
        xmlstr: *mut *mut ::std::os::raw::c_char,
        flags: *mut switch_asr_flag_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Get result headers from an asr handle\n\\param ah the handle to get results from\n\\param headers a pointer to dynamically allocate an switch_event_t result to\n\\param flags flags to influence behaviour\n\\return SWITCH_STATUS_SUCCESS"]
    pub fn switch_core_asr_get_result_headers(
        ah: *mut switch_asr_handle_t,
        headers: *mut *mut switch_event_t,
        flags: *mut switch_asr_flag_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Load a grammar to an asr handle\n\\param ah the handle to load to\n\\param grammar the grammar text, file path, or URI\n\\param name the grammar name\n\\return SWITCH_STATUS_SUCCESS"]
    pub fn switch_core_asr_load_grammar(
        ah: *mut switch_asr_handle_t,
        grammar: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Unload a grammar from an asr handle\n\\param ah the handle to unload the grammar from\n\\param name the name of the grammar to unload\n\\return SWITCH_STATUS_SUCCESS"]
    pub fn switch_core_asr_unload_grammar(
        ah: *mut switch_asr_handle_t,
        name: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Enable a grammar from an asr handle\n\\param ah the handle to enable the grammar from\n\\param name the name of the grammar to enable\n\\return SWITCH_STATUS_SUCCESS"]
    pub fn switch_core_asr_enable_grammar(
        ah: *mut switch_asr_handle_t,
        name: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Disable a grammar from an asr handle\n\\param ah the handle to disable the grammar from\n\\param name the name of the grammar to disable\n\\return SWITCH_STATUS_SUCCESS"]
    pub fn switch_core_asr_disable_grammar(
        ah: *mut switch_asr_handle_t,
        name: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Disable all grammars from an asr handle\n\\param ah the handle to disable the grammars from\n\\return SWITCH_STATUS_SUCCESS"]
    pub fn switch_core_asr_disable_all_grammars(ah: *mut switch_asr_handle_t) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Pause detection on an asr handle\n\\param ah the handle to pause\n\\return SWITCH_STATUS_SUCCESS"]
    pub fn switch_core_asr_pause(ah: *mut switch_asr_handle_t) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Resume detection on an asr handle\n\\param ah the handle to resume\n\\return SWITCH_STATUS_SUCCESS"]
    pub fn switch_core_asr_resume(ah: *mut switch_asr_handle_t) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Start input timers on an asr handle\n\\param ah the handle to start timers on\n\\return SWITCH_STATUS_SUCCESS"]
    pub fn switch_core_asr_start_input_timers(ah: *mut switch_asr_handle_t) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Set a text parameter on an asr handle\n\\param sh the asr handle\n\\param param the parameter\n\\param val the value"]
    pub fn switch_core_asr_text_param(
        ah: *mut switch_asr_handle_t,
        param: *mut ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "\\brief Set a numeric parameter on an asr handle\n\\param sh the asr handle\n\\param param the parameter\n\\param val the value"]
    pub fn switch_core_asr_numeric_param(
        ah: *mut switch_asr_handle_t,
        param: *mut ::std::os::raw::c_char,
        val: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "\\brief Set a float parameter on an asr handle\n\\param sh the asr handle\n\\param param the parameter\n\\param val the value"]
    pub fn switch_core_asr_float_param(
        ah: *mut switch_asr_handle_t,
        param: *mut ::std::os::raw::c_char,
        val: f64,
    );
}
extern "C" {
    #[doc = "\\defgroup dir Directory Service Functions\n\\ingroup core1\n\\{\n*!\n\\brief Open a directory handle\n\\param dh a directory handle to use\n\\param module_name the directory module to use\n\\param source the source of the db (ip, hostname, path etc)\n\\param dsn the username or designation of the lookup\n\\param passwd the password\n\\param pool the pool to use (NULL for new pool)\n\\return SWITCH_STATUS_SUCCESS if the handle is opened\n*/"]
    pub fn switch_core_directory_open(
        dh: *mut switch_directory_handle_t,
        module_name: *mut ::std::os::raw::c_char,
        source: *mut ::std::os::raw::c_char,
        dsn: *mut ::std::os::raw::c_char,
        passwd: *mut ::std::os::raw::c_char,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Query a directory handle\n\\param dh a directory handle to use\n\\param base the base to query against\n\\param query a string of filters or query data\n\\return SWITCH_STATUS_SUCCESS if the query is successful"]
    pub fn switch_core_directory_query(
        dh: *mut switch_directory_handle_t,
        base: *mut ::std::os::raw::c_char,
        query: *mut ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Obtain the next record in a lookup\n\\param dh a directory handle to use\n\\return SWITCH_STATUS_SUCCESS if another record exists"]
    pub fn switch_core_directory_next(dh: *mut switch_directory_handle_t) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Obtain the next name/value pair in the current record\n\\param dh a directory handle to use\n\\param var a pointer to pointer of the name to fill in\n\\param val a pointer to pointer of the value to fill in\n\\return SWITCH_STATUS_SUCCESS if an item exists"]
    pub fn switch_core_directory_next_pair(
        dh: *mut switch_directory_handle_t,
        var: *mut *mut ::std::os::raw::c_char,
        val: *mut *mut ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Close an open directory handle\n\\param dh a directory handle to close\n\\return SWITCH_STATUS_SUCCESS if handle was closed"]
    pub fn switch_core_directory_close(dh: *mut switch_directory_handle_t) -> switch_status_t;
}
extern "C" {
    #[doc = "\\defgroup misc Misc\n\\ingroup core1\n\\{\n*!\n\\brief Retrieve a FILE stream of a given text channel name\n\\param channel text channel enumeration\n\\return a FILE stream\n*/"]
    pub fn switch_core_data_channel(channel: switch_text_channel_t) -> *mut FILE;
}
extern "C" {
    #[doc = "\\brief Determines if the core is ready to take calls\n\\return SWITCH_TRUE or SWITCH_FALSE"]
    pub fn switch_core_ready() -> switch_bool_t;
}
extern "C" {
    pub fn switch_core_running() -> switch_bool_t;
}
extern "C" {
    #[doc = "\\brief Determines if the core is ready to take inbound calls\n\\return SWITCH_TRUE or SWITCH_FALSE"]
    pub fn switch_core_ready_inbound() -> switch_bool_t;
}
extern "C" {
    #[doc = "\\brief Determines if the core is ready to place outbound calls\n\\return SWITCH_TRUE or SWITCH_FALSE"]
    pub fn switch_core_ready_outbound() -> switch_bool_t;
}
extern "C" {
    #[doc = "\\brief return core flags\n\\return core flags"]
    pub fn switch_core_flags() -> switch_core_flag_t;
}
extern "C" {
    #[doc = "\\brief Execute a management operation.\n\\param relative_oid the relative oid of the operation.\n\\param action the action to perform.\n\\param data input/output string.\n\\param datalen size in bytes of data.\n\\return SUCCESS on sucess."]
    pub fn switch_core_management_exec(
        relative_oid: *mut ::std::os::raw::c_char,
        action: switch_management_action_t,
        data: *mut ::std::os::raw::c_char,
        datalen: switch_size_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Switch on the privilege awareness for the process and request required privileges\n\\return 0 on success"]
    pub fn switch_core_set_process_privileges() -> i32;
}
extern "C" {
    #[doc = "\\brief Set the maximum priority the process can obtain\n\\return 0 on success"]
    pub fn set_normal_priority() -> i32;
}
extern "C" {
    pub fn set_auto_priority() -> i32;
}
extern "C" {
    pub fn set_realtime_priority() -> i32;
}
extern "C" {
    pub fn set_low_priority() -> i32;
}
extern "C" {
    #[doc = "\\brief Change user and/or group of the running process\n\\param user name of the user to switch to (or NULL)\n\\param group name of the group to switch to (or NULL)\n\\return 0 on success, -1 otherwise\n\nSeveral possible combinations:\n- user only (group NULL): switch to user and his primary group (and supplementary groups, if supported)\n- user and group: switch to user and specified group (only)\n- group only (user NULL): switch group only"]
    pub fn change_user_group(
        user: *const ::std::os::raw::c_char,
        group: *const ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    #[doc = "\\brief Run endlessly until the system is shutdown\n\\param bg divert console to the background"]
    pub fn switch_core_runtime_loop(bg: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "\\brief Set the output console to the desired file\n\\param console the file path"]
    pub fn switch_core_set_console(console: *const ::std::os::raw::c_char) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Breakdown a number of milliseconds into various time spec\n\\param total_ms a number of milliseconds\n\\param duration an object to store the results"]
    pub fn switch_core_measure_time(
        total_ms: switch_time_t,
        duration: *mut switch_core_time_duration_t,
    );
}
extern "C" {
    #[doc = "\\brief Number of microseconds the system has been up\n\\return a number of microseconds"]
    pub fn switch_core_uptime() -> switch_time_t;
}
extern "C" {
    #[doc = "\\brief send a control message to the core\n\\param cmd the command\n\\param val the command arguement (if needed)\n\\return 0 on success nonzero on error"]
    pub fn switch_core_session_ctl(
        cmd: switch_session_ctl_t,
        val: *mut ::std::os::raw::c_void,
    ) -> i32;
}
extern "C" {
    #[doc = "\\brief Get the output console\n\\return the FILE stream"]
    pub fn switch_core_get_console() -> *mut FILE;
}
extern "C" {
    #[doc = "\\brief Launch a thread"]
    pub fn switch_core_launch_thread(
        func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut switch_thread_t,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        obj: *mut ::std::os::raw::c_void,
        pool: *mut switch_memory_pool_t,
    ) -> *mut switch_thread_t;
}
extern "C" {
    #[doc = "\\brief Initiate Globals"]
    pub fn switch_core_set_globals();
}
extern "C" {
    #[doc = "\\brief Checks if 2 sessions are using the same endpoint module\n\\param a the first session\n\\param b the second session\n\\return TRUE or FALSE"]
    pub fn switch_core_session_compare(
        a: *mut switch_core_session_t,
        b: *mut switch_core_session_t,
    ) -> u8;
}
extern "C" {
    #[doc = "\\brief Checks if a session is using a specific endpoint\n\\param session the session\n\\param endpoint_interface interface of the endpoint to check\n\\return TRUE or FALSE"]
    pub fn switch_core_session_check_interface(
        session: *mut switch_core_session_t,
        endpoint_interface: *const switch_endpoint_interface_t,
    ) -> u8;
}
extern "C" {
    pub fn switch_core_session_set_video_read_callback(
        session: *mut switch_core_session_t,
        func: switch_core_video_thread_callback_func_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_video_read_callback(
        session: *mut switch_core_session_t,
        frame: *mut switch_frame_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_mime_index() -> *mut switch_hash_index_t;
}
extern "C" {
    pub fn switch_core_mime_ext2type(
        ext: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_core_mime_type2ext(
        type_: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_core_mime_add_type(
        type_: *const ::std::os::raw::c_char,
        ext: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_loadable_module_create_module_interface(
        pool: *mut switch_memory_pool_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut switch_loadable_module_interface_t;
}
extern "C" {
    pub fn switch_loadable_module_create_interface(
        mod_: *mut switch_loadable_module_interface_t,
        iname: switch_module_interface_name_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "\\brief Get the current epoch time in microseconds\n\\return the current epoch time in microseconds"]
    pub fn switch_micro_time_now() -> switch_time_t;
}
extern "C" {
    pub fn switch_mono_micro_time_now() -> switch_time_t;
}
extern "C" {
    pub fn switch_core_memory_reclaim();
}
extern "C" {
    pub fn switch_core_memory_reclaim_events();
}
extern "C" {
    pub fn switch_core_memory_reclaim_logger();
}
extern "C" {
    pub fn switch_core_memory_reclaim_all();
}
extern "C" {
    pub fn switch_core_setrlimits();
}
extern "C" {
    pub fn switch_time_ref() -> switch_time_t;
}
extern "C" {
    pub fn switch_time_sync();
}
extern "C" {
    #[doc = "\\brief Get the current epoch time\n\\param [out] (optional) The current epoch time\n\\return The current epoch time"]
    pub fn switch_epoch_time_now(t: *mut time_t) -> time_t;
}
extern "C" {
    pub fn switch_lookup_timezone(
        tz_name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_strftime_tz(
        tz: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        date: *mut ::std::os::raw::c_char,
        len: usize,
        thetime: switch_time_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_time_exp_tz_name(
        tz: *const ::std::os::raw::c_char,
        tm: *mut switch_time_exp_t,
        thetime: switch_time_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_load_network_lists(reload: switch_bool_t);
}
extern "C" {
    pub fn switch_check_network_list_ip_port_token(
        ip_str: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_int,
        list_name: *const ::std::os::raw::c_char,
        token: *mut *const ::std::os::raw::c_char,
    ) -> switch_bool_t;
}
extern "C" {
    pub fn switch_check_network_list_ip_token(
        ip_str: *const ::std::os::raw::c_char,
        list_name: *const ::std::os::raw::c_char,
        token: *mut *const ::std::os::raw::c_char,
    ) -> switch_bool_t;
}
extern "C" {
    pub fn switch_time_set_monotonic(enable: switch_bool_t);
}
extern "C" {
    pub fn switch_time_set_timerfd(enable: ::std::os::raw::c_int);
}
extern "C" {
    pub fn switch_time_set_nanosleep(enable: switch_bool_t);
}
extern "C" {
    pub fn switch_time_set_matrix(enable: switch_bool_t);
}
extern "C" {
    pub fn switch_time_set_cond_yield(enable: switch_bool_t);
}
extern "C" {
    pub fn switch_time_set_use_system_time(enable: switch_bool_t);
}
extern "C" {
    pub fn switch_core_min_dtmf_duration(duration: u32) -> u32;
}
extern "C" {
    pub fn switch_core_max_dtmf_duration(duration: u32) -> u32;
}
extern "C" {
    pub fn switch_core_min_idle_cpu(new_limit: f64) -> f64;
}
extern "C" {
    pub fn switch_core_idle_cpu() -> f64;
}
extern "C" {
    pub fn switch_core_default_dtmf_duration(duration: u32) -> u32;
}
extern "C" {
    pub fn switch_console_set_complete(string: *const ::std::os::raw::c_char) -> switch_status_t;
}
extern "C" {
    pub fn switch_console_set_alias(string: *const ::std::os::raw::c_char) -> switch_status_t;
}
extern "C" {
    pub fn switch_system(
        cmd: *const ::std::os::raw::c_char,
        wait: switch_bool_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_stream_system(
        cmd: *const ::std::os::raw::c_char,
        stream: *mut switch_stream_handle_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_cond_yield(t: switch_interval_time_t);
}
extern "C" {
    pub fn switch_cond_next();
}
extern "C" {
    pub fn switch_core_chat_send_args(
        dest_proto: *const ::std::os::raw::c_char,
        proto: *const ::std::os::raw::c_char,
        from: *const ::std::os::raw::c_char,
        to: *const ::std::os::raw::c_char,
        subject: *const ::std::os::raw::c_char,
        body: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        hint: *const ::std::os::raw::c_char,
        blocking: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_chat_send(
        dest_proto: *const ::std::os::raw::c_char,
        message_event: *mut switch_event_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_chat_deliver(
        dest_proto: *const ::std::os::raw::c_char,
        message_event: *mut *mut switch_event_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_preprocess_session(
        session: *mut switch_core_session_t,
        cmds: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_sqldb_pause();
}
extern "C" {
    pub fn switch_core_sqldb_resume();
}
#[doc = "\\}"]
pub type switch_core_db_event_callback_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        pArg: *mut ::std::os::raw::c_void,
        event: *mut switch_event_t,
    ) -> ::std::os::raw::c_int,
>;
pub const cache_db_flag_t_CDF_INUSE: cache_db_flag_t = 1;
pub const cache_db_flag_t_CDF_PRUNE: cache_db_flag_t = 2;
pub const cache_db_flag_t_CDF_NONEXPIRING: cache_db_flag_t = 4;
pub type cache_db_flag_t = ::std::os::raw::c_uint;
pub const switch_cache_db_handle_type_t_SCDB_TYPE_CORE_DB: switch_cache_db_handle_type_t = 0;
pub const switch_cache_db_handle_type_t_SCDB_TYPE_ODBC: switch_cache_db_handle_type_t = 1;
pub const switch_cache_db_handle_type_t_SCDB_TYPE_DATABASE_INTERFACE:
    switch_cache_db_handle_type_t = 2;
pub type switch_cache_db_handle_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union switch_cache_db_native_handle_t {
    pub core_db_dbh: *mut switch_coredb_handle_t,
    pub odbc_dbh: *mut switch_odbc_handle_t,
    pub database_interface_dbh: *mut switch_database_interface_handle_t,
}
#[test]
fn bindgen_test_layout_switch_cache_db_native_handle_t() {
    const UNINIT: ::std::mem::MaybeUninit<switch_cache_db_native_handle_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_cache_db_native_handle_t>(),
        8usize,
        concat!("Size of: ", stringify!(switch_cache_db_native_handle_t))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_cache_db_native_handle_t>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_cache_db_native_handle_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).core_db_dbh) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_cache_db_native_handle_t),
            "::",
            stringify!(core_db_dbh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).odbc_dbh) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_cache_db_native_handle_t),
            "::",
            stringify!(odbc_dbh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).database_interface_dbh) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_cache_db_native_handle_t),
            "::",
            stringify!(database_interface_dbh)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_cache_db_core_db_options_t {
    pub db_path: *mut ::std::os::raw::c_char,
    pub in_memory: switch_bool_t,
}
#[test]
fn bindgen_test_layout_switch_cache_db_core_db_options_t() {
    const UNINIT: ::std::mem::MaybeUninit<switch_cache_db_core_db_options_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_cache_db_core_db_options_t>(),
        16usize,
        concat!("Size of: ", stringify!(switch_cache_db_core_db_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_cache_db_core_db_options_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(switch_cache_db_core_db_options_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).db_path) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_cache_db_core_db_options_t),
            "::",
            stringify!(db_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).in_memory) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_cache_db_core_db_options_t),
            "::",
            stringify!(in_memory)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_cache_db_odbc_options_t {
    pub dsn: *mut ::std::os::raw::c_char,
    pub user: *mut ::std::os::raw::c_char,
    pub pass: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_switch_cache_db_odbc_options_t() {
    const UNINIT: ::std::mem::MaybeUninit<switch_cache_db_odbc_options_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_cache_db_odbc_options_t>(),
        24usize,
        concat!("Size of: ", stringify!(switch_cache_db_odbc_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_cache_db_odbc_options_t>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_cache_db_odbc_options_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dsn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_cache_db_odbc_options_t),
            "::",
            stringify!(dsn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_cache_db_odbc_options_t),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pass) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_cache_db_odbc_options_t),
            "::",
            stringify!(pass)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_cache_db_database_interface_options_t {
    pub original_dsn: *const ::std::os::raw::c_char,
    pub connection_string: *mut ::std::os::raw::c_char,
    pub prefix: [::std::os::raw::c_char; 16usize],
    pub database_interface: *mut switch_database_interface_t,
    pub make_module_no_unloadable: switch_bool_t,
}
#[test]
fn bindgen_test_layout_switch_cache_db_database_interface_options_t() {
    const UNINIT: ::std::mem::MaybeUninit<switch_cache_db_database_interface_options_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_cache_db_database_interface_options_t>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(switch_cache_db_database_interface_options_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<switch_cache_db_database_interface_options_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(switch_cache_db_database_interface_options_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).original_dsn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_cache_db_database_interface_options_t),
            "::",
            stringify!(original_dsn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connection_string) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_cache_db_database_interface_options_t),
            "::",
            stringify!(connection_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefix) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_cache_db_database_interface_options_t),
            "::",
            stringify!(prefix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).database_interface) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_cache_db_database_interface_options_t),
            "::",
            stringify!(database_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).make_module_no_unloadable) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_cache_db_database_interface_options_t),
            "::",
            stringify!(make_module_no_unloadable)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union switch_cache_db_connection_options_t {
    pub core_db_options: switch_cache_db_core_db_options_t,
    pub odbc_options: switch_cache_db_odbc_options_t,
    pub database_interface_options: switch_cache_db_database_interface_options_t,
}
#[test]
fn bindgen_test_layout_switch_cache_db_connection_options_t() {
    const UNINIT: ::std::mem::MaybeUninit<switch_cache_db_connection_options_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_cache_db_connection_options_t>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(switch_cache_db_connection_options_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<switch_cache_db_connection_options_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(switch_cache_db_connection_options_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).core_db_options) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_cache_db_connection_options_t),
            "::",
            stringify!(core_db_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).odbc_options) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_cache_db_connection_options_t),
            "::",
            stringify!(odbc_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).database_interface_options) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_cache_db_connection_options_t),
            "::",
            stringify!(database_interface_options)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_cache_db_handle {
    _unused: [u8; 0],
}
pub type switch_cache_db_handle_t = switch_cache_db_handle;
extern "C" {
    pub fn switch_cache_db_get_type(
        dbh: *mut switch_cache_db_handle_t,
    ) -> switch_cache_db_handle_type_t;
}
extern "C" {
    #[doc = "\\brief Returns the handle to the pool, immediately available for other\nthreads to use.\n\\param [in] The handle"]
    pub fn switch_cache_db_dismiss_db_handle(dbh: *mut *mut switch_cache_db_handle_t);
}
extern "C" {
    #[doc = "\\brief Returns the handle to the pool, handle is NOT available to\nother threads until the allocating thread actually terminates.\n\\param [in] The handle"]
    pub fn switch_cache_db_release_db_handle(dbh: *mut *mut switch_cache_db_handle_t);
}
extern "C" {
    #[doc = "\\brief Gets a new cached handle from the pool, potentially creating a new connection.\nThe connection is bound to the thread until it (the thread) terminates unless\nyou dismiss rather than release.\n\\param [out] dbh The handle\n\\param [in] type - ODBC or SQLLITE\n\\param [in] connection_options (userid, password, etc)"]
    pub fn _switch_cache_db_get_db_handle(
        dbh: *mut *mut switch_cache_db_handle_t,
        type_: switch_cache_db_handle_type_t,
        connection_options: *mut switch_cache_db_connection_options_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    pub fn _switch_cache_db_get_db_handle_dsn_ex(
        dbh: *mut *mut switch_cache_db_handle_t,
        dsn: *const ::std::os::raw::c_char,
        make_module_no_unloadable: switch_bool_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    pub fn _switch_cache_db_get_db_handle_dsn(
        dbh: *mut *mut switch_cache_db_handle_t,
        dsn: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Executes the create schema sql\n\\param [in] dbh The handle\n\\param [in] sql - sql to run\n\\param [out] err - Error if it exists"]
    pub fn switch_cache_db_create_schema(
        dbh: *mut switch_cache_db_handle_t,
        sql: *mut ::std::os::raw::c_char,
        err: *mut *mut ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Executes the sql and returns the result as a string\n\\param [in] dbh The handle\n\\param [in] sql - sql to run\n\\param [out] str - buffer for result\n\\param [in] len - length of str buffer\n\\param [out] err - Error if it exists"]
    pub fn switch_cache_db_execute_sql2str(
        dbh: *mut switch_cache_db_handle_t,
        sql: *mut ::std::os::raw::c_char,
        str_: *mut ::std::os::raw::c_char,
        len: usize,
        err: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Executes the sql\n\\param [in] dbh The handle\n\\param [in] sql - sql to run\n\\param [out] err - Error if it exists"]
    pub fn switch_cache_db_execute_sql(
        dbh: *mut switch_cache_db_handle_t,
        sql: *mut ::std::os::raw::c_char,
        err: *mut *mut ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Executes the sql and uses callback for row-by-row processing\n\\param [in] dbh The handle\n\\param [in] sql - sql to run\n\\param [in] callback - function pointer to callback\n\\param [in] pdata - data to pass to callback\n\\param [out] err - Error if it exists"]
    pub fn switch_cache_db_execute_sql_callback(
        dbh: *mut switch_cache_db_handle_t,
        sql: *const ::std::os::raw::c_char,
        callback: switch_core_db_callback_func_t,
        pdata: *mut ::std::os::raw::c_void,
        err: *mut *mut ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Executes the sql and uses callback for row-by-row processing\n\\param [in] dbh The handle\n\\param [in] sql - sql to run\n\\param [in] callback - function pointer to callback\n\\param [in] err_callback - function pointer to callback when error occurs\n\\param [in] pdata - data to pass to callback\n\\param [out] err - Error if it exists"]
    pub fn switch_cache_db_execute_sql_callback_err(
        dbh: *mut switch_cache_db_handle_t,
        sql: *const ::std::os::raw::c_char,
        callback: switch_core_db_callback_func_t,
        err_callback: switch_core_db_err_callback_func_t,
        pdata: *mut ::std::os::raw::c_void,
        err: *mut *mut ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Get the affected rows of the last performed query\n\\param [in] dbh The handle\n\\param [out] the number of affected rows"]
    pub fn switch_cache_db_affected_rows(
        dbh: *mut switch_cache_db_handle_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief load an external extension to db\n\\param [in] dbh The handle\n\\param [out] the path to the extension"]
    pub fn switch_cache_db_load_extension(
        dbh: *mut switch_cache_db_handle_t,
        extension: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Provides some feedback as to the status of the db connection pool\n\\param [in] stream stream for status"]
    pub fn switch_cache_db_status(stream: *mut switch_stream_handle_t);
}
extern "C" {
    pub fn _switch_core_db_handle(
        dbh: *mut *mut switch_cache_db_handle_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_cache_db_test_reactive(
        db: *mut switch_cache_db_handle_t,
        test_sql: *const ::std::os::raw::c_char,
        drop_sql: *const ::std::os::raw::c_char,
        reactive_sql: *const ::std::os::raw::c_char,
    ) -> switch_bool_t;
}
extern "C" {
    pub fn switch_cache_db_test_reactive_ex(
        db: *mut switch_cache_db_handle_t,
        test_sql: *const ::std::os::raw::c_char,
        drop_sql: *const ::std::os::raw::c_char,
        reactive_sql: *const ::std::os::raw::c_char,
        row_size_limited_reactive_sql: *const ::std::os::raw::c_char,
    ) -> switch_bool_t;
}
extern "C" {
    pub fn switch_cache_db_persistant_execute(
        dbh: *mut switch_cache_db_handle_t,
        sql: *const ::std::os::raw::c_char,
        retries: u32,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_cache_db_persistant_execute_trans_full(
        dbh: *mut switch_cache_db_handle_t,
        sql: *mut ::std::os::raw::c_char,
        retries: u32,
        pre_trans_execute: *const ::std::os::raw::c_char,
        post_trans_execute: *const ::std::os::raw::c_char,
        inner_pre_trans_execute: *const ::std::os::raw::c_char,
        inner_post_trans_execute: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_cache_db_database_interface_flush_handles(
        database_interface: *mut switch_database_interface_t,
    );
}
extern "C" {
    #[doc = "\\brief Returns error if no suitable database interface found to serve core db dsn."]
    pub fn switch_core_check_core_db_dsn() -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Returns error if no suitable database interface found for a dsn."]
    pub fn switch_database_available(dsn: *mut ::std::os::raw::c_char) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_set_signal_handlers();
}
extern "C" {
    pub fn switch_core_debug_level() -> u32;
}
extern "C" {
    pub fn switch_core_sps() -> i32;
}
extern "C" {
    pub fn switch_core_sps_last() -> i32;
}
extern "C" {
    pub fn switch_core_sps_peak() -> i32;
}
extern "C" {
    pub fn switch_core_sps_peak_fivemin() -> i32;
}
extern "C" {
    pub fn switch_core_sessions_peak() -> i32;
}
extern "C" {
    pub fn switch_core_sessions_peak_fivemin() -> i32;
}
extern "C" {
    pub fn switch_cache_db_flush_handles();
}
extern "C" {
    pub fn switch_core_banner() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_core_session_in_thread(session: *mut switch_core_session_t) -> switch_bool_t;
}
extern "C" {
    pub fn switch_default_ptime(name: *const ::std::os::raw::c_char, number: u32) -> u32;
}
extern "C" {
    pub fn switch_default_rate(name: *const ::std::os::raw::c_char, number: u32) -> u32;
}
extern "C" {
    pub fn switch_core_max_audio_channels(limit: u32) -> u32;
}
extern "C" {
    #[doc = "\\brief Add user registration\n\\param [in] user\n\\param [in] realm\n\\param [in] token\n\\param [in] url - a freeswitch dial string\n\\param [in] expires\n\\param [in] network_ip\n\\param [in] network_port\n\\param [in] network_proto - one of tls, tcp, udp\n\\param [in] metadata - generic metadata supplied by module\n\\param [out] err - Error if it exists"]
    pub fn switch_core_add_registration(
        user: *const ::std::os::raw::c_char,
        realm: *const ::std::os::raw::c_char,
        token: *const ::std::os::raw::c_char,
        url: *const ::std::os::raw::c_char,
        expires: u32,
        network_ip: *const ::std::os::raw::c_char,
        network_port: *const ::std::os::raw::c_char,
        network_proto: *const ::std::os::raw::c_char,
        metadata: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Delete user registration\n\\param [in] user\n\\param [in] realm\n\\param [in] token\n\\param [out] err - Error if it exists"]
    pub fn switch_core_del_registration(
        user: *const ::std::os::raw::c_char,
        realm: *const ::std::os::raw::c_char,
        token: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Expire user registrations\n\\param [in] force delete all registrations\n\\param [out] err - Error if it exists"]
    pub fn switch_core_expire_registration(force: ::std::os::raw::c_int) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Get RTP port range start value\n\\param[in] void\n\\param[out] RTP port range start value"]
    pub fn switch_core_get_rtp_port_range_start_port() -> u16;
}
extern "C" {
    #[doc = "\\brief Get RTP port range end value\n\\param[in] void\n\\param[out] RTP port range end value"]
    pub fn switch_core_get_rtp_port_range_end_port() -> u16;
}
extern "C" {
    pub fn switch_say_file_handle_get_variable(
        sh: *mut switch_say_file_handle_t,
        var: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_say_file_handle_get_path(
        sh: *mut switch_say_file_handle_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_say_file_handle_detach_path(
        sh: *mut switch_say_file_handle_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_say_file_handle_destroy(sh: *mut *mut switch_say_file_handle_t);
}
extern "C" {
    pub fn switch_say_file_handle_create(
        sh: *mut *mut switch_say_file_handle_t,
        ext: *const ::std::os::raw::c_char,
        var_event: *mut *mut switch_event_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_say_file(
        sh: *mut switch_say_file_handle_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn switch_max_file_desc() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_close_extra_files(
        keep: *mut ::std::os::raw::c_int,
        keep_ttl: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn switch_core_thread_set_cpu_affinity(cpu: ::std::os::raw::c_int) -> switch_status_t;
}
extern "C" {
    pub fn switch_os_yield();
}
extern "C" {
    pub fn switch_core_get_stacksizes(
        cur: *mut switch_size_t,
        max: *mut switch_size_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_gen_encoded_silence(
        data: *mut ::std::os::raw::c_uchar,
        read_impl: *const switch_codec_implementation_t,
        len: switch_size_t,
    );
}
extern "C" {
    pub fn switch_core_dbtype() -> switch_cache_db_handle_type_t;
}
extern "C" {
    pub fn switch_core_sql_exec(sql: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn switch_core_recovery_recover(
        technology: *const ::std::os::raw::c_char,
        profile_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_core_recovery_untrack(session: *mut switch_core_session_t, force: switch_bool_t);
}
extern "C" {
    pub fn switch_core_recovery_track(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_recovery_flush(
        technology: *const ::std::os::raw::c_char,
        profile_name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn switch_sql_queue_manager_pause(
        qm: *mut switch_sql_queue_manager_t,
        flush: switch_bool_t,
    );
}
extern "C" {
    pub fn switch_sql_queue_manager_resume(qm: *mut switch_sql_queue_manager_t);
}
extern "C" {
    pub fn switch_sql_queue_manager_size(
        qm: *mut switch_sql_queue_manager_t,
        index: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_sql_queue_manager_push_confirm(
        qm: *mut switch_sql_queue_manager_t,
        sql: *const ::std::os::raw::c_char,
        pos: u32,
        dup: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_sql_queue_manager_push(
        qm: *mut switch_sql_queue_manager_t,
        sql: *const ::std::os::raw::c_char,
        pos: u32,
        dup: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_sql_queue_manager_destroy(
        qmp: *mut *mut switch_sql_queue_manager_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_sql_queue_manager_init_name(
        name: *const ::std::os::raw::c_char,
        qmp: *mut *mut switch_sql_queue_manager_t,
        numq: u32,
        dsn: *const ::std::os::raw::c_char,
        max_trans: u32,
        pre_trans_execute: *const ::std::os::raw::c_char,
        post_trans_execute: *const ::std::os::raw::c_char,
        inner_pre_trans_execute: *const ::std::os::raw::c_char,
        inner_post_trans_execute: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_sql_queue_manager_start(qm: *mut switch_sql_queue_manager_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_sql_queue_manager_stop(qm: *mut switch_sql_queue_manager_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_cache_db_execute_sql_event_callback(
        dbh: *mut switch_cache_db_handle_t,
        sql: *const ::std::os::raw::c_char,
        callback: switch_core_db_event_callback_func_t,
        pdata: *mut ::std::os::raw::c_void,
        err: *mut *mut ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_sql_queue_manager_execute_sql_callback(
        qm: *mut switch_sql_queue_manager_t,
        sql: *const ::std::os::raw::c_char,
        callback: switch_core_db_callback_func_t,
        pdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn switch_sql_queue_manager_execute_sql_callback_err(
        qm: *mut switch_sql_queue_manager_t,
        sql: *const ::std::os::raw::c_char,
        callback: switch_core_db_callback_func_t,
        err_callback: switch_core_db_err_callback_func_t,
        pdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn switch_sql_queue_manager_execute_sql_event_callback(
        qm: *mut switch_sql_queue_manager_t,
        sql: *const ::std::os::raw::c_char,
        callback: switch_core_db_event_callback_func_t,
        pdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn switch_sql_queue_manager_execute_sql_event_callback_err(
        qm: *mut switch_sql_queue_manager_t,
        sql: *const ::std::os::raw::c_char,
        callback: switch_core_db_event_callback_func_t,
        err_callback: switch_core_db_err_callback_func_t,
        pdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn switch_fork() -> pid_t;
}
extern "C" {
    pub fn switch_core_gen_certs(prefix: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_core_check_dtls_pem(file: *const ::std::os::raw::c_char) -> switch_bool_t;
}
extern "C" {
    pub fn switch_core_cert_gen_fingerprint(
        prefix: *const ::std::os::raw::c_char,
        fp: *mut dtls_fingerprint_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_core_cert_expand_fingerprint(
        fp: *mut dtls_fingerprint_t,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_core_cert_verify(fp: *mut dtls_fingerprint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _switch_core_session_request_video_refresh(
        session: *mut switch_core_session_t,
        force: ::std::os::raw::c_int,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_send_and_request_video_refresh(
        session: *mut switch_core_session_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_stream_system_fork(
        cmd: *const ::std::os::raw::c_char,
        stream: *mut switch_stream_handle_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_spawn(
        cmd: *const ::std::os::raw::c_char,
        wait: switch_bool_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_stream_spawn(
        cmd: *const ::std::os::raw::c_char,
        shell: switch_bool_t,
        wait: switch_bool_t,
        stream: *mut switch_stream_handle_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_core_session_debug_pool(stream: *mut switch_stream_handle_t);
}
extern "C" {
    pub fn switch_core_session_override_io_routines(
        session: *mut switch_core_session_t,
        ior: *mut switch_io_routines_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_version_major() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_version_minor() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_version_micro() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_version_revision() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_version_revision_human() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_version_full() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_version_full_human() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_core_autobind_cpu();
}
extern "C" {
    pub fn switch_core_session_start_text_thread(
        session: *mut switch_core_session_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_get_event_channel_key_separator() -> *const ::std::os::raw::c_char;
}
#[doc = "\\defgroup log Logger Routines\n\\ingroup core1\n\\{\n*! \\brief Log Data\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_log_node_t {
    #[doc = " The complete log message"]
    pub data: *mut ::std::os::raw::c_char,
    #[doc = " The file where the message originated"]
    pub file: [::std::os::raw::c_char; 80usize],
    #[doc = " The line number where the message originated"]
    pub line: u32,
    #[doc = " The function where the message originated"]
    pub func: [::std::os::raw::c_char; 80usize],
    #[doc = " The log level of the message"]
    pub level: switch_log_level_t,
    #[doc = " The time when the log line was sent"]
    pub timestamp: switch_time_t,
    #[doc = " A pointer to where the actual content of the message starts (skipping past the preformatted portion)"]
    pub content: *mut ::std::os::raw::c_char,
    pub userdata: *mut ::std::os::raw::c_char,
    pub channel: switch_text_channel_t,
    pub slevel: switch_log_level_t,
    pub tags: *mut switch_event_t,
    pub sequence: i64,
    pub meta: *mut cJSON,
}
#[test]
fn bindgen_test_layout_switch_log_node_t() {
    const UNINIT: ::std::mem::MaybeUninit<switch_log_node_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_log_node_t>(),
        232usize,
        concat!("Size of: ", stringify!(switch_log_node_t))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_log_node_t>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_log_node_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_log_node_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_log_node_t),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_log_node_t),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_log_node_t),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_log_node_t),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_log_node_t),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_log_node_t),
            "::",
            stringify!(content)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).userdata) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_log_node_t),
            "::",
            stringify!(userdata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_log_node_t),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slevel) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_log_node_t),
            "::",
            stringify!(slevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tags) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_log_node_t),
            "::",
            stringify!(tags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_log_node_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meta) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_log_node_t),
            "::",
            stringify!(meta)
        )
    );
}
#[doc = "\\{\n*! \\brief JSON Log formatting data item\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_log_json_format_item_t {
    pub name: *const ::std::os::raw::c_char,
    pub value: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_switch_log_json_format_item_t() {
    const UNINIT: ::std::mem::MaybeUninit<switch_log_json_format_item_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_log_json_format_item_t>(),
        16usize,
        concat!("Size of: ", stringify!(switch_log_json_format_item_t))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_log_json_format_item_t>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_log_json_format_item_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_log_json_format_item_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_log_json_format_item_t),
            "::",
            stringify!(value)
        )
    );
}
#[doc = "\\{\n*! \\brief JSON Log formatting data\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_log_json_format_t {
    pub version: switch_log_json_format_item_t,
    pub host: switch_log_json_format_item_t,
    pub timestamp: switch_log_json_format_item_t,
    pub level: switch_log_json_format_item_t,
    pub ident: switch_log_json_format_item_t,
    pub pid: switch_log_json_format_item_t,
    pub uuid: switch_log_json_format_item_t,
    pub file: switch_log_json_format_item_t,
    pub line: switch_log_json_format_item_t,
    pub function: switch_log_json_format_item_t,
    pub full_message: switch_log_json_format_item_t,
    pub short_message: switch_log_json_format_item_t,
    pub custom_field_prefix: *const ::std::os::raw::c_char,
    pub timestamp_divisor: f64,
    pub sequence: switch_log_json_format_item_t,
}
#[test]
fn bindgen_test_layout_switch_log_json_format_t() {
    const UNINIT: ::std::mem::MaybeUninit<switch_log_json_format_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_log_json_format_t>(),
        224usize,
        concat!("Size of: ", stringify!(switch_log_json_format_t))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_log_json_format_t>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_log_json_format_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_log_json_format_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_log_json_format_t),
            "::",
            stringify!(host)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_log_json_format_t),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_log_json_format_t),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ident) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_log_json_format_t),
            "::",
            stringify!(ident)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pid) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_log_json_format_t),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uuid) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_log_json_format_t),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_log_json_format_t),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_log_json_format_t),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).function) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_log_json_format_t),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).full_message) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_log_json_format_t),
            "::",
            stringify!(full_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).short_message) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_log_json_format_t),
            "::",
            stringify!(short_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_field_prefix) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_log_json_format_t),
            "::",
            stringify!(custom_field_prefix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp_divisor) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_log_json_format_t),
            "::",
            stringify!(timestamp_divisor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_log_json_format_t),
            "::",
            stringify!(sequence)
        )
    );
}
pub type switch_log_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        node: *const switch_log_node_t,
        level: switch_log_level_t,
    ) -> switch_status_t,
>;
extern "C" {
    #[doc = "\\brief Convert a log node to JSON object.  Destroy JSON object when finished.\n\\param node the node\n\\param log_level the log level\n\\param json_format the output format definition\n\\param char_vars optional channel variables to add to logs"]
    pub fn switch_log_node_to_json(
        node: *const switch_log_node_t,
        log_level: ::std::os::raw::c_int,
        json_format: *mut switch_log_json_format_t,
        chan_vars: *mut switch_event_t,
    ) -> *mut cJSON;
}
extern "C" {
    #[doc = "\\brief Initilize the logging engine\n\\param pool the memory pool to use\n\\note to be called at application startup by the core"]
    pub fn switch_log_init(
        pool: *mut switch_memory_pool_t,
        colorize: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Shut down the logging engine\n\\note to be called at application termination by the core"]
    pub fn switch_log_shutdown() -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Write log data to the logging engine\n\\param channel the log channel to write to\n\\param file the current file\n\\param func the current function\n\\param line the current line\n\\param userdata ununsed\n\\param level the current log level\n\\param fmt desired format\n\\param ... variable args\n\\note there are channel macros to supply the first 4 parameters (SWITCH_CHANNEL_LOG, SWITCH_CHANNEL_LOG_CLEAN, ...)\n\\see switch_types.h"]
    pub fn switch_log_printf(
        channel: switch_text_channel_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        userdata: *const ::std::os::raw::c_char,
        level: switch_log_level_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = "\\brief Write log data to the logging engine\n\\param channel the log channel to write to\n\\param file the current file\n\\param func the current function\n\\param line the current line\n\\param userdata ununsed\n\\param level the current log level\n\\param fmt desired format\n\\param ap variable args\n\\note there are channel macros to supply the first 4 parameters (SWITCH_CHANNEL_LOG, SWITCH_CHANNEL_LOG_CLEAN, ...)\n\\see switch_types.h"]
    pub fn switch_log_vprintf(
        channel: switch_text_channel_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        userdata: *const ::std::os::raw::c_char,
        level: switch_log_level_t,
        fmt: *const ::std::os::raw::c_char,
        ap: va_list,
    );
}
extern "C" {
    #[doc = "\\brief Write log data to the logging engine w/ optional JSON metadata\n\\param channel the log channel to write to\n\\param file the current file\n\\param func the current function\n\\param line the current line\n\\param userdata ununsed\n\\param level the current log level\n\\param meta log metadata - consumed by this function\n\\param fmt desired format\n\\param ... variable args\n\\note there are channel macros to supply the first 4 parameters (SWITCH_CHANNEL_LOG, SWITCH_CHANNEL_LOG_CLEAN, ...)\n\\see switch_types.h"]
    pub fn switch_log_meta_printf(
        channel: switch_text_channel_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        userdata: *const ::std::os::raw::c_char,
        level: switch_log_level_t,
        meta: *mut *mut cJSON,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = "\\brief Write log data to the logging engine w/ optional JSON metadata\n\\param channel the log channel to write to\n\\param file the current file\n\\param func the current function\n\\param line the current line\n\\param userdata ununsed\n\\param level the current log level\n\\param meta log metadata - consumed by this function\n\\param fmt desired format\n\\param ap variable args\n\\note there are channel macros to supply the first 4 parameters (SWITCH_CHANNEL_LOG, SWITCH_CHANNEL_LOG_CLEAN, ...)\n\\see switch_types.h"]
    pub fn switch_log_meta_vprintf(
        channel: switch_text_channel_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        userdata: *const ::std::os::raw::c_char,
        level: switch_log_level_t,
        meta: *mut *mut cJSON,
        fmt: *const ::std::os::raw::c_char,
        ap: va_list,
    );
}
extern "C" {
    #[doc = "\\brief Shut down  the logging engine\n\\note to be called at application termination by the core"]
    pub fn switch_log_bind_logger(
        function: switch_log_function_t,
        level: switch_log_level_t,
        is_console: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_log_unbind_logger(function: switch_log_function_t) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Return the name of the specified log level\n\\param level the level\n\\return the name of the log level"]
    pub fn switch_log_level2str(level: switch_log_level_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Return the level number of the specified log level name\n\\param str the name of the level\n\\return the log level"]
    pub fn switch_log_str2level(str_: *const ::std::os::raw::c_char) -> switch_log_level_t;
}
extern "C" {
    pub fn switch_log_str2mask(str_: *const ::std::os::raw::c_char) -> u32;
}
extern "C" {
    pub fn switch_log_node_dup(node: *const switch_log_node_t) -> *mut switch_log_node_t;
}
extern "C" {
    pub fn switch_log_node_free(pnode: *mut *mut switch_log_node_t);
}
#[doc = "\\defgroup resamp Audio Resample Functions\n\\ingroup core1\n\\{\n/\n/*! \\brief An audio resampling handle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_audio_resampler_t {
    #[doc = " a pointer to store the resampler object"]
    pub resampler: *mut ::std::os::raw::c_void,
    #[doc = " the rate to resample from in hz"]
    pub from_rate: ::std::os::raw::c_int,
    #[doc = " the rate to resample to in hz"]
    pub to_rate: ::std::os::raw::c_int,
    #[doc = " the factor to resample by (from / to)"]
    pub factor: f64,
    pub rfactor: f64,
    pub to: *mut i16,
    #[doc = " the size of the to buffer used"]
    pub to_len: u32,
    #[doc = " the total size of the to buffer"]
    pub to_size: u32,
    #[doc = " the number of channels"]
    pub channels: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_switch_audio_resampler_t() {
    const UNINIT: ::std::mem::MaybeUninit<switch_audio_resampler_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_audio_resampler_t>(),
        56usize,
        concat!("Size of: ", stringify!(switch_audio_resampler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_audio_resampler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_audio_resampler_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resampler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_audio_resampler_t),
            "::",
            stringify!(resampler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).from_rate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_audio_resampler_t),
            "::",
            stringify!(from_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_rate) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_audio_resampler_t),
            "::",
            stringify!(to_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).factor) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_audio_resampler_t),
            "::",
            stringify!(factor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rfactor) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_audio_resampler_t),
            "::",
            stringify!(rfactor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_audio_resampler_t),
            "::",
            stringify!(to)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_len) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_audio_resampler_t),
            "::",
            stringify!(to_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_size) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_audio_resampler_t),
            "::",
            stringify!(to_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_audio_resampler_t),
            "::",
            stringify!(channels)
        )
    );
}
extern "C" {
    #[doc = "\\brief Prepare a new resampler handle\n\\param new_resampler NULL pointer to aim at the new handle\n\\param from_rate the rate to transfer from in hz\n\\param to_rate the rate to transfer to in hz\n\\param quality the quality desired\n\\return SWITCH_STATUS_SUCCESS if the handle was created"]
    pub fn switch_resample_perform_create(
        new_resampler: *mut *mut switch_audio_resampler_t,
        from_rate: u32,
        to_rate: u32,
        to_size: u32,
        quality: ::std::os::raw::c_int,
        channels: u32,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Destroy an existing resampler handle\n\\param resampler the resampler handle to destroy"]
    pub fn switch_resample_destroy(resampler: *mut *mut switch_audio_resampler_t);
}
extern "C" {
    #[doc = "\\brief Resample one float buffer into another using specifications of a given handle\n\\param resampler the resample handle\n\\param src the source data\n\\param srclen the length of the source data\n\\return the used size of dst"]
    pub fn switch_resample_process(
        resampler: *mut switch_audio_resampler_t,
        src: *mut i16,
        srclen: u32,
    ) -> u32;
}
extern "C" {
    #[doc = "\\brief Convert an array of floats to an array of shorts\n\\param f the float buffer\n\\param s the short buffer\n\\param len the length of the buffers\n\\return the size of the converted buffer"]
    pub fn switch_float_to_short(
        f: *mut f32,
        s: *mut ::std::os::raw::c_short,
        len: switch_size_t,
    ) -> switch_size_t;
}
extern "C" {
    #[doc = "\\brief Convert an array of chars to an array of floats\n\\param c the char buffer\n\\param f the float buffer\n\\param len the length of the buffers\n\\return the size of the converted buffer"]
    pub fn switch_char_to_float(
        c: *mut ::std::os::raw::c_char,
        f: *mut f32,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Convert an array of floats to an array of chars\n\\param f an array of floats\n\\param c an array of chars\n\\param len the length of the buffers\n\\return the size of the converted buffer"]
    pub fn switch_float_to_char(
        f: *mut f32,
        c: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Convert an array of shorts to an array of floats\n\\param s an array of shorts\n\\param f an array of floats\n\\param len the size of the buffers\n\\return the size of the converted buffer"]
    pub fn switch_short_to_float(
        s: *mut ::std::os::raw::c_short,
        f: *mut f32,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Perform a byteswap on a buffer of 16 bit samples\n\\param buf an array of samples\n\\param len the size of the array"]
    pub fn switch_swap_linear(buf: *mut i16, len: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "\\brief Generate static noise\n\\param data the audio data buffer\n\\param samples the number of 2 byte samples\n\\param divisor the volume factor"]
    pub fn switch_generate_sln_silence(data: *mut i16, samples: u32, channels: u32, divisor: u32);
}
extern "C" {
    #[doc = "\\brief Change the volume of a signed linear audio frame\n\\param data the audio data\n\\param samples the number of 2 byte samples\n\\param vol the volume factor -4 -> 4"]
    pub fn switch_change_sln_volume(data: *mut i16, samples: u32, vol: i32);
}
extern "C" {
    #[doc = "\\brief Change the volume of a signed linear audio frame with more granularity\n\\param data the audio data\n\\param samples the number of 2 byte samples\n\\param vol the volume factor -12 -> 12"]
    pub fn switch_change_sln_volume_granular(data: *mut i16, samples: u32, vol: i32);
}
extern "C" {
    #[doc = "\\}"]
    pub fn switch_merge_sln(
        data: *mut i16,
        samples: u32,
        other_data: *mut i16,
        other_samples: u32,
        channels: ::std::os::raw::c_int,
    ) -> u32;
}
extern "C" {
    pub fn switch_unmerge_sln(
        data: *mut i16,
        samples: u32,
        other_data: *mut i16,
        other_samples: u32,
        channels: ::std::os::raw::c_int,
    ) -> u32;
}
extern "C" {
    pub fn switch_mux_channels(
        data: *mut i16,
        samples: switch_size_t,
        orig_channels: u32,
        channels: u32,
    );
}
extern "C" {
    pub fn switch_agc_set(
        agc: *mut switch_agc_t,
        energy_avg: u32,
        low_energy_point: u32,
        margin: u32,
        change_factor: u32,
        period_len: u32,
    );
}
extern "C" {
    pub fn switch_agc_create(
        agcP: *mut *mut switch_agc_t,
        energy_avg: u32,
        low_energy_point: u32,
        margin: u32,
        change_factor: u32,
        period_len: u32,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_agc_destroy(agcP: *mut *mut switch_agc_t);
}
extern "C" {
    pub fn switch_agc_feed(
        agc: *mut switch_agc_t,
        data: *mut i16,
        samples: u32,
        channels: u32,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_agc_set_energy_avg(agc: *mut switch_agc_t, energy_avg: u32);
}
extern "C" {
    pub fn switch_agc_set_energy_low(agc: *mut switch_agc_t, low_energy_point: u32);
}
extern "C" {
    pub fn switch_agc_set_token(agc: *mut switch_agc_t, token: *const ::std::os::raw::c_char);
}
pub const switch_state_handler_name_t_SWITCH_SHN_ON_INIT: switch_state_handler_name_t = 0;
pub const switch_state_handler_name_t_SWITCH_SHN_ON_ROUTING: switch_state_handler_name_t = 1;
pub const switch_state_handler_name_t_SWITCH_SHN_ON_EXECUTE: switch_state_handler_name_t = 2;
pub const switch_state_handler_name_t_SWITCH_SHN_ON_HANGUP: switch_state_handler_name_t = 3;
pub const switch_state_handler_name_t_SWITCH_SHN_ON_EXCHANGE_MEDIA: switch_state_handler_name_t = 4;
pub const switch_state_handler_name_t_SWITCH_SHN_ON_SOFT_EXECUTE: switch_state_handler_name_t = 5;
pub const switch_state_handler_name_t_SWITCH_SHN_ON_CONSUME_MEDIA: switch_state_handler_name_t = 6;
pub const switch_state_handler_name_t_SWITCH_SHN_ON_HIBERNATE: switch_state_handler_name_t = 7;
pub const switch_state_handler_name_t_SWITCH_SHN_ON_RESET: switch_state_handler_name_t = 8;
pub const switch_state_handler_name_t_SWITCH_SHN_ON_PARK: switch_state_handler_name_t = 9;
pub const switch_state_handler_name_t_SWITCH_SHN_ON_REPORTING: switch_state_handler_name_t = 10;
pub const switch_state_handler_name_t_SWITCH_SHN_ON_DESTROY: switch_state_handler_name_t = 11;
#[doc = " \\brief A table of functions to execute at various states"]
pub type switch_state_handler_name_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_state_handler_table {
    #[doc = " executed when the state changes to init"]
    pub on_init: switch_state_handler_t,
    #[doc = " executed when the state changes to routing"]
    pub on_routing: switch_state_handler_t,
    #[doc = " executed when the state changes to execute"]
    pub on_execute: switch_state_handler_t,
    #[doc = " executed when the state changes to hangup"]
    pub on_hangup: switch_state_handler_t,
    #[doc = " executed when the state changes to exchange_media"]
    pub on_exchange_media: switch_state_handler_t,
    #[doc = " executed when the state changes to soft_execute"]
    pub on_soft_execute: switch_state_handler_t,
    #[doc = " executed when the state changes to consume_media"]
    pub on_consume_media: switch_state_handler_t,
    #[doc = " executed when the state changes to hibernate"]
    pub on_hibernate: switch_state_handler_t,
    #[doc = " executed when the state changes to reset"]
    pub on_reset: switch_state_handler_t,
    #[doc = " executed when the state changes to park"]
    pub on_park: switch_state_handler_t,
    #[doc = " executed when the state changes to reporting"]
    pub on_reporting: switch_state_handler_t,
    #[doc = " executed when the state changes to destroy"]
    pub on_destroy: switch_state_handler_t,
    pub flags: ::std::os::raw::c_int,
    pub padding: [*mut ::std::os::raw::c_void; 10usize],
}
#[test]
fn bindgen_test_layout_switch_state_handler_table() {
    const UNINIT: ::std::mem::MaybeUninit<switch_state_handler_table> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_state_handler_table>(),
        184usize,
        concat!("Size of: ", stringify!(switch_state_handler_table))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_state_handler_table>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_state_handler_table))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_init) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_state_handler_table),
            "::",
            stringify!(on_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_routing) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_state_handler_table),
            "::",
            stringify!(on_routing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_execute) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_state_handler_table),
            "::",
            stringify!(on_execute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_hangup) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_state_handler_table),
            "::",
            stringify!(on_hangup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_exchange_media) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_state_handler_table),
            "::",
            stringify!(on_exchange_media)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_soft_execute) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_state_handler_table),
            "::",
            stringify!(on_soft_execute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_consume_media) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_state_handler_table),
            "::",
            stringify!(on_consume_media)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_hibernate) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_state_handler_table),
            "::",
            stringify!(on_hibernate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_reset) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_state_handler_table),
            "::",
            stringify!(on_reset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_park) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_state_handler_table),
            "::",
            stringify!(on_park)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_reporting) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_state_handler_table),
            "::",
            stringify!(on_reporting)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_destroy) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_state_handler_table),
            "::",
            stringify!(on_destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_state_handler_table),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_state_handler_table),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_stream_handle {
    pub read_function: switch_stream_handle_read_function_t,
    pub write_function: switch_stream_handle_write_function_t,
    pub raw_write_function: switch_stream_handle_raw_write_function_t,
    pub data: *mut ::std::os::raw::c_void,
    pub end: *mut ::std::os::raw::c_void,
    pub data_size: switch_size_t,
    pub data_len: switch_size_t,
    pub alloc_len: switch_size_t,
    pub alloc_chunk: switch_size_t,
    pub param_event: *mut switch_event_t,
}
#[test]
fn bindgen_test_layout_switch_stream_handle() {
    const UNINIT: ::std::mem::MaybeUninit<switch_stream_handle> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_stream_handle>(),
        80usize,
        concat!("Size of: ", stringify!(switch_stream_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_stream_handle>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_stream_handle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_function) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_stream_handle),
            "::",
            stringify!(read_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_function) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_stream_handle),
            "::",
            stringify!(write_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_write_function) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_stream_handle),
            "::",
            stringify!(raw_write_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_stream_handle),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_stream_handle),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_size) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_stream_handle),
            "::",
            stringify!(data_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_len) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_stream_handle),
            "::",
            stringify!(data_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc_len) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_stream_handle),
            "::",
            stringify!(alloc_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc_chunk) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_stream_handle),
            "::",
            stringify!(alloc_chunk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).param_event) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_stream_handle),
            "::",
            stringify!(param_event)
        )
    );
}
pub type switch_io_outgoing_channel_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut switch_core_session_t,
        arg2: *mut switch_event_t,
        arg3: *mut switch_caller_profile_t,
        arg4: *mut *mut switch_core_session_t,
        arg5: *mut *mut switch_memory_pool_t,
        arg6: switch_originate_flag_t,
        arg7: *mut switch_call_cause_t,
    ) -> switch_call_cause_t,
>;
pub type switch_io_read_frame_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut switch_core_session_t,
        arg2: *mut *mut switch_frame_t,
        arg3: switch_io_flag_t,
        arg4: ::std::os::raw::c_int,
    ) -> switch_status_t,
>;
pub type switch_io_write_frame_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut switch_core_session_t,
        arg2: *mut switch_frame_t,
        arg3: switch_io_flag_t,
        arg4: ::std::os::raw::c_int,
    ) -> switch_status_t,
>;
pub type switch_io_kill_channel_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut switch_core_session_t,
        arg2: ::std::os::raw::c_int,
    ) -> switch_status_t,
>;
pub type switch_io_send_dtmf_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut switch_core_session_t,
        arg2: *const switch_dtmf_t,
    ) -> switch_status_t,
>;
pub type switch_io_receive_message_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut switch_core_session_t,
        arg2: *mut switch_core_session_message_t,
    ) -> switch_status_t,
>;
pub type switch_io_receive_event_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut switch_core_session_t,
        arg2: *mut switch_event_t,
    ) -> switch_status_t,
>;
pub type switch_io_state_change_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut switch_core_session_t) -> switch_status_t,
>;
pub type switch_io_state_run_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut switch_core_session_t) -> switch_status_t,
>;
pub type switch_io_read_video_frame_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut switch_core_session_t,
        arg2: *mut *mut switch_frame_t,
        arg3: switch_io_flag_t,
        arg4: ::std::os::raw::c_int,
    ) -> switch_status_t,
>;
pub type switch_io_write_video_frame_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut switch_core_session_t,
        arg2: *mut switch_frame_t,
        arg3: switch_io_flag_t,
        arg4: ::std::os::raw::c_int,
    ) -> switch_status_t,
>;
pub type switch_io_read_text_frame_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut switch_core_session_t,
        arg2: *mut *mut switch_frame_t,
        arg3: switch_io_flag_t,
        arg4: ::std::os::raw::c_int,
    ) -> switch_status_t,
>;
pub type switch_io_write_text_frame_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut switch_core_session_t,
        arg2: *mut switch_frame_t,
        arg3: switch_io_flag_t,
        arg4: ::std::os::raw::c_int,
    ) -> switch_status_t,
>;
pub type switch_io_get_jb_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut switch_core_session_t,
        arg2: switch_media_type_t,
    ) -> *mut switch_jb_t,
>;
pub const switch_io_routine_name_t_SWITCH_IO_OUTGOING_CHANNEL: switch_io_routine_name_t = 0;
pub const switch_io_routine_name_t_SWITCH_IO_READ_FRAME: switch_io_routine_name_t = 1;
pub const switch_io_routine_name_t_SWITCH_IO_WRITE_FRAME: switch_io_routine_name_t = 2;
pub const switch_io_routine_name_t_SWITCH_IO_KILL_CHANNEL: switch_io_routine_name_t = 3;
pub const switch_io_routine_name_t_SWITCH_IO_SEND_DTMF: switch_io_routine_name_t = 4;
pub const switch_io_routine_name_t_SWITCH_IO_RECEIVE_MESSAGE: switch_io_routine_name_t = 5;
pub const switch_io_routine_name_t_SWITCH_IO_RECEIVE_EVENT: switch_io_routine_name_t = 6;
pub const switch_io_routine_name_t_SWITCH_IO_STATE_CHANGE: switch_io_routine_name_t = 7;
pub const switch_io_routine_name_t_SWITCH_IO_READ_VIDEO_FRAME: switch_io_routine_name_t = 8;
pub const switch_io_routine_name_t_SWITCH_IO_WRITE_VIDEO_FRAME: switch_io_routine_name_t = 9;
pub const switch_io_routine_name_t_SWITCH_IO_READ_TEXT_FRAME: switch_io_routine_name_t = 10;
pub const switch_io_routine_name_t_SWITCH_IO_WRITE_TEXT_FRAME: switch_io_routine_name_t = 11;
pub const switch_io_routine_name_t_SWITCH_IO_GET_JB: switch_io_routine_name_t = 12;
pub type switch_io_routine_name_t = ::std::os::raw::c_uint;
#[doc = " \\brief A table of i/o routines that an endpoint interface can implement"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_io_routines {
    #[doc = " creates an outgoing session from given session, caller profile"]
    pub outgoing_channel: switch_io_outgoing_channel_t,
    #[doc = " read a frame from a session"]
    pub read_frame: switch_io_read_frame_t,
    #[doc = " write a frame to a session"]
    pub write_frame: switch_io_write_frame_t,
    #[doc = " send a kill signal to the session's channel"]
    pub kill_channel: switch_io_kill_channel_t,
    #[doc = " send a string of DTMF digits to a session's channel"]
    pub send_dtmf: switch_io_send_dtmf_t,
    #[doc = " receive a message from another session"]
    pub receive_message: switch_io_receive_message_t,
    #[doc = " queue a message for another session"]
    pub receive_event: switch_io_receive_event_t,
    #[doc = " change a sessions channel state"]
    pub state_change: switch_io_state_change_t,
    #[doc = " read a video frame from a session"]
    pub read_video_frame: switch_io_read_video_frame_t,
    #[doc = " write a video frame to a session"]
    pub write_video_frame: switch_io_write_video_frame_t,
    #[doc = " read a video frame from a session"]
    pub read_text_frame: switch_io_read_text_frame_t,
    #[doc = " write a video frame to a session"]
    pub write_text_frame: switch_io_write_text_frame_t,
    #[doc = " change a sessions channel run state"]
    pub state_run: switch_io_state_run_t,
    #[doc = " get sessions jitterbuffer"]
    pub get_jb: switch_io_get_jb_t,
    pub padding: [*mut ::std::os::raw::c_void; 10usize],
}
#[test]
fn bindgen_test_layout_switch_io_routines() {
    const UNINIT: ::std::mem::MaybeUninit<switch_io_routines> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_io_routines>(),
        192usize,
        concat!("Size of: ", stringify!(switch_io_routines))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_io_routines>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_io_routines))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outgoing_channel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_routines),
            "::",
            stringify!(outgoing_channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_frame) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_routines),
            "::",
            stringify!(read_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_frame) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_routines),
            "::",
            stringify!(write_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kill_channel) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_routines),
            "::",
            stringify!(kill_channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).send_dtmf) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_routines),
            "::",
            stringify!(send_dtmf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receive_message) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_routines),
            "::",
            stringify!(receive_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receive_event) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_routines),
            "::",
            stringify!(receive_event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state_change) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_routines),
            "::",
            stringify!(state_change)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_video_frame) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_routines),
            "::",
            stringify!(read_video_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_video_frame) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_routines),
            "::",
            stringify!(write_video_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_text_frame) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_routines),
            "::",
            stringify!(read_text_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_text_frame) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_routines),
            "::",
            stringify!(write_text_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state_run) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_routines),
            "::",
            stringify!(state_run)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_jb) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_routines),
            "::",
            stringify!(get_jb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_routines),
            "::",
            stringify!(padding)
        )
    );
}
#[doc = " \\brief Abstraction of an module endpoint interface\nThis is the glue between the abstract idea of a \"channel\" and what is really going on under the\nhood.\t Each endpoint module fills out one of these tables and makes it available when a channel\nis created of it's paticular type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_endpoint_interface {
    #[doc = " the interface's name"]
    pub interface_name: *const ::std::os::raw::c_char,
    #[doc = " channel abstraction methods"]
    pub io_routines: *mut switch_io_routines_t,
    #[doc = " state machine methods"]
    pub state_handler: *mut switch_state_handler_table_t,
    #[doc = " private information"]
    pub private_info: *mut ::std::os::raw::c_void,
    pub rwlock: *mut switch_thread_rwlock_t,
    pub refs: ::std::os::raw::c_int,
    pub reflock: *mut switch_mutex_t,
    pub parent: *mut switch_loadable_module_interface_t,
    pub next: *mut switch_endpoint_interface,
    pub recover_callback: switch_core_recover_callback_t,
}
#[test]
fn bindgen_test_layout_switch_endpoint_interface() {
    const UNINIT: ::std::mem::MaybeUninit<switch_endpoint_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_endpoint_interface>(),
        80usize,
        concat!("Size of: ", stringify!(switch_endpoint_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_endpoint_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_endpoint_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_endpoint_interface),
            "::",
            stringify!(interface_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_routines) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_endpoint_interface),
            "::",
            stringify!(io_routines)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state_handler) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_endpoint_interface),
            "::",
            stringify!(state_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_info) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_endpoint_interface),
            "::",
            stringify!(private_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rwlock) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_endpoint_interface),
            "::",
            stringify!(rwlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refs) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_endpoint_interface),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reflock) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_endpoint_interface),
            "::",
            stringify!(reflock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_endpoint_interface),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_endpoint_interface),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recover_callback) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_endpoint_interface),
            "::",
            stringify!(recover_callback)
        )
    );
}
#[doc = " \\brief Abstract handler to a timer module"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_timer {
    #[doc = " time interval expressed in milliseconds"]
    pub interval: ::std::os::raw::c_int,
    #[doc = " flags to control behaviour"]
    pub flags: u32,
    #[doc = " sample count to increment by on each cycle"]
    pub samples: ::std::os::raw::c_uint,
    #[doc = " current sample count based on samples parameter"]
    pub samplecount: u32,
    pub last_samplecount: u32,
    #[doc = " the timer interface provided from a loadable module"]
    pub timer_interface: *mut switch_timer_interface_t,
    #[doc = " the timer's memory pool"]
    pub memory_pool: *mut switch_memory_pool_t,
    #[doc = " private data for loadable modules to store information"]
    pub private_info: *mut ::std::os::raw::c_void,
    #[doc = " remaining time from last call to _check()"]
    pub diff: switch_size_t,
    pub start: switch_time_t,
    pub tick: u64,
}
#[test]
fn bindgen_test_layout_switch_timer() {
    const UNINIT: ::std::mem::MaybeUninit<switch_timer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_timer>(),
        72usize,
        concat!("Size of: ", stringify!(switch_timer))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_timer>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_timer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_timer),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_timer),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samples) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_timer),
            "::",
            stringify!(samples)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samplecount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_timer),
            "::",
            stringify!(samplecount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_samplecount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_timer),
            "::",
            stringify!(last_samplecount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timer_interface) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_timer),
            "::",
            stringify!(timer_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory_pool) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_timer),
            "::",
            stringify!(memory_pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_info) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_timer),
            "::",
            stringify!(private_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).diff) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_timer),
            "::",
            stringify!(diff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_timer),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tick) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_timer),
            "::",
            stringify!(tick)
        )
    );
}
pub const switch_timer_func_name_t_SWITCH_TIMER_FUNC_TIMER_INIT: switch_timer_func_name_t = 0;
pub const switch_timer_func_name_t_SWITCH_TIMER_FUNC_TIMER_NEXT: switch_timer_func_name_t = 1;
pub const switch_timer_func_name_t_SWITCH_TIMER_FUNC_TIMER_STEP: switch_timer_func_name_t = 2;
pub const switch_timer_func_name_t_SWITCH_TIMER_FUNC_TIMER_SYNC: switch_timer_func_name_t = 3;
pub const switch_timer_func_name_t_SWITCH_TIMER_FUNC_TIMER_CHECK: switch_timer_func_name_t = 4;
pub const switch_timer_func_name_t_SWITCH_TIMER_FUNC_TIMER_DESTROY: switch_timer_func_name_t = 5;
pub type switch_timer_func_name_t = ::std::os::raw::c_uint;
#[doc = " \\brief A table of functions that a timer module implements"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_timer_interface {
    #[doc = " the name of the interface"]
    pub interface_name: *const ::std::os::raw::c_char,
    #[doc = " function to allocate the timer"]
    pub timer_init:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut switch_timer_t) -> switch_status_t>,
    #[doc = " function to wait for one cycle to pass"]
    pub timer_next:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut switch_timer_t) -> switch_status_t>,
    #[doc = " function to step the timer one step"]
    pub timer_step:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut switch_timer_t) -> switch_status_t>,
    #[doc = " function to reset the timer"]
    pub timer_sync:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut switch_timer_t) -> switch_status_t>,
    #[doc = " function to check if the current step has expired"]
    pub timer_check: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut switch_timer_t, arg2: switch_bool_t) -> switch_status_t,
    >,
    #[doc = " function to deallocate the timer"]
    pub timer_destroy:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut switch_timer_t) -> switch_status_t>,
    pub rwlock: *mut switch_thread_rwlock_t,
    pub refs: ::std::os::raw::c_int,
    pub reflock: *mut switch_mutex_t,
    pub parent: *mut switch_loadable_module_interface_t,
    pub next: *mut switch_timer_interface,
}
#[test]
fn bindgen_test_layout_switch_timer_interface() {
    const UNINIT: ::std::mem::MaybeUninit<switch_timer_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_timer_interface>(),
        96usize,
        concat!("Size of: ", stringify!(switch_timer_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_timer_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_timer_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_timer_interface),
            "::",
            stringify!(interface_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timer_init) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_timer_interface),
            "::",
            stringify!(timer_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timer_next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_timer_interface),
            "::",
            stringify!(timer_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timer_step) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_timer_interface),
            "::",
            stringify!(timer_step)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timer_sync) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_timer_interface),
            "::",
            stringify!(timer_sync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timer_check) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_timer_interface),
            "::",
            stringify!(timer_check)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timer_destroy) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_timer_interface),
            "::",
            stringify!(timer_destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rwlock) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_timer_interface),
            "::",
            stringify!(rwlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refs) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_timer_interface),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reflock) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_timer_interface),
            "::",
            stringify!(reflock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_timer_interface),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_timer_interface),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " \\brief Abstract interface to a dialplan module"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_dialplan_interface {
    #[doc = " the name of the interface"]
    pub interface_name: *const ::std::os::raw::c_char,
    #[doc = " the function to read an extension and set a channels dialpan"]
    pub hunt_function: switch_dialplan_hunt_function_t,
    pub rwlock: *mut switch_thread_rwlock_t,
    pub refs: ::std::os::raw::c_int,
    pub reflock: *mut switch_mutex_t,
    pub parent: *mut switch_loadable_module_interface_t,
    pub next: *mut switch_dialplan_interface,
}
#[test]
fn bindgen_test_layout_switch_dialplan_interface() {
    const UNINIT: ::std::mem::MaybeUninit<switch_dialplan_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_dialplan_interface>(),
        56usize,
        concat!("Size of: ", stringify!(switch_dialplan_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_dialplan_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_dialplan_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_dialplan_interface),
            "::",
            stringify!(interface_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hunt_function) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_dialplan_interface),
            "::",
            stringify!(hunt_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rwlock) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_dialplan_interface),
            "::",
            stringify!(rwlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_dialplan_interface),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reflock) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_dialplan_interface),
            "::",
            stringify!(reflock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_dialplan_interface),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_dialplan_interface),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " \\brief Abstract interface to a file format module"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_file_interface {
    #[doc = " the name of the interface"]
    pub interface_name: *const ::std::os::raw::c_char,
    #[doc = " function to open the file"]
    pub file_open: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut switch_file_handle_t,
            file_path: *const ::std::os::raw::c_char,
        ) -> switch_status_t,
    >,
    #[doc = " function to close the file"]
    pub file_close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut switch_file_handle_t) -> switch_status_t,
    >,
    #[doc = " function to close the file"]
    pub file_truncate: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut switch_file_handle_t, offset: i64) -> switch_status_t,
    >,
    #[doc = " function to read from the file"]
    pub file_read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut switch_file_handle_t,
            data: *mut ::std::os::raw::c_void,
            len: *mut switch_size_t,
        ) -> switch_status_t,
    >,
    #[doc = " function to write from the file"]
    pub file_write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut switch_file_handle_t,
            data: *mut ::std::os::raw::c_void,
            len: *mut switch_size_t,
        ) -> switch_status_t,
    >,
    #[doc = " function to seek to a certian position in the file"]
    pub file_read_video: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut switch_file_handle_t,
            frame: *mut switch_frame_t,
            flags: switch_video_read_flag_t,
        ) -> switch_status_t,
    >,
    #[doc = " function to write from the file"]
    pub file_write_video: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut switch_file_handle_t,
            frame: *mut switch_frame_t,
        ) -> switch_status_t,
    >,
    #[doc = " function to seek to a certian position in the file"]
    pub file_seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut switch_file_handle_t,
            cur_pos: *mut ::std::os::raw::c_uint,
            samples: i64,
            whence: ::std::os::raw::c_int,
        ) -> switch_status_t,
    >,
    #[doc = " function to set meta data"]
    pub file_set_string: ::std::option::Option<
        unsafe extern "C" fn(
            fh: *mut switch_file_handle_t,
            col: switch_audio_col_t,
            string: *const ::std::os::raw::c_char,
        ) -> switch_status_t,
    >,
    #[doc = " function to get meta data"]
    pub file_get_string: ::std::option::Option<
        unsafe extern "C" fn(
            fh: *mut switch_file_handle_t,
            col: switch_audio_col_t,
            string: *mut *const ::std::os::raw::c_char,
        ) -> switch_status_t,
    >,
    #[doc = " function to pre close the file to read params"]
    pub file_pre_close: ::std::option::Option<
        unsafe extern "C" fn(fh: *mut switch_file_handle_t) -> switch_status_t,
    >,
    #[doc = " function to control the underlying tech of the file"]
    pub file_command: ::std::option::Option<
        unsafe extern "C" fn(
            fh: *mut switch_file_handle_t,
            command: switch_file_command_t,
        ) -> switch_status_t,
    >,
    #[doc = " list of supported file extensions"]
    pub extens: *mut *mut ::std::os::raw::c_char,
    pub rwlock: *mut switch_thread_rwlock_t,
    pub refs: ::std::os::raw::c_int,
    pub reflock: *mut switch_mutex_t,
    pub parent: *mut switch_loadable_module_interface_t,
    pub next: *mut switch_file_interface,
}
#[test]
fn bindgen_test_layout_switch_file_interface() {
    const UNINIT: ::std::mem::MaybeUninit<switch_file_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_file_interface>(),
        152usize,
        concat!("Size of: ", stringify!(switch_file_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_file_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_file_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_interface),
            "::",
            stringify!(interface_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_open) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_interface),
            "::",
            stringify!(file_open)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_close) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_interface),
            "::",
            stringify!(file_close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_truncate) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_interface),
            "::",
            stringify!(file_truncate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_read) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_interface),
            "::",
            stringify!(file_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_write) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_interface),
            "::",
            stringify!(file_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_read_video) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_interface),
            "::",
            stringify!(file_read_video)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_write_video) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_interface),
            "::",
            stringify!(file_write_video)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_seek) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_interface),
            "::",
            stringify!(file_seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_set_string) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_interface),
            "::",
            stringify!(file_set_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_get_string) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_interface),
            "::",
            stringify!(file_get_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_pre_close) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_interface),
            "::",
            stringify!(file_pre_close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_command) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_interface),
            "::",
            stringify!(file_command)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extens) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_interface),
            "::",
            stringify!(extens)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rwlock) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_interface),
            "::",
            stringify!(rwlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refs) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_interface),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reflock) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_interface),
            "::",
            stringify!(reflock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_interface),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_interface),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " an abstract representation of a file handle (some parameters based on compat with libsndfile)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_file_handle {
    #[doc = " the interface of the module that implemented the current file type"]
    pub file_interface: *mut switch_file_interface_t,
    #[doc = " flags to control behaviour"]
    pub flags: u32,
    #[doc = " a file descriptor if neceessary"]
    pub fd: *mut switch_file_t,
    #[doc = " samples position of the handle"]
    pub samples: ::std::os::raw::c_uint,
    #[doc = " the current samplerate"]
    pub samplerate: u32,
    #[doc = " the current native samplerate"]
    pub native_rate: u32,
    #[doc = " the number of channels"]
    pub channels: u32,
    pub real_channels: u32,
    #[doc = " integer representation of the format"]
    pub format: ::std::os::raw::c_uint,
    #[doc = " integer representation of the sections"]
    pub sections: ::std::os::raw::c_uint,
    #[doc = " is the file seekable"]
    pub seekable: ::std::os::raw::c_int,
    #[doc = " the sample count of the file"]
    pub sample_count: switch_size_t,
    #[doc = " the speed of the file playback"]
    pub speed: ::std::os::raw::c_int,
    #[doc = " the handle's memory pool"]
    pub memory_pool: *mut switch_memory_pool_t,
    #[doc = " pre-buffer x bytes for streams"]
    pub prebuf: u32,
    #[doc = " private data for the format module to store handle specific info"]
    pub interval: u32,
    pub private_info: *mut ::std::os::raw::c_void,
    pub handler: *mut ::std::os::raw::c_char,
    pub pos: i64,
    pub audio_buffer: *mut switch_buffer_t,
    pub sp_audio_buffer: *mut switch_buffer_t,
    pub thresh: u32,
    pub silence_hits: u32,
    pub offset_pos: u32,
    pub samples_in: switch_size_t,
    pub samples_out: switch_size_t,
    pub vol: i32,
    pub volgranular: i32,
    pub resampler: *mut switch_audio_resampler_t,
    pub buffer: *mut switch_buffer_t,
    pub dbuf: *mut switch_byte_t,
    pub dbuflen: switch_size_t,
    pub pre_buffer: *mut switch_buffer_t,
    pub pre_buffer_data: *mut ::std::os::raw::c_uchar,
    pub pre_buffer_datalen: switch_size_t,
    pub file: *const ::std::os::raw::c_char,
    pub func: *const ::std::os::raw::c_char,
    pub line: ::std::os::raw::c_int,
    pub file_path: *mut ::std::os::raw::c_char,
    pub spool_path: *mut ::std::os::raw::c_char,
    pub prefix: *const ::std::os::raw::c_char,
    pub max_samples: ::std::os::raw::c_int,
    pub params: *mut switch_event_t,
    pub cur_channels: u32,
    pub cur_samplerate: u32,
    pub stream_name: *mut ::std::os::raw::c_char,
    pub modname: *mut ::std::os::raw::c_char,
    pub mm: switch_mm_t,
    pub flag_mutex: *mut switch_mutex_t,
    #[doc = " total video duration, or total page in pdf"]
    pub duration: i64,
    #[doc = " current video position, or current page in pdf"]
    pub vpos: i64,
    pub muxbuf: *mut ::std::os::raw::c_void,
    pub muxlen: switch_size_t,
}
#[test]
fn bindgen_test_layout_switch_file_handle() {
    const UNINIT: ::std::mem::MaybeUninit<switch_file_handle> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_file_handle>(),
        440usize,
        concat!("Size of: ", stringify!(switch_file_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_file_handle>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_file_handle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_interface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(file_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samples) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(samples)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samplerate) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(samplerate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).native_rate) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(native_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).real_channels) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(real_channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sections) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(sections)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seekable) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(seekable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sample_count) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(sample_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speed) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(speed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory_pool) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(memory_pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prebuf) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(prebuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interval) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_info) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(private_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handler) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audio_buffer) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(audio_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sp_audio_buffer) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(sp_audio_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thresh) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(thresh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).silence_hits) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(silence_hits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset_pos) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(offset_pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samples_in) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(samples_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samples_out) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(samples_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vol) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(vol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).volgranular) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(volgranular)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resampler) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(resampler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dbuf) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(dbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dbuflen) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(dbuflen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pre_buffer) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(pre_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pre_buffer_data) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(pre_buffer_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pre_buffer_datalen) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(pre_buffer_datalen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_path) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(file_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spool_path) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(spool_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefix) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(prefix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_samples) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(max_samples)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cur_channels) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(cur_channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cur_samplerate) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(cur_samplerate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_name) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(stream_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modname) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(modname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mm) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(mm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flag_mutex) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(flag_mutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duration) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vpos) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(vpos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).muxbuf) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(muxbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).muxlen) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_file_handle),
            "::",
            stringify!(muxlen)
        )
    );
}
#[doc = " \\brief Abstract interface to an asr module"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_asr_interface {
    #[doc = " the name of the interface"]
    pub interface_name: *const ::std::os::raw::c_char,
    #[doc = " function to open the asr interface"]
    pub asr_open: ::std::option::Option<
        unsafe extern "C" fn(
            ah: *mut switch_asr_handle_t,
            codec: *const ::std::os::raw::c_char,
            rate: ::std::os::raw::c_int,
            dest: *const ::std::os::raw::c_char,
            flags: *mut switch_asr_flag_t,
        ) -> switch_status_t,
    >,
    #[doc = " function to load a grammar to the asr interface"]
    pub asr_load_grammar: ::std::option::Option<
        unsafe extern "C" fn(
            ah: *mut switch_asr_handle_t,
            grammar: *const ::std::os::raw::c_char,
            name: *const ::std::os::raw::c_char,
        ) -> switch_status_t,
    >,
    #[doc = " function to unload a grammar to the asr interface"]
    pub asr_unload_grammar: ::std::option::Option<
        unsafe extern "C" fn(
            ah: *mut switch_asr_handle_t,
            name: *const ::std::os::raw::c_char,
        ) -> switch_status_t,
    >,
    #[doc = " function to close the asr interface"]
    pub asr_close: ::std::option::Option<
        unsafe extern "C" fn(
            ah: *mut switch_asr_handle_t,
            flags: *mut switch_asr_flag_t,
        ) -> switch_status_t,
    >,
    #[doc = " function to feed audio to the ASR"]
    pub asr_feed: ::std::option::Option<
        unsafe extern "C" fn(
            ah: *mut switch_asr_handle_t,
            data: *mut ::std::os::raw::c_void,
            len: ::std::os::raw::c_uint,
            flags: *mut switch_asr_flag_t,
        ) -> switch_status_t,
    >,
    #[doc = " function to resume the ASR"]
    pub asr_resume: ::std::option::Option<
        unsafe extern "C" fn(ah: *mut switch_asr_handle_t) -> switch_status_t,
    >,
    #[doc = " function to pause the ASR"]
    pub asr_pause: ::std::option::Option<
        unsafe extern "C" fn(ah: *mut switch_asr_handle_t) -> switch_status_t,
    >,
    #[doc = " function to read results from the ASR"]
    pub asr_check_results: ::std::option::Option<
        unsafe extern "C" fn(
            ah: *mut switch_asr_handle_t,
            flags: *mut switch_asr_flag_t,
        ) -> switch_status_t,
    >,
    #[doc = " function to read results from the ASR"]
    pub asr_get_results: ::std::option::Option<
        unsafe extern "C" fn(
            ah: *mut switch_asr_handle_t,
            xmlstr: *mut *mut ::std::os::raw::c_char,
            flags: *mut switch_asr_flag_t,
        ) -> switch_status_t,
    >,
    #[doc = " function to read result headers from the ASR"]
    pub asr_get_result_headers: ::std::option::Option<
        unsafe extern "C" fn(
            ah: *mut switch_asr_handle_t,
            headers: *mut *mut switch_event_t,
            flags: *mut switch_asr_flag_t,
        ) -> switch_status_t,
    >,
    #[doc = " function to start ASR input timers"]
    pub asr_start_input_timers: ::std::option::Option<
        unsafe extern "C" fn(ah: *mut switch_asr_handle_t) -> switch_status_t,
    >,
    pub asr_text_param: ::std::option::Option<
        unsafe extern "C" fn(
            ah: *mut switch_asr_handle_t,
            param: *mut ::std::os::raw::c_char,
            val: *const ::std::os::raw::c_char,
        ),
    >,
    pub asr_numeric_param: ::std::option::Option<
        unsafe extern "C" fn(
            ah: *mut switch_asr_handle_t,
            param: *mut ::std::os::raw::c_char,
            val: ::std::os::raw::c_int,
        ),
    >,
    pub asr_float_param: ::std::option::Option<
        unsafe extern "C" fn(
            ah: *mut switch_asr_handle_t,
            param: *mut ::std::os::raw::c_char,
            val: f64,
        ),
    >,
    pub rwlock: *mut switch_thread_rwlock_t,
    pub refs: ::std::os::raw::c_int,
    pub reflock: *mut switch_mutex_t,
    pub parent: *mut switch_loadable_module_interface_t,
    pub next: *mut switch_asr_interface,
    #[doc = " function to enable a grammar to the asr interface"]
    pub asr_enable_grammar: ::std::option::Option<
        unsafe extern "C" fn(
            ah: *mut switch_asr_handle_t,
            name: *const ::std::os::raw::c_char,
        ) -> switch_status_t,
    >,
    #[doc = " function to disable a grammar to the asr interface"]
    pub asr_disable_grammar: ::std::option::Option<
        unsafe extern "C" fn(
            ah: *mut switch_asr_handle_t,
            name: *const ::std::os::raw::c_char,
        ) -> switch_status_t,
    >,
    #[doc = " function to disable all grammars to the asr interface"]
    pub asr_disable_all_grammars: ::std::option::Option<
        unsafe extern "C" fn(ah: *mut switch_asr_handle_t) -> switch_status_t,
    >,
    #[doc = " function to feed DTMF to the ASR"]
    pub asr_feed_dtmf: ::std::option::Option<
        unsafe extern "C" fn(
            ah: *mut switch_asr_handle_t,
            dtmf: *const switch_dtmf_t,
            flags: *mut switch_asr_flag_t,
        ) -> switch_status_t,
    >,
}
#[test]
fn bindgen_test_layout_switch_asr_interface() {
    const UNINIT: ::std::mem::MaybeUninit<switch_asr_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_asr_interface>(),
        192usize,
        concat!("Size of: ", stringify!(switch_asr_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_asr_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_asr_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_interface),
            "::",
            stringify!(interface_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asr_open) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_interface),
            "::",
            stringify!(asr_open)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asr_load_grammar) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_interface),
            "::",
            stringify!(asr_load_grammar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asr_unload_grammar) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_interface),
            "::",
            stringify!(asr_unload_grammar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asr_close) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_interface),
            "::",
            stringify!(asr_close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asr_feed) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_interface),
            "::",
            stringify!(asr_feed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asr_resume) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_interface),
            "::",
            stringify!(asr_resume)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asr_pause) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_interface),
            "::",
            stringify!(asr_pause)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asr_check_results) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_interface),
            "::",
            stringify!(asr_check_results)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asr_get_results) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_interface),
            "::",
            stringify!(asr_get_results)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asr_get_result_headers) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_interface),
            "::",
            stringify!(asr_get_result_headers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asr_start_input_timers) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_interface),
            "::",
            stringify!(asr_start_input_timers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asr_text_param) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_interface),
            "::",
            stringify!(asr_text_param)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asr_numeric_param) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_interface),
            "::",
            stringify!(asr_numeric_param)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asr_float_param) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_interface),
            "::",
            stringify!(asr_float_param)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rwlock) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_interface),
            "::",
            stringify!(rwlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refs) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_interface),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reflock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_interface),
            "::",
            stringify!(reflock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_interface),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_interface),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asr_enable_grammar) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_interface),
            "::",
            stringify!(asr_enable_grammar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asr_disable_grammar) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_interface),
            "::",
            stringify!(asr_disable_grammar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asr_disable_all_grammars) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_interface),
            "::",
            stringify!(asr_disable_all_grammars)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asr_feed_dtmf) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_interface),
            "::",
            stringify!(asr_feed_dtmf)
        )
    );
}
#[doc = " an abstract representation of an asr speech interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_asr_handle {
    #[doc = " the interface of the module that implemented the current speech interface"]
    pub asr_interface: *mut switch_asr_interface_t,
    #[doc = " flags to control behaviour"]
    pub flags: u32,
    #[doc = " The Name"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = " The Codec"]
    pub codec: *mut ::std::os::raw::c_char,
    #[doc = " The Rate"]
    pub rate: u32,
    pub grammar: *mut ::std::os::raw::c_char,
    #[doc = " module specific param"]
    pub param: *mut ::std::os::raw::c_char,
    #[doc = " the handle's memory pool"]
    pub memory_pool: *mut switch_memory_pool_t,
    pub buffer: *mut switch_buffer_t,
    pub dbuf: *mut switch_byte_t,
    pub dbuflen: switch_size_t,
    pub resampler: *mut switch_audio_resampler_t,
    #[doc = " the current samplerate"]
    pub samplerate: u32,
    #[doc = " the current native samplerate"]
    pub native_rate: u32,
    #[doc = " private data for the format module to store handle specific info"]
    pub private_info: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_switch_asr_handle() {
    const UNINIT: ::std::mem::MaybeUninit<switch_asr_handle> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_asr_handle>(),
        112usize,
        concat!("Size of: ", stringify!(switch_asr_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_asr_handle>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_asr_handle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asr_interface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_handle),
            "::",
            stringify!(asr_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_handle),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_handle),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_handle),
            "::",
            stringify!(codec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_handle),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).grammar) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_handle),
            "::",
            stringify!(grammar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).param) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_handle),
            "::",
            stringify!(param)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory_pool) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_handle),
            "::",
            stringify!(memory_pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_handle),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dbuf) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_handle),
            "::",
            stringify!(dbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dbuflen) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_handle),
            "::",
            stringify!(dbuflen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resampler) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_handle),
            "::",
            stringify!(resampler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samplerate) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_handle),
            "::",
            stringify!(samplerate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).native_rate) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_handle),
            "::",
            stringify!(native_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_info) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_asr_handle),
            "::",
            stringify!(private_info)
        )
    );
}
#[doc = " \\brief Abstract interface to a speech module"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_speech_interface {
    #[doc = " the name of the interface"]
    pub interface_name: *const ::std::os::raw::c_char,
    #[doc = " function to open the speech interface"]
    pub speech_open: ::std::option::Option<
        unsafe extern "C" fn(
            sh: *mut switch_speech_handle_t,
            voice_name: *const ::std::os::raw::c_char,
            rate: ::std::os::raw::c_int,
            channels: ::std::os::raw::c_int,
            flags: *mut switch_speech_flag_t,
        ) -> switch_status_t,
    >,
    #[doc = " function to close the speech interface"]
    pub speech_close: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut switch_speech_handle_t,
            flags: *mut switch_speech_flag_t,
        ) -> switch_status_t,
    >,
    #[doc = " function to feed audio to the ASR"]
    pub speech_feed_tts: ::std::option::Option<
        unsafe extern "C" fn(
            sh: *mut switch_speech_handle_t,
            text: *mut ::std::os::raw::c_char,
            flags: *mut switch_speech_flag_t,
        ) -> switch_status_t,
    >,
    #[doc = " function to read audio from the TTS"]
    pub speech_read_tts: ::std::option::Option<
        unsafe extern "C" fn(
            sh: *mut switch_speech_handle_t,
            data: *mut ::std::os::raw::c_void,
            datalen: *mut switch_size_t,
            flags: *mut switch_speech_flag_t,
        ) -> switch_status_t,
    >,
    pub speech_flush_tts:
        ::std::option::Option<unsafe extern "C" fn(sh: *mut switch_speech_handle_t)>,
    pub speech_text_param_tts: ::std::option::Option<
        unsafe extern "C" fn(
            sh: *mut switch_speech_handle_t,
            param: *mut ::std::os::raw::c_char,
            val: *const ::std::os::raw::c_char,
        ),
    >,
    pub speech_numeric_param_tts: ::std::option::Option<
        unsafe extern "C" fn(
            sh: *mut switch_speech_handle_t,
            param: *mut ::std::os::raw::c_char,
            val: ::std::os::raw::c_int,
        ),
    >,
    pub speech_float_param_tts: ::std::option::Option<
        unsafe extern "C" fn(
            sh: *mut switch_speech_handle_t,
            param: *mut ::std::os::raw::c_char,
            val: f64,
        ),
    >,
    pub rwlock: *mut switch_thread_rwlock_t,
    pub refs: ::std::os::raw::c_int,
    pub reflock: *mut switch_mutex_t,
    pub parent: *mut switch_loadable_module_interface_t,
    pub next: *mut switch_speech_interface,
}
#[test]
fn bindgen_test_layout_switch_speech_interface() {
    const UNINIT: ::std::mem::MaybeUninit<switch_speech_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_speech_interface>(),
        112usize,
        concat!("Size of: ", stringify!(switch_speech_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_speech_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_speech_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_interface),
            "::",
            stringify!(interface_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speech_open) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_interface),
            "::",
            stringify!(speech_open)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speech_close) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_interface),
            "::",
            stringify!(speech_close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speech_feed_tts) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_interface),
            "::",
            stringify!(speech_feed_tts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speech_read_tts) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_interface),
            "::",
            stringify!(speech_read_tts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speech_flush_tts) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_interface),
            "::",
            stringify!(speech_flush_tts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speech_text_param_tts) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_interface),
            "::",
            stringify!(speech_text_param_tts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speech_numeric_param_tts) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_interface),
            "::",
            stringify!(speech_numeric_param_tts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speech_float_param_tts) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_interface),
            "::",
            stringify!(speech_float_param_tts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rwlock) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_interface),
            "::",
            stringify!(rwlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refs) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_interface),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reflock) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_interface),
            "::",
            stringify!(reflock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_interface),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_interface),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " an abstract representation of a tts speech interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_speech_handle {
    #[doc = " the interface of the module that implemented the current speech interface"]
    pub speech_interface: *mut switch_speech_interface_t,
    #[doc = " flags to control behaviour"]
    pub flags: u32,
    #[doc = " The Name"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = " The Rate"]
    pub rate: u32,
    pub speed: u32,
    pub samples: u32,
    pub channels: u32,
    pub real_channels: u32,
    pub voice: [::std::os::raw::c_char; 80usize],
    pub engine: *mut ::std::os::raw::c_char,
    #[doc = " module specific param"]
    pub param: *mut ::std::os::raw::c_char,
    #[doc = " the handle's memory pool"]
    pub memory_pool: *mut switch_memory_pool_t,
    pub resampler: *mut switch_audio_resampler_t,
    pub buffer: *mut switch_buffer_t,
    pub dbuf: *mut switch_byte_t,
    pub dbuflen: switch_size_t,
    #[doc = " the current samplerate"]
    pub samplerate: u32,
    #[doc = " the current native samplerate"]
    pub native_rate: u32,
    #[doc = " private data for the format module to store handle specific info"]
    pub private_info: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_switch_speech_handle() {
    const UNINIT: ::std::mem::MaybeUninit<switch_speech_handle> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_speech_handle>(),
        200usize,
        concat!("Size of: ", stringify!(switch_speech_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_speech_handle>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_speech_handle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speech_interface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_handle),
            "::",
            stringify!(speech_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_handle),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_handle),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_handle),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speed) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_handle),
            "::",
            stringify!(speed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samples) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_handle),
            "::",
            stringify!(samples)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_handle),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).real_channels) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_handle),
            "::",
            stringify!(real_channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).voice) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_handle),
            "::",
            stringify!(voice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).engine) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_handle),
            "::",
            stringify!(engine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).param) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_handle),
            "::",
            stringify!(param)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory_pool) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_handle),
            "::",
            stringify!(memory_pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resampler) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_handle),
            "::",
            stringify!(resampler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_handle),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dbuf) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_handle),
            "::",
            stringify!(dbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dbuflen) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_handle),
            "::",
            stringify!(dbuflen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samplerate) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_handle),
            "::",
            stringify!(samplerate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).native_rate) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_handle),
            "::",
            stringify!(native_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_info) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_speech_handle),
            "::",
            stringify!(private_info)
        )
    );
}
#[doc = " \\brief Abstract interface to a say module"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_say_interface {
    #[doc = " the name of the interface"]
    pub interface_name: *const ::std::os::raw::c_char,
    #[doc = " function to pass down to the module"]
    pub say_function: switch_say_callback_t,
    pub say_string_function: switch_say_string_callback_t,
    pub rwlock: *mut switch_thread_rwlock_t,
    pub refs: ::std::os::raw::c_int,
    pub reflock: *mut switch_mutex_t,
    pub parent: *mut switch_loadable_module_interface_t,
    pub next: *mut switch_say_interface,
}
#[test]
fn bindgen_test_layout_switch_say_interface() {
    const UNINIT: ::std::mem::MaybeUninit<switch_say_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_say_interface>(),
        64usize,
        concat!("Size of: ", stringify!(switch_say_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_say_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_say_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_say_interface),
            "::",
            stringify!(interface_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).say_function) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_say_interface),
            "::",
            stringify!(say_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).say_string_function) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_say_interface),
            "::",
            stringify!(say_string_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rwlock) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_say_interface),
            "::",
            stringify!(rwlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refs) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_say_interface),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reflock) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_say_interface),
            "::",
            stringify!(reflock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_say_interface),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_say_interface),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " \\brief Abstract interface to a chat module"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_chat_interface {
    #[doc = " the name of the interface"]
    pub interface_name: *const ::std::os::raw::c_char,
    #[doc = " function to open the directory interface"]
    pub chat_send: ::std::option::Option<
        unsafe extern "C" fn(message_event: *mut switch_event_t) -> switch_status_t,
    >,
    pub rwlock: *mut switch_thread_rwlock_t,
    pub refs: ::std::os::raw::c_int,
    pub reflock: *mut switch_mutex_t,
    pub parent: *mut switch_loadable_module_interface_t,
    pub next: *mut switch_chat_interface,
}
#[test]
fn bindgen_test_layout_switch_chat_interface() {
    const UNINIT: ::std::mem::MaybeUninit<switch_chat_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_chat_interface>(),
        56usize,
        concat!("Size of: ", stringify!(switch_chat_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_chat_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_chat_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_chat_interface),
            "::",
            stringify!(interface_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chat_send) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_chat_interface),
            "::",
            stringify!(chat_send)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rwlock) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_chat_interface),
            "::",
            stringify!(rwlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_chat_interface),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reflock) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_chat_interface),
            "::",
            stringify!(reflock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_chat_interface),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_chat_interface),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " \\brief Abstract interface to a management module"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_management_interface {
    #[doc = " the name of the interface"]
    pub relative_oid: *const ::std::os::raw::c_char,
    #[doc = " function to open the directory interface"]
    pub management_function: ::std::option::Option<
        unsafe extern "C" fn(
            relative_oid: *mut ::std::os::raw::c_char,
            action: switch_management_action_t,
            data: *mut ::std::os::raw::c_char,
            datalen: switch_size_t,
        ) -> switch_status_t,
    >,
    pub rwlock: *mut switch_thread_rwlock_t,
    pub refs: ::std::os::raw::c_int,
    pub reflock: *mut switch_mutex_t,
    pub parent: *mut switch_loadable_module_interface_t,
    pub next: *mut switch_management_interface,
}
#[test]
fn bindgen_test_layout_switch_management_interface() {
    const UNINIT: ::std::mem::MaybeUninit<switch_management_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_management_interface>(),
        56usize,
        concat!("Size of: ", stringify!(switch_management_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_management_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_management_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).relative_oid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_management_interface),
            "::",
            stringify!(relative_oid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).management_function) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_management_interface),
            "::",
            stringify!(management_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rwlock) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_management_interface),
            "::",
            stringify!(rwlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_management_interface),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reflock) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_management_interface),
            "::",
            stringify!(reflock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_management_interface),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_management_interface),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " \\brief Abstract interface to a limit module"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_limit_interface {
    #[doc = " name of the interface"]
    pub interface_name: *const ::std::os::raw::c_char,
    #[doc = " increment"]
    pub incr: ::std::option::Option<
        unsafe extern "C" fn(
            session: *mut switch_core_session_t,
            realm: *const ::std::os::raw::c_char,
            resource: *const ::std::os::raw::c_char,
            max: ::std::os::raw::c_int,
            interval: ::std::os::raw::c_int,
        ) -> switch_status_t,
    >,
    #[doc = " release"]
    pub release: ::std::option::Option<
        unsafe extern "C" fn(
            session: *mut switch_core_session_t,
            realm: *const ::std::os::raw::c_char,
            resource: *const ::std::os::raw::c_char,
        ) -> switch_status_t,
    >,
    #[doc = " usage for resource"]
    pub usage: ::std::option::Option<
        unsafe extern "C" fn(
            realm: *const ::std::os::raw::c_char,
            resource: *const ::std::os::raw::c_char,
            rcount: *mut u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " reset counters"]
    pub reset: ::std::option::Option<unsafe extern "C" fn() -> switch_status_t>,
    #[doc = " freform status"]
    pub status: ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_char>,
    #[doc = " reset interval counter"]
    pub interval_reset: ::std::option::Option<
        unsafe extern "C" fn(
            realm: *const ::std::os::raw::c_char,
            resource: *const ::std::os::raw::c_char,
        ) -> switch_status_t,
    >,
    pub rwlock: *mut switch_thread_rwlock_t,
    pub refs: ::std::os::raw::c_int,
    pub reflock: *mut switch_mutex_t,
    pub parent: *mut switch_loadable_module_interface_t,
    pub next: *mut switch_limit_interface,
}
#[test]
fn bindgen_test_layout_switch_limit_interface() {
    const UNINIT: ::std::mem::MaybeUninit<switch_limit_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_limit_interface>(),
        96usize,
        concat!("Size of: ", stringify!(switch_limit_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_limit_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_limit_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_limit_interface),
            "::",
            stringify!(interface_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).incr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_limit_interface),
            "::",
            stringify!(incr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_limit_interface),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usage) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_limit_interface),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reset) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_limit_interface),
            "::",
            stringify!(reset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_limit_interface),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interval_reset) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_limit_interface),
            "::",
            stringify!(interval_reset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rwlock) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_limit_interface),
            "::",
            stringify!(rwlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refs) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_limit_interface),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reflock) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_limit_interface),
            "::",
            stringify!(reflock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_limit_interface),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_limit_interface),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " \\brief Abstract interface to a directory module"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_directory_interface {
    #[doc = " the name of the interface"]
    pub interface_name: *const ::std::os::raw::c_char,
    #[doc = " function to open the directory interface"]
    pub directory_open: ::std::option::Option<
        unsafe extern "C" fn(
            dh: *mut switch_directory_handle_t,
            source: *mut ::std::os::raw::c_char,
            dsn: *mut ::std::os::raw::c_char,
            passwd: *mut ::std::os::raw::c_char,
        ) -> switch_status_t,
    >,
    #[doc = " function to close the directory interface"]
    pub directory_close: ::std::option::Option<
        unsafe extern "C" fn(dh: *mut switch_directory_handle_t) -> switch_status_t,
    >,
    #[doc = " function to query the directory interface"]
    pub directory_query: ::std::option::Option<
        unsafe extern "C" fn(
            dh: *mut switch_directory_handle_t,
            base: *mut ::std::os::raw::c_char,
            query: *mut ::std::os::raw::c_char,
        ) -> switch_status_t,
    >,
    #[doc = " function to advance to the next record"]
    pub directory_next: ::std::option::Option<
        unsafe extern "C" fn(dh: *mut switch_directory_handle_t) -> switch_status_t,
    >,
    #[doc = " function to advance to the next name/value pair in the current record"]
    pub directory_next_pair: ::std::option::Option<
        unsafe extern "C" fn(
            dh: *mut switch_directory_handle_t,
            var: *mut *mut ::std::os::raw::c_char,
            val: *mut *mut ::std::os::raw::c_char,
        ) -> switch_status_t,
    >,
    pub rwlock: *mut switch_thread_rwlock_t,
    pub refs: ::std::os::raw::c_int,
    pub reflock: *mut switch_mutex_t,
    pub parent: *mut switch_loadable_module_interface_t,
    pub next: *mut switch_directory_interface,
}
#[test]
fn bindgen_test_layout_switch_directory_interface() {
    const UNINIT: ::std::mem::MaybeUninit<switch_directory_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_directory_interface>(),
        88usize,
        concat!("Size of: ", stringify!(switch_directory_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_directory_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_directory_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directory_interface),
            "::",
            stringify!(interface_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).directory_open) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directory_interface),
            "::",
            stringify!(directory_open)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).directory_close) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directory_interface),
            "::",
            stringify!(directory_close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).directory_query) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directory_interface),
            "::",
            stringify!(directory_query)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).directory_next) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directory_interface),
            "::",
            stringify!(directory_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).directory_next_pair) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directory_interface),
            "::",
            stringify!(directory_next_pair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rwlock) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directory_interface),
            "::",
            stringify!(rwlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refs) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directory_interface),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reflock) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directory_interface),
            "::",
            stringify!(reflock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directory_interface),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directory_interface),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " an abstract representation of a directory interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_directory_handle {
    #[doc = " the interface of the module that implemented the current directory interface"]
    pub directory_interface: *mut switch_directory_interface_t,
    #[doc = " flags to control behaviour"]
    pub flags: u32,
    #[doc = " the handle's memory pool"]
    pub memory_pool: *mut switch_memory_pool_t,
    #[doc = " private data for the format module to store handle specific info"]
    pub private_info: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_switch_directory_handle() {
    const UNINIT: ::std::mem::MaybeUninit<switch_directory_handle> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_directory_handle>(),
        32usize,
        concat!("Size of: ", stringify!(switch_directory_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_directory_handle>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_directory_handle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).directory_interface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directory_handle),
            "::",
            stringify!(directory_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directory_handle),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory_pool) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directory_handle),
            "::",
            stringify!(memory_pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_info) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_directory_handle),
            "::",
            stringify!(private_info)
        )
    );
}
#[doc = " \\brief Abstract interface to a database module"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_database_interface {
    #[doc = " the name of the interface"]
    pub interface_name: *const ::std::os::raw::c_char,
    #[doc = " flags indicating database specifics, see switch_database_flag_t"]
    pub flags: u32,
    pub handle_new: ::std::option::Option<
        unsafe extern "C" fn(
            database_interface_options: switch_cache_db_database_interface_options_t,
            dih: *mut *mut switch_database_interface_handle_t,
        ) -> switch_status_t,
    >,
    pub handle_destroy: ::std::option::Option<
        unsafe extern "C" fn(dih: *mut *mut switch_database_interface_handle_t) -> switch_status_t,
    >,
    pub flush: ::std::option::Option<
        unsafe extern "C" fn(dih: *mut switch_database_interface_handle_t) -> switch_status_t,
    >,
    pub exec_detailed: ::std::option::Option<
        unsafe extern "C" fn(
            file: *const ::std::os::raw::c_char,
            func: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            dih: *mut switch_database_interface_handle_t,
            sql: *const ::std::os::raw::c_char,
            err: *mut *mut ::std::os::raw::c_char,
        ) -> switch_status_t,
    >,
    pub exec_string: ::std::option::Option<
        unsafe extern "C" fn(
            dih: *mut switch_database_interface_handle_t,
            sql: *const ::std::os::raw::c_char,
            resbuf: *mut ::std::os::raw::c_char,
            len: usize,
            err: *mut *mut ::std::os::raw::c_char,
        ) -> switch_status_t,
    >,
    pub sql_set_auto_commit_attr: ::std::option::Option<
        unsafe extern "C" fn(
            dih: *mut switch_database_interface_handle_t,
            on: switch_bool_t,
        ) -> switch_status_t,
    >,
    pub commit: ::std::option::Option<
        unsafe extern "C" fn(dih: *mut switch_database_interface_handle_t) -> switch_status_t,
    >,
    pub rollback: ::std::option::Option<
        unsafe extern "C" fn(dih: *mut switch_database_interface_handle_t) -> switch_status_t,
    >,
    pub callback_exec_detailed: ::std::option::Option<
        unsafe extern "C" fn(
            file: *const ::std::os::raw::c_char,
            func: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            dih: *mut switch_database_interface_handle_t,
            sql: *const ::std::os::raw::c_char,
            callback: switch_core_db_callback_func_t,
            pdata: *mut ::std::os::raw::c_void,
            err: *mut *mut ::std::os::raw::c_char,
        ) -> switch_status_t,
    >,
    pub affected_rows: ::std::option::Option<
        unsafe extern "C" fn(
            dih: *mut switch_database_interface_handle_t,
            affected_rows: *mut ::std::os::raw::c_int,
        ) -> switch_status_t,
    >,
    #[doc = " list of supported dsn prefixes"]
    pub prefixes: *mut *mut ::std::os::raw::c_char,
    pub rwlock: *mut switch_thread_rwlock_t,
    pub refs: ::std::os::raw::c_int,
    pub reflock: *mut switch_mutex_t,
    pub parent: *mut switch_loadable_module_interface_t,
    pub next: *mut switch_database_interface,
}
#[test]
fn bindgen_test_layout_switch_database_interface() {
    const UNINIT: ::std::mem::MaybeUninit<switch_database_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_database_interface>(),
        144usize,
        concat!("Size of: ", stringify!(switch_database_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_database_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_database_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_database_interface),
            "::",
            stringify!(interface_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_database_interface),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle_new) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_database_interface),
            "::",
            stringify!(handle_new)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle_destroy) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_database_interface),
            "::",
            stringify!(handle_destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flush) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_database_interface),
            "::",
            stringify!(flush)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exec_detailed) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_database_interface),
            "::",
            stringify!(exec_detailed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exec_string) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_database_interface),
            "::",
            stringify!(exec_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sql_set_auto_commit_attr) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_database_interface),
            "::",
            stringify!(sql_set_auto_commit_attr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).commit) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_database_interface),
            "::",
            stringify!(commit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rollback) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_database_interface),
            "::",
            stringify!(rollback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback_exec_detailed) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_database_interface),
            "::",
            stringify!(callback_exec_detailed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).affected_rows) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_database_interface),
            "::",
            stringify!(affected_rows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefixes) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_database_interface),
            "::",
            stringify!(prefixes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rwlock) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_database_interface),
            "::",
            stringify!(rwlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refs) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_database_interface),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reflock) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_database_interface),
            "::",
            stringify!(reflock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_database_interface),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_database_interface),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " an abstract representation of a database interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_database_interface_handle {
    pub connection_options: switch_cache_db_database_interface_options_t,
    pub handle: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_switch_database_interface_handle() {
    const UNINIT: ::std::mem::MaybeUninit<switch_database_interface_handle> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_database_interface_handle>(),
        56usize,
        concat!("Size of: ", stringify!(switch_database_interface_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_database_interface_handle>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(switch_database_interface_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connection_options) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_database_interface_handle),
            "::",
            stringify!(connection_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_database_interface_handle),
            "::",
            stringify!(handle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_audio_codec_settings {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_switch_audio_codec_settings() {
    const UNINIT: ::std::mem::MaybeUninit<switch_audio_codec_settings> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_audio_codec_settings>(),
        4usize,
        concat!("Size of: ", stringify!(switch_audio_codec_settings))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_audio_codec_settings>(),
        4usize,
        concat!("Alignment of ", stringify!(switch_audio_codec_settings))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_audio_codec_settings),
            "::",
            stringify!(unused)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_video_codec_settings {
    pub bandwidth: u32,
    pub width: i32,
    pub height: i32,
    pub try_hardware_encoder: u8,
    pub fps: u8,
    pub config_profile_name: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_switch_video_codec_settings() {
    const UNINIT: ::std::mem::MaybeUninit<switch_video_codec_settings> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_video_codec_settings>(),
        80usize,
        concat!("Size of: ", stringify!(switch_video_codec_settings))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_video_codec_settings>(),
        4usize,
        concat!("Alignment of ", stringify!(switch_video_codec_settings))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bandwidth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_video_codec_settings),
            "::",
            stringify!(bandwidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_video_codec_settings),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_video_codec_settings),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).try_hardware_encoder) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_video_codec_settings),
            "::",
            stringify!(try_hardware_encoder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fps) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_video_codec_settings),
            "::",
            stringify!(fps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).config_profile_name) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_video_codec_settings),
            "::",
            stringify!(config_profile_name)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union switch_codec_settings {
    pub audio: switch_audio_codec_settings,
    pub video: switch_video_codec_settings,
}
#[test]
fn bindgen_test_layout_switch_codec_settings() {
    const UNINIT: ::std::mem::MaybeUninit<switch_codec_settings> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_codec_settings>(),
        80usize,
        concat!("Size of: ", stringify!(switch_codec_settings))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_codec_settings>(),
        4usize,
        concat!("Alignment of ", stringify!(switch_codec_settings))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audio) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_settings),
            "::",
            stringify!(audio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).video) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_settings),
            "::",
            stringify!(video)
        )
    );
}
#[doc = " an abstract handle of a fmtp parsed by codec"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_codec_fmtp {
    #[doc = " actual samples transferred per second for those who are not moron g722 RFC writers"]
    pub actual_samples_per_second: u32,
    #[doc = " bits transferred per second"]
    pub bits_per_second: ::std::os::raw::c_int,
    #[doc = " number of microseconds of media in one packet (ptime * 1000)"]
    pub microseconds_per_packet: ::std::os::raw::c_int,
    #[doc = " maximum ptime in ms"]
    pub max_ptime: ::std::os::raw::c_int,
    #[doc = " minimum ptime in ms"]
    pub min_ptime: ::std::os::raw::c_int,
    #[doc = " stereo, typically bidirectional"]
    pub stereo: ::std::os::raw::c_int,
    pub sprop_stereo: ::std::os::raw::c_int,
    #[doc = " private data for the codec module to store handle specific info"]
    pub private_info: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_switch_codec_fmtp() {
    const UNINIT: ::std::mem::MaybeUninit<switch_codec_fmtp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_codec_fmtp>(),
        40usize,
        concat!("Size of: ", stringify!(switch_codec_fmtp))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_codec_fmtp>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_codec_fmtp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).actual_samples_per_second) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_fmtp),
            "::",
            stringify!(actual_samples_per_second)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits_per_second) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_fmtp),
            "::",
            stringify!(bits_per_second)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).microseconds_per_packet) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_fmtp),
            "::",
            stringify!(microseconds_per_packet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_ptime) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_fmtp),
            "::",
            stringify!(max_ptime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_ptime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_fmtp),
            "::",
            stringify!(min_ptime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stereo) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_fmtp),
            "::",
            stringify!(stereo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sprop_stereo) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_fmtp),
            "::",
            stringify!(sprop_stereo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_info) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_fmtp),
            "::",
            stringify!(private_info)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_picture {
    pub width: u32,
    pub height: u32,
    pub planes: [*mut u8; 4usize],
    pub stride: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_switch_picture() {
    const UNINIT: ::std::mem::MaybeUninit<switch_picture> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_picture>(),
        56usize,
        concat!("Size of: ", stringify!(switch_picture))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_picture>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_picture))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_picture),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_picture),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).planes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_picture),
            "::",
            stringify!(planes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_picture),
            "::",
            stringify!(stride)
        )
    );
}
#[doc = " an abstract handle to a codec module"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_codec {
    #[doc = " the codec interface table this handle uses"]
    pub codec_interface: *mut switch_codec_interface_t,
    #[doc = " the specific implementation of the above codec"]
    pub implementation: *const switch_codec_implementation_t,
    #[doc = " fmtp line from remote sdp"]
    pub fmtp_in: *mut ::std::os::raw::c_char,
    #[doc = " fmtp line for local sdp"]
    pub fmtp_out: *mut ::std::os::raw::c_char,
    #[doc = " flags to modify behaviour"]
    pub flags: u32,
    #[doc = " the handle's memory pool"]
    pub memory_pool: *mut switch_memory_pool_t,
    #[doc = " private data for the codec module to store handle specific info"]
    pub private_info: *mut ::std::os::raw::c_void,
    pub agreed_pt: switch_payload_t,
    pub mutex: *mut switch_mutex_t,
    pub next: *mut switch_codec,
    pub session: *mut switch_core_session_t,
    pub cur_frame: *mut switch_frame_t,
}
#[test]
fn bindgen_test_layout_switch_codec() {
    const UNINIT: ::std::mem::MaybeUninit<switch_codec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_codec>(),
        96usize,
        concat!("Size of: ", stringify!(switch_codec))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_codec>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_codec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec_interface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec),
            "::",
            stringify!(codec_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).implementation) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec),
            "::",
            stringify!(implementation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fmtp_in) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec),
            "::",
            stringify!(fmtp_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fmtp_out) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec),
            "::",
            stringify!(fmtp_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory_pool) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec),
            "::",
            stringify!(memory_pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_info) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec),
            "::",
            stringify!(private_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).agreed_pt) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec),
            "::",
            stringify!(agreed_pt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec),
            "::",
            stringify!(session)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cur_frame) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec),
            "::",
            stringify!(cur_frame)
        )
    );
}
#[doc = " \\brief A table of settings and callbacks that define a paticular implementation of a codec"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_codec_implementation {
    #[doc = " enumeration defining the type of the codec"]
    pub codec_type: switch_codec_type_t,
    #[doc = " the IANA code number"]
    pub ianacode: switch_payload_t,
    #[doc = " the IANA code name"]
    pub iananame: *mut ::std::os::raw::c_char,
    #[doc = " default fmtp to send (can be overridden by the init function)"]
    pub fmtp: *mut ::std::os::raw::c_char,
    #[doc = " samples transferred per second"]
    pub samples_per_second: u32,
    #[doc = " actual samples transferred per second for those who are not moron g722 RFC writers"]
    pub actual_samples_per_second: u32,
    #[doc = " bits transferred per second"]
    pub bits_per_second: ::std::os::raw::c_int,
    #[doc = " number of microseconds of media in one packet (ptime * 1000)"]
    pub microseconds_per_packet: ::std::os::raw::c_int,
    #[doc = " number of samples in one packet"]
    pub samples_per_packet: u32,
    #[doc = " number of bytes one packet will decompress to"]
    pub decoded_bytes_per_packet: u32,
    #[doc = " number of encoded bytes in the RTP payload"]
    pub encoded_bytes_per_packet: u32,
    #[doc = " number of channels represented"]
    pub number_of_channels: u8,
    #[doc = " number of codec frames packetized into one packet"]
    pub codec_frames_per_packet: ::std::os::raw::c_int,
    #[doc = " function to initialize a codec handle using this implementation"]
    pub init: switch_core_codec_init_func_t,
    #[doc = " function to encode raw data into encoded data"]
    pub encode: switch_core_codec_encode_func_t,
    #[doc = " function to decode encoded data into raw data"]
    pub decode: switch_core_codec_decode_func_t,
    #[doc = " function to encode video raw data into encoded data"]
    pub encode_video: switch_core_codec_video_encode_func_t,
    #[doc = " function to decode video encoded data into raw data"]
    pub decode_video: switch_core_codec_video_decode_func_t,
    #[doc = " function to send control messages to the codec"]
    pub codec_control: switch_core_codec_control_func_t,
    #[doc = " deinitalize a codec handle using this implementation"]
    pub destroy: switch_core_codec_destroy_func_t,
    pub codec_id: u32,
    pub impl_id: u32,
    pub modname: *mut ::std::os::raw::c_char,
    pub next: *mut switch_codec_implementation,
}
#[test]
fn bindgen_test_layout_switch_codec_implementation() {
    const UNINIT: ::std::mem::MaybeUninit<switch_codec_implementation> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_codec_implementation>(),
        144usize,
        concat!("Size of: ", stringify!(switch_codec_implementation))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_codec_implementation>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_codec_implementation))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_implementation),
            "::",
            stringify!(codec_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ianacode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_implementation),
            "::",
            stringify!(ianacode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iananame) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_implementation),
            "::",
            stringify!(iananame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fmtp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_implementation),
            "::",
            stringify!(fmtp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samples_per_second) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_implementation),
            "::",
            stringify!(samples_per_second)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).actual_samples_per_second) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_implementation),
            "::",
            stringify!(actual_samples_per_second)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits_per_second) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_implementation),
            "::",
            stringify!(bits_per_second)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).microseconds_per_packet) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_implementation),
            "::",
            stringify!(microseconds_per_packet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samples_per_packet) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_implementation),
            "::",
            stringify!(samples_per_packet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decoded_bytes_per_packet) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_implementation),
            "::",
            stringify!(decoded_bytes_per_packet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encoded_bytes_per_packet) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_implementation),
            "::",
            stringify!(encoded_bytes_per_packet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).number_of_channels) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_implementation),
            "::",
            stringify!(number_of_channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec_frames_per_packet) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_implementation),
            "::",
            stringify!(codec_frames_per_packet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_implementation),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encode) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_implementation),
            "::",
            stringify!(encode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decode) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_implementation),
            "::",
            stringify!(decode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encode_video) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_implementation),
            "::",
            stringify!(encode_video)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decode_video) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_implementation),
            "::",
            stringify!(decode_video)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec_control) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_implementation),
            "::",
            stringify!(codec_control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_implementation),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec_id) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_implementation),
            "::",
            stringify!(codec_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_id) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_implementation),
            "::",
            stringify!(impl_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modname) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_implementation),
            "::",
            stringify!(modname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_implementation),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " \\brief Top level module interface to implement a series of codec implementations"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_codec_interface {
    #[doc = " the name of the interface"]
    pub interface_name: *const ::std::os::raw::c_char,
    #[doc = " a list of codec implementations related to the codec"]
    pub implementations: *mut switch_codec_implementation_t,
    #[doc = " function to decode a codec fmtp parameters"]
    pub parse_fmtp: switch_core_codec_fmtp_parse_func_t,
    pub codec_id: u32,
    pub rwlock: *mut switch_thread_rwlock_t,
    pub refs: ::std::os::raw::c_int,
    pub reflock: *mut switch_mutex_t,
    pub modname: *mut ::std::os::raw::c_char,
    pub parent: *mut switch_loadable_module_interface_t,
    pub next: *mut switch_codec_interface,
}
#[test]
fn bindgen_test_layout_switch_codec_interface() {
    const UNINIT: ::std::mem::MaybeUninit<switch_codec_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_codec_interface>(),
        80usize,
        concat!("Size of: ", stringify!(switch_codec_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_codec_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_codec_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_interface),
            "::",
            stringify!(interface_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).implementations) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_interface),
            "::",
            stringify!(implementations)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parse_fmtp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_interface),
            "::",
            stringify!(parse_fmtp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_interface),
            "::",
            stringify!(codec_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rwlock) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_interface),
            "::",
            stringify!(rwlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refs) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_interface),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reflock) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_interface),
            "::",
            stringify!(reflock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modname) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_interface),
            "::",
            stringify!(modname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_interface),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_codec_interface),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " \\brief A module interface to implement an application"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_application_interface {
    #[doc = " the name of the interface"]
    pub interface_name: *const ::std::os::raw::c_char,
    #[doc = " function the application implements"]
    pub application_function: switch_application_function_t,
    #[doc = " the long winded description of the application"]
    pub long_desc: *const ::std::os::raw::c_char,
    #[doc = " the short and sweet description of the application"]
    pub short_desc: *const ::std::os::raw::c_char,
    #[doc = " an example of the application syntax"]
    pub syntax: *const ::std::os::raw::c_char,
    #[doc = " flags to control behaviour"]
    pub flags: u32,
    pub rwlock: *mut switch_thread_rwlock_t,
    pub refs: ::std::os::raw::c_int,
    pub reflock: *mut switch_mutex_t,
    pub parent: *mut switch_loadable_module_interface_t,
    pub next: *mut switch_application_interface,
}
#[test]
fn bindgen_test_layout_switch_application_interface() {
    const UNINIT: ::std::mem::MaybeUninit<switch_application_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_application_interface>(),
        88usize,
        concat!("Size of: ", stringify!(switch_application_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_application_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_application_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_application_interface),
            "::",
            stringify!(interface_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).application_function) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_application_interface),
            "::",
            stringify!(application_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).long_desc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_application_interface),
            "::",
            stringify!(long_desc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).short_desc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_application_interface),
            "::",
            stringify!(short_desc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).syntax) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_application_interface),
            "::",
            stringify!(syntax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_application_interface),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rwlock) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_application_interface),
            "::",
            stringify!(rwlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refs) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_application_interface),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reflock) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_application_interface),
            "::",
            stringify!(reflock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_application_interface),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_application_interface),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " \\brief A module interface to implement a chat application"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_chat_application_interface {
    #[doc = " the name of the interface"]
    pub interface_name: *const ::std::os::raw::c_char,
    #[doc = " function the application implements"]
    pub chat_application_function: switch_chat_application_function_t,
    #[doc = " the long winded description of the application"]
    pub long_desc: *const ::std::os::raw::c_char,
    #[doc = " the short and sweet description of the application"]
    pub short_desc: *const ::std::os::raw::c_char,
    #[doc = " an example of the application syntax"]
    pub syntax: *const ::std::os::raw::c_char,
    #[doc = " flags to control behaviour"]
    pub flags: u32,
    pub rwlock: *mut switch_thread_rwlock_t,
    pub refs: ::std::os::raw::c_int,
    pub reflock: *mut switch_mutex_t,
    pub parent: *mut switch_loadable_module_interface_t,
    pub next: *mut switch_chat_application_interface,
}
#[test]
fn bindgen_test_layout_switch_chat_application_interface() {
    const UNINIT: ::std::mem::MaybeUninit<switch_chat_application_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_chat_application_interface>(),
        88usize,
        concat!("Size of: ", stringify!(switch_chat_application_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_chat_application_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(switch_chat_application_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_chat_application_interface),
            "::",
            stringify!(interface_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chat_application_function) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_chat_application_interface),
            "::",
            stringify!(chat_application_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).long_desc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_chat_application_interface),
            "::",
            stringify!(long_desc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).short_desc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_chat_application_interface),
            "::",
            stringify!(short_desc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).syntax) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_chat_application_interface),
            "::",
            stringify!(syntax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_chat_application_interface),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rwlock) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_chat_application_interface),
            "::",
            stringify!(rwlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refs) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_chat_application_interface),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reflock) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_chat_application_interface),
            "::",
            stringify!(reflock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_chat_application_interface),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_chat_application_interface),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " \\brief A module interface to implement an api function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_api_interface {
    #[doc = " the name of the interface"]
    pub interface_name: *const ::std::os::raw::c_char,
    #[doc = " a description of the api function"]
    pub desc: *const ::std::os::raw::c_char,
    #[doc = " function the api call uses"]
    pub function: switch_api_function_t,
    #[doc = " an example of the api syntax"]
    pub syntax: *const ::std::os::raw::c_char,
    pub rwlock: *mut switch_thread_rwlock_t,
    pub refs: ::std::os::raw::c_int,
    pub reflock: *mut switch_mutex_t,
    pub parent: *mut switch_loadable_module_interface_t,
    pub next: *mut switch_api_interface,
}
#[test]
fn bindgen_test_layout_switch_api_interface() {
    const UNINIT: ::std::mem::MaybeUninit<switch_api_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_api_interface>(),
        72usize,
        concat!("Size of: ", stringify!(switch_api_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_api_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_api_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_api_interface),
            "::",
            stringify!(interface_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_api_interface),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).function) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_api_interface),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).syntax) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_api_interface),
            "::",
            stringify!(syntax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rwlock) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_api_interface),
            "::",
            stringify!(rwlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refs) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_api_interface),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reflock) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_api_interface),
            "::",
            stringify!(reflock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_api_interface),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_api_interface),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " \\brief A module interface to implement a json api function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_json_api_interface {
    #[doc = " the name of the interface"]
    pub interface_name: *const ::std::os::raw::c_char,
    #[doc = " a description of the api function"]
    pub desc: *const ::std::os::raw::c_char,
    #[doc = " function the api call uses"]
    pub function: switch_json_api_function_t,
    #[doc = " an example of the api syntax"]
    pub syntax: *const ::std::os::raw::c_char,
    pub rwlock: *mut switch_thread_rwlock_t,
    pub refs: ::std::os::raw::c_int,
    pub reflock: *mut switch_mutex_t,
    pub parent: *mut switch_loadable_module_interface_t,
    pub next: *mut switch_json_api_interface,
}
#[test]
fn bindgen_test_layout_switch_json_api_interface() {
    const UNINIT: ::std::mem::MaybeUninit<switch_json_api_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_json_api_interface>(),
        72usize,
        concat!("Size of: ", stringify!(switch_json_api_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_json_api_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_json_api_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_json_api_interface),
            "::",
            stringify!(interface_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_json_api_interface),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).function) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_json_api_interface),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).syntax) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_json_api_interface),
            "::",
            stringify!(syntax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rwlock) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_json_api_interface),
            "::",
            stringify!(rwlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refs) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_json_api_interface),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reflock) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_json_api_interface),
            "::",
            stringify!(reflock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_json_api_interface),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_json_api_interface),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_frame_geometry {
    pub w: i32,
    pub h: i32,
    pub x: i32,
    pub y: i32,
    pub z: i32,
    pub M: i32,
    pub X: i32,
}
#[test]
fn bindgen_test_layout_switch_frame_geometry() {
    const UNINIT: ::std::mem::MaybeUninit<switch_frame_geometry> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_frame_geometry>(),
        28usize,
        concat!("Size of: ", stringify!(switch_frame_geometry))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_frame_geometry>(),
        4usize,
        concat!("Alignment of ", stringify!(switch_frame_geometry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_frame_geometry),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_frame_geometry),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_frame_geometry),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_frame_geometry),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_frame_geometry),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).M) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_frame_geometry),
            "::",
            stringify!(M)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).X) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_frame_geometry),
            "::",
            stringify!(X)
        )
    );
}
pub type switch_frame_geometry_t = switch_frame_geometry;
#[doc = " \\brief An abstraction of a data frame"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_frame {
    #[doc = " a pointer to the codec information"]
    pub codec: *mut switch_codec_t,
    #[doc = " the originating source of the frame"]
    pub source: *const ::std::os::raw::c_char,
    #[doc = " the raw packet"]
    pub packet: *mut ::std::os::raw::c_void,
    #[doc = " the size of the raw packet when applicable"]
    pub packetlen: u32,
    #[doc = " the extra frame data"]
    pub extra_data: *mut ::std::os::raw::c_void,
    #[doc = " the frame data"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " the size of the buffer that is in use"]
    pub datalen: u32,
    #[doc = " the entire size of the buffer"]
    pub buflen: u32,
    #[doc = " the number of audio samples present (audio only)"]
    pub samples: u32,
    #[doc = " the rate of the frame"]
    pub rate: u32,
    #[doc = " the number of channels in the frame"]
    pub channels: u32,
    #[doc = " the payload of the frame"]
    pub payload: switch_payload_t,
    #[doc = " the timestamp of the frame"]
    pub timestamp: u32,
    pub seq: u16,
    pub ssrc: u32,
    pub m: switch_bool_t,
    #[doc = " frame flags"]
    pub flags: switch_frame_flag_t,
    pub user_data: *mut ::std::os::raw::c_void,
    pub pmap: *mut payload_map_t,
    pub img: *mut switch_image_t,
    pub geometry: switch_frame_geometry,
}
#[test]
fn bindgen_test_layout_switch_frame() {
    const UNINIT: ::std::mem::MaybeUninit<switch_frame> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_frame>(),
        152usize,
        concat!("Size of: ", stringify!(switch_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_frame))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_frame),
            "::",
            stringify!(codec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_frame),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packet) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_frame),
            "::",
            stringify!(packet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packetlen) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_frame),
            "::",
            stringify!(packetlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extra_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_frame),
            "::",
            stringify!(extra_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_frame),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).datalen) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_frame),
            "::",
            stringify!(datalen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buflen) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_frame),
            "::",
            stringify!(buflen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samples) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_frame),
            "::",
            stringify!(samples)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_frame),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_frame),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).payload) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_frame),
            "::",
            stringify!(payload)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_frame),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seq) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_frame),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ssrc) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_frame),
            "::",
            stringify!(ssrc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_frame),
            "::",
            stringify!(m)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_frame),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_frame),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pmap) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_frame),
            "::",
            stringify!(pmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).img) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_frame),
            "::",
            stringify!(img)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).geometry) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_frame),
            "::",
            stringify!(geometry)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_slin_data {
    pub session: *mut switch_core_session_t,
    pub write_frame: switch_frame_t,
    pub codec: switch_codec_t,
    pub frame_data: [::std::os::raw::c_char; 8192usize],
}
#[test]
fn bindgen_test_layout_switch_slin_data() {
    const UNINIT: ::std::mem::MaybeUninit<switch_slin_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_slin_data>(),
        8448usize,
        concat!("Size of: ", stringify!(switch_slin_data))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_slin_data>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_slin_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_slin_data),
            "::",
            stringify!(session)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_frame) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_slin_data),
            "::",
            stringify!(write_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_slin_data),
            "::",
            stringify!(codec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_data) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_slin_data),
            "::",
            stringify!(frame_data)
        )
    );
}
pub const switch_loadable_module_type_t_SWITCH_LOADABLE_MODULE_TYPE_PRELOAD:
    switch_loadable_module_type_t = 0;
pub const switch_loadable_module_type_t_SWITCH_LOADABLE_MODULE_TYPE_COMMON:
    switch_loadable_module_type_t = 1;
pub const switch_loadable_module_type_t_SWITCH_LOADABLE_MODULE_TYPE_POSTLOAD:
    switch_loadable_module_type_t = 2;
#[doc = " \\brief List of loadable module types"]
pub type switch_loadable_module_type_t = ::std::os::raw::c_uint;
#[doc = " \\brief The abstraction of a loadable module"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_loadable_module_interface {
    #[doc = " the name of the module"]
    pub module_name: *const ::std::os::raw::c_char,
    #[doc = " the table of endpoints the module has implemented"]
    pub endpoint_interface: *mut switch_endpoint_interface_t,
    #[doc = " the table of timers the module has implemented"]
    pub timer_interface: *mut switch_timer_interface_t,
    #[doc = " the table of dialplans the module has implemented"]
    pub dialplan_interface: *mut switch_dialplan_interface_t,
    #[doc = " the table of codecs the module has implemented"]
    pub codec_interface: *mut switch_codec_interface_t,
    #[doc = " the table of applications the module has implemented"]
    pub application_interface: *mut switch_application_interface_t,
    #[doc = " the table of chat applications the module has implemented"]
    pub chat_application_interface: *mut switch_chat_application_interface_t,
    #[doc = " the table of api functions the module has implemented"]
    pub api_interface: *mut switch_api_interface_t,
    #[doc = " the table of json api functions the module has implemented"]
    pub json_api_interface: *mut switch_json_api_interface_t,
    #[doc = " the table of file formats the module has implemented"]
    pub file_interface: *mut switch_file_interface_t,
    #[doc = " the table of speech interfaces the module has implemented"]
    pub speech_interface: *mut switch_speech_interface_t,
    #[doc = " the table of directory interfaces the module has implemented"]
    pub directory_interface: *mut switch_directory_interface_t,
    #[doc = " the table of chat interfaces the module has implemented"]
    pub chat_interface: *mut switch_chat_interface_t,
    #[doc = " the table of say interfaces the module has implemented"]
    pub say_interface: *mut switch_say_interface_t,
    #[doc = " the table of asr interfaces the module has implemented"]
    pub asr_interface: *mut switch_asr_interface_t,
    #[doc = " the table of management interfaces the module has implemented"]
    pub management_interface: *mut switch_management_interface_t,
    #[doc = " the table of limit interfaces the module has implemented"]
    pub limit_interface: *mut switch_limit_interface_t,
    #[doc = " the table of database interfaces the module has implemented"]
    pub database_interface: *mut switch_database_interface_t,
    pub rwlock: *mut switch_thread_rwlock_t,
    pub refs: ::std::os::raw::c_int,
    pub pool: *mut switch_memory_pool_t,
}
#[test]
fn bindgen_test_layout_switch_loadable_module_interface() {
    const UNINIT: ::std::mem::MaybeUninit<switch_loadable_module_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_loadable_module_interface>(),
        168usize,
        concat!("Size of: ", stringify!(switch_loadable_module_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_loadable_module_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(switch_loadable_module_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).module_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_loadable_module_interface),
            "::",
            stringify!(module_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endpoint_interface) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_loadable_module_interface),
            "::",
            stringify!(endpoint_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timer_interface) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_loadable_module_interface),
            "::",
            stringify!(timer_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dialplan_interface) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_loadable_module_interface),
            "::",
            stringify!(dialplan_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec_interface) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_loadable_module_interface),
            "::",
            stringify!(codec_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).application_interface) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_loadable_module_interface),
            "::",
            stringify!(application_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chat_application_interface) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_loadable_module_interface),
            "::",
            stringify!(chat_application_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).api_interface) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_loadable_module_interface),
            "::",
            stringify!(api_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).json_api_interface) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_loadable_module_interface),
            "::",
            stringify!(json_api_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_interface) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_loadable_module_interface),
            "::",
            stringify!(file_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speech_interface) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_loadable_module_interface),
            "::",
            stringify!(speech_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).directory_interface) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_loadable_module_interface),
            "::",
            stringify!(directory_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chat_interface) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_loadable_module_interface),
            "::",
            stringify!(chat_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).say_interface) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_loadable_module_interface),
            "::",
            stringify!(say_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asr_interface) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_loadable_module_interface),
            "::",
            stringify!(asr_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).management_interface) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_loadable_module_interface),
            "::",
            stringify!(management_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).limit_interface) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_loadable_module_interface),
            "::",
            stringify!(limit_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).database_interface) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_loadable_module_interface),
            "::",
            stringify!(database_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rwlock) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_loadable_module_interface),
            "::",
            stringify!(rwlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refs) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_loadable_module_interface),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_loadable_module_interface),
            "::",
            stringify!(pool)
        )
    );
}
extern "C" {
    #[doc = "\\brief Initilize the module backend and load all the modules\n\\return SWITCH_STATUS_SUCCESS when complete"]
    pub fn switch_loadable_module_init(autoload: switch_bool_t) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Shutdown the module backend and call the shutdown routine in all loaded modules"]
    pub fn switch_loadable_module_shutdown();
}
extern "C" {
    #[doc = "\\brief Retrieve the endpoint interface by it's registered name\n\\param name the name of the endpoint\n\\return the desired endpoint interface"]
    pub fn switch_loadable_module_get_endpoint_interface(
        name: *const ::std::os::raw::c_char,
    ) -> *mut switch_endpoint_interface_t;
}
extern "C" {
    #[doc = "\\brief Retrieve the codec interface by it's registered name\n\\param name the name of the codec\n\\return the desired codec interface"]
    pub fn switch_loadable_module_get_codec_interface(
        name: *const ::std::os::raw::c_char,
        modname: *const ::std::os::raw::c_char,
    ) -> *mut switch_codec_interface_t;
}
extern "C" {
    pub fn switch_parse_codec_buf(
        buf: *mut ::std::os::raw::c_char,
        interval: *mut u32,
        rate: *mut u32,
        bit: *mut u32,
        channels: *mut u32,
        modname: *mut *mut ::std::os::raw::c_char,
        fmtp: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Retrieve the dialplan interface by it's registered name\n\\param name the name of the dialplan\n\\return the desired dialplan interface"]
    pub fn switch_loadable_module_get_dialplan_interface(
        name: *const ::std::os::raw::c_char,
    ) -> *mut switch_dialplan_interface_t;
}
extern "C" {
    #[doc = "\\brief Enumerates a list of all modules discovered in a directory\n\\param the directory to look for modules in\n\\param memory pool\n\\param callback function to call for each module found\n\\param user data argument to pass to the callback function\n\\return the resulting status"]
    pub fn switch_loadable_module_enumerate_available(
        dir_path: *const ::std::os::raw::c_char,
        callback: switch_modulename_callback_func_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Enumerates a list of all currently loaded modules\n\\param callback function to call for each module found\n\\param user data argument to pass to the callback function\n\\return the resulting status"]
    pub fn switch_loadable_module_enumerate_loaded(
        callback: switch_modulename_callback_func_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief build a dynamic module object and register it (for use in double embeded modules)\n\\param filename the name of the modules source file\n\\param switch_module_load the function to call when the module is loaded\n\\param switch_module_runtime a function requested to be started in it's own thread once loaded\n\\param switch_module_shutdown the function to call when the system is shutdown\n\\param runtime start the runtime thread or not\n\\return the resulting status\n\\note only use this function if you are making a module that in turn gateways module loading to another technology"]
    pub fn switch_loadable_module_build_dynamic(
        filename: *mut ::std::os::raw::c_char,
        switch_module_load: switch_module_load_t,
        switch_module_runtime: switch_module_runtime_t,
        switch_module_shutdown: switch_module_shutdown_t,
        runtime: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Retrieve the timer interface by it's registered name\n\\param name the name of the timer\n\\return the desired timer interface"]
    pub fn switch_loadable_module_get_timer_interface(
        name: *const ::std::os::raw::c_char,
    ) -> *mut switch_timer_interface_t;
}
extern "C" {
    #[doc = "\\brief Retrieve the application interface by it's registered name\n\\param name the name of the application\n\\return the desired application interface"]
    pub fn switch_loadable_module_get_application_interface(
        name: *const ::std::os::raw::c_char,
    ) -> *mut switch_application_interface_t;
}
extern "C" {
    #[doc = "\\brief Retrieve the chat application interface by it's registered name\n\\param name the name of the chat application\n\\return the desired chat application interface"]
    pub fn switch_loadable_module_get_chat_application_interface(
        name: *const ::std::os::raw::c_char,
    ) -> *mut switch_chat_application_interface_t;
}
extern "C" {
    pub fn switch_core_execute_chat_app(
        message: *mut switch_event_t,
        app: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Retrieve the API interface by it's registered name\n\\param name the name of the API\n\\return the desired API interface"]
    pub fn switch_loadable_module_get_api_interface(
        name: *const ::std::os::raw::c_char,
    ) -> *mut switch_api_interface_t;
}
extern "C" {
    #[doc = "\\brief Retrieve the JSON API interface by it's registered name\n\\param name the name of the API\n\\return the desired API interface"]
    pub fn switch_loadable_module_get_json_api_interface(
        name: *const ::std::os::raw::c_char,
    ) -> *mut switch_json_api_interface_t;
}
extern "C" {
    #[doc = "\\brief Retrieve the file format interface by it's registered name\n\\param name the name of the file format\n\\return the desired file format interface"]
    pub fn switch_loadable_module_get_file_interface(
        name: *const ::std::os::raw::c_char,
        modname: *const ::std::os::raw::c_char,
    ) -> *mut switch_file_interface_t;
}
extern "C" {
    #[doc = "\\brief Retrieve the database interface by it's registered name\n\\param name the name of the dsn prefix\n\\return the desired database format interface"]
    pub fn switch_loadable_module_get_database_interface(
        name: *const ::std::os::raw::c_char,
        modname: *const ::std::os::raw::c_char,
    ) -> *mut switch_database_interface_t;
}
extern "C" {
    #[doc = "\\brief Retrieve the speech interface by it's registered name\n\\param name the name of the speech interface\n\\return the desired speech interface"]
    pub fn switch_loadable_module_get_speech_interface(
        name: *const ::std::os::raw::c_char,
    ) -> *mut switch_speech_interface_t;
}
extern "C" {
    #[doc = "\\brief Retrieve the asr interface by it's registered name\n\\param name the name of the asr interface\n\\return the desired asr interface"]
    pub fn switch_loadable_module_get_asr_interface(
        name: *const ::std::os::raw::c_char,
    ) -> *mut switch_asr_interface_t;
}
extern "C" {
    #[doc = "\\brief Retrieve the directory interface by it's registered name\n\\param name the name of the directory interface\n\\return the desired directory interface"]
    pub fn switch_loadable_module_get_directory_interface(
        name: *const ::std::os::raw::c_char,
    ) -> *mut switch_directory_interface_t;
}
extern "C" {
    #[doc = "\\brief Retrieve the chat interface by it's registered name\n\\param name the name of the chat interface\n\\return the desired chat interface"]
    pub fn switch_loadable_module_get_chat_interface(
        name: *const ::std::os::raw::c_char,
    ) -> *mut switch_chat_interface_t;
}
extern "C" {
    #[doc = "\\brief Retrieve the say interface by it's registered name\n\\param name the name of the say interface\n\\return the desired say interface"]
    pub fn switch_loadable_module_get_say_interface(
        name: *const ::std::os::raw::c_char,
    ) -> *mut switch_say_interface_t;
}
extern "C" {
    #[doc = "\\brief Retrieve the management interface by it's registered name\n\\param relative_oid the relative oid of the management interface\n\\return the desired management interface"]
    pub fn switch_loadable_module_get_management_interface(
        relative_oid: *const ::std::os::raw::c_char,
    ) -> *mut switch_management_interface_t;
}
extern "C" {
    #[doc = "\\brief Retrieve the limit interface by it's registered name\n\\param name the name of the limit interface\n\\return the desired limit interface"]
    pub fn switch_loadable_module_get_limit_interface(
        name: *const ::std::os::raw::c_char,
    ) -> *mut switch_limit_interface_t;
}
extern "C" {
    #[doc = "\\brief Retrieve the list of loaded codecs into an array\n\\param array the array to populate\n\\param arraylen the max size in elements of the array\n\\return the number of elements added to the array"]
    pub fn switch_loadable_module_get_codecs(
        array: *mut *const switch_codec_implementation_t,
        arraylen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Retrieve the list of loaded codecs into an array based on another array showing the sorted order\n\\param array the array to populate\n\\param arraylen the max size in elements of the array\n\\param prefs the array of preferred codec names\n\\param preflen the size in elements of the prefs\n\\return the number of elements added to the array\n\\note this function only considers codecs that are listed in the \"prefs\" array and ignores the rest."]
    pub fn switch_loadable_module_get_codecs_sorted(
        array: *mut *const switch_codec_implementation_t,
        fmtp_array: *mut [::std::os::raw::c_char; 256usize],
        arraylen: ::std::os::raw::c_int,
        prefs: *mut *mut ::std::os::raw::c_char,
        preflen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Execute a registered API command\n\\param cmd the name of the API command to execute\n\\param arg the optional arguement to the command\n\\param session an optional session\n\\param stream stream for output\n\\return the status returned by the API call"]
    pub fn switch_api_execute(
        cmd: *const ::std::os::raw::c_char,
        arg: *const ::std::os::raw::c_char,
        session: *mut switch_core_session_t,
        stream: *mut switch_stream_handle_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Execute a registered JSON API command\n\\param json the name of the JSON API command to execute\n\\param arg the optional arguement to the command\n\\param session an optional session\n\\param stream stream for output\n\\return the status returned by the API call"]
    pub fn switch_json_api_execute(
        json: *mut cJSON,
        session: *mut switch_core_session_t,
        retval: *mut *mut cJSON,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Load a module\n\\param dir the directory where the module resides\n\\param fname the file name of the module\n\\param runtime option to start the runtime thread if it exists\n\\param err pointer to error message\n\\return the status"]
    pub fn switch_loadable_module_load_module(
        dir: *const ::std::os::raw::c_char,
        fname: *const ::std::os::raw::c_char,
        runtime: switch_bool_t,
        err: *mut *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Check if a module is loaded\n\\param mod the module name\n\\return the status"]
    pub fn switch_loadable_module_exists(mod_: *const ::std::os::raw::c_char) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Protect module from beeing unloaded\n\\param mod the module name\n\\return the status"]
    pub fn switch_loadable_module_protect(mod_: *const ::std::os::raw::c_char) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Unoad a module\n\\param dir the directory where the module resides\n\\param fname the file name of the module\n\\param err pointer to error message\n\\return the status"]
    pub fn switch_loadable_module_unload_module(
        dir: *const ::std::os::raw::c_char,
        fname: *const ::std::os::raw::c_char,
        force: switch_bool_t,
        err: *mut *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Load a module\n\\param module_interface a pointer to a pointer to aim at your module's local interface\n\\param filename the path to the module's dll or so file\n\\return SWITCH_STATUS_SUCCESS on a successful load"]
    pub fn switch_module_load(
        module_interface: *mut *mut switch_loadable_module_interface_t,
        filename: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_module_runtime() -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Shutdown a module\n\\return SWITCH_STATUS_SUCCESS on a successful shutdown"]
    pub fn switch_module_shutdown() -> switch_status_t;
}
extern "C" {
    pub fn switch_core_codec_next_id() -> u32;
}
extern "C" {
    pub fn switch_core_get_secondary_recover_callback(
        key: *const ::std::os::raw::c_char,
    ) -> switch_core_recover_callback_t;
}
extern "C" {
    pub fn switch_core_register_secondary_recover_callback(
        key: *const ::std::os::raw::c_char,
        cb: switch_core_recover_callback_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_unregister_secondary_recover_callback(key: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = "\\brief A simple comand loop that reads input from the terminal"]
    pub fn switch_console_loop();
}
extern "C" {
    #[doc = "\\brief A method akin to printf that allows you to redirect output to a specific console \"channel\""]
    pub fn switch_console_printf(
        channel: switch_text_channel_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn switch_console_stream_raw_write(
        handle: *mut switch_stream_handle_t,
        data: *mut u8,
        datalen: switch_size_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief A method akin to printf for dealing with api streams"]
    pub fn switch_console_stream_write(
        handle: *mut switch_stream_handle_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_stream_write_file_contents(
        stream: *mut switch_stream_handle_t,
        path: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_console_init(pool: *mut switch_memory_pool_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_console_shutdown() -> switch_status_t;
}
extern "C" {
    pub fn switch_console_add_complete_func(
        name: *const ::std::os::raw::c_char,
        cb: switch_console_complete_callback_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_console_del_complete_func(name: *const ::std::os::raw::c_char)
        -> switch_status_t;
}
extern "C" {
    pub fn switch_console_run_complete_func(
        func: *const ::std::os::raw::c_char,
        line: *const ::std::os::raw::c_char,
        last_word: *const ::std::os::raw::c_char,
        matches: *mut *mut switch_console_callback_match_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_console_push_match_unique(
        matches: *mut *mut switch_console_callback_match_t,
        new_val: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn switch_console_push_match(
        matches: *mut *mut switch_console_callback_match_t,
        new_val: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn switch_console_free_matches(matches: *mut *mut switch_console_callback_match_t);
}
extern "C" {
    pub fn switch_console_complete(
        line: *const ::std::os::raw::c_char,
        last_word: *const ::std::os::raw::c_char,
        console_out: *mut FILE,
        stream: *mut switch_stream_handle_t,
        xml: switch_xml_t,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn switch_console_sort_matches(matches: *mut switch_console_callback_match_t);
}
extern "C" {
    pub fn switch_console_save_history();
}
extern "C" {
    pub fn switch_console_expand_alias(
        cmd: *mut ::std::os::raw::c_char,
        arg: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_console_execute(
        xcmd: *mut ::std::os::raw::c_char,
        rec: ::std::os::raw::c_int,
        istream: *mut switch_stream_handle_t,
    ) -> switch_status_t;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __fpclassify(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpclassifyf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpclassifyl(arg1: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbit(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitl(arg1: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acos(arg1: f64) -> f64;
}
extern "C" {
    pub fn acosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acosl(arg1: u128) -> u128;
}
extern "C" {
    pub fn acosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn acoshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acoshl(arg1: u128) -> u128;
}
extern "C" {
    pub fn asin(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asinl(arg1: u128) -> u128;
}
extern "C" {
    pub fn asinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asinhl(arg1: u128) -> u128;
}
extern "C" {
    pub fn atan(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atanl(arg1: u128) -> u128;
}
extern "C" {
    pub fn atan2(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn atan2f(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn atan2l(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn atanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atanhl(arg1: u128) -> u128;
}
extern "C" {
    pub fn cbrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cbrtl(arg1: u128) -> u128;
}
extern "C" {
    pub fn ceil(arg1: f64) -> f64;
}
extern "C" {
    pub fn ceilf(arg1: f32) -> f32;
}
extern "C" {
    pub fn ceill(arg1: u128) -> u128;
}
extern "C" {
    pub fn copysign(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn copysignf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn copysignl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn cos(arg1: f64) -> f64;
}
extern "C" {
    pub fn cosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cosl(arg1: u128) -> u128;
}
extern "C" {
    pub fn cosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn coshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn coshl(arg1: u128) -> u128;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn exp(arg1: f64) -> f64;
}
extern "C" {
    pub fn expf(arg1: f32) -> f32;
}
extern "C" {
    pub fn expl(arg1: u128) -> u128;
}
extern "C" {
    pub fn exp2(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn exp2l(arg1: u128) -> u128;
}
extern "C" {
    pub fn expm1(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn expm1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn fabs(arg1: f64) -> f64;
}
extern "C" {
    pub fn fabsf(arg1: f32) -> f32;
}
extern "C" {
    pub fn fabsl(arg1: u128) -> u128;
}
extern "C" {
    pub fn fdim(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fdimf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fdiml(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn floor(arg1: f64) -> f64;
}
extern "C" {
    pub fn floorf(arg1: f32) -> f32;
}
extern "C" {
    pub fn floorl(arg1: u128) -> u128;
}
extern "C" {
    pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
}
extern "C" {
    pub fn fmal(arg1: u128, arg2: u128, arg3: u128) -> u128;
}
extern "C" {
    pub fn fmax(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmaxl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn fmin(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fminf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fminl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn fmod(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmodf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmodl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn frexp(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn frexpf(arg1: f32, arg2: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn frexpl(arg1: u128, arg2: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn hypot(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn hypotf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn hypotl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn ilogb(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ilogbf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ilogbl(arg1: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ldexp(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexpf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpl(arg1: u128, arg2: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn llrint(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llrintf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llrintl(arg1: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llround(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundl(arg1: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn log(arg1: f64) -> f64;
}
extern "C" {
    pub fn logf(arg1: f32) -> f32;
}
extern "C" {
    pub fn logl(arg1: u128) -> u128;
}
extern "C" {
    pub fn log10(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn log10l(arg1: u128) -> u128;
}
extern "C" {
    pub fn log1p(arg1: f64) -> f64;
}
extern "C" {
    pub fn log1pf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log1pl(arg1: u128) -> u128;
}
extern "C" {
    pub fn log2(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn log2l(arg1: u128) -> u128;
}
extern "C" {
    pub fn logb(arg1: f64) -> f64;
}
extern "C" {
    pub fn logbf(arg1: f32) -> f32;
}
extern "C" {
    pub fn logbl(arg1: u128) -> u128;
}
extern "C" {
    pub fn lrint(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lrintf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lrintl(arg1: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lround(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lroundf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lroundl(arg1: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
}
extern "C" {
    pub fn modfl(arg1: u128, arg2: *mut u128) -> u128;
}
extern "C" {
    pub fn nan(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nanf(arg1: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn nanl(arg1: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn nearbyint(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn nearbyintl(arg1: u128) -> u128;
}
extern "C" {
    pub fn nextafter(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn nextafterl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn nexttoward(arg1: f64, arg2: u128) -> f64;
}
extern "C" {
    pub fn nexttowardf(arg1: f32, arg2: u128) -> f32;
}
extern "C" {
    pub fn nexttowardl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn pow(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn powl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn remainder(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remainderf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn remainderl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn remquo(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn remquof(arg1: f32, arg2: f32, arg3: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn remquol(arg1: u128, arg2: u128, arg3: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn rint(arg1: f64) -> f64;
}
extern "C" {
    pub fn rintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn rintl(arg1: u128) -> u128;
}
extern "C" {
    pub fn round(arg1: f64) -> f64;
}
extern "C" {
    pub fn roundf(arg1: f32) -> f32;
}
extern "C" {
    pub fn roundl(arg1: u128) -> u128;
}
extern "C" {
    pub fn scalbln(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn scalblnf(arg1: f32, arg2: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn scalblnl(arg1: u128, arg2: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn scalbn(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn scalbnf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn scalbnl(arg1: u128, arg2: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn sin(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sinl(arg1: u128) -> u128;
}
extern "C" {
    pub fn sinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sinhl(arg1: u128) -> u128;
}
extern "C" {
    pub fn sqrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn sqrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sqrtl(arg1: u128) -> u128;
}
extern "C" {
    pub fn tan(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tanl(arg1: u128) -> u128;
}
extern "C" {
    pub fn tanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tanhl(arg1: u128) -> u128;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn trunc(arg1: f64) -> f64;
}
extern "C" {
    pub fn truncf(arg1: f32) -> f32;
}
extern "C" {
    pub fn truncl(arg1: u128) -> u128;
}
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn drem(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn dremf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn finite(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitef(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalb(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn scalbf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn significand(arg1: f64) -> f64;
}
extern "C" {
    pub fn significandf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, arg2: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn lgammal_r(arg1: u128, arg2: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn sincos(arg1: f64, arg2: *mut f64, arg3: *mut f64);
}
extern "C" {
    pub fn sincosf(arg1: f32, arg2: *mut f32, arg3: *mut f32);
}
extern "C" {
    pub fn sincosl(arg1: u128, arg2: *mut u128, arg3: *mut u128);
}
extern "C" {
    pub fn exp10(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn exp10l(arg1: u128) -> u128;
}
extern "C" {
    pub fn pow10(arg1: f64) -> f64;
}
extern "C" {
    pub fn pow10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn pow10l(arg1: u128) -> u128;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_network_port_range {
    pub port: ::std::os::raw::c_int,
    pub ports: [::std::os::raw::c_int; 10usize],
    pub min_port: ::std::os::raw::c_int,
    pub max_port: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_switch_network_port_range() {
    const UNINIT: ::std::mem::MaybeUninit<switch_network_port_range> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_network_port_range>(),
        52usize,
        concat!("Size of: ", stringify!(switch_network_port_range))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_network_port_range>(),
        4usize,
        concat!("Alignment of ", stringify!(switch_network_port_range))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_network_port_range),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ports) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_network_port_range),
            "::",
            stringify!(ports)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_port) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_network_port_range),
            "::",
            stringify!(min_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_port) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_network_port_range),
            "::",
            stringify!(max_port)
        )
    );
}
pub type switch_network_port_range_t = switch_network_port_range;
pub type switch_network_port_range_p = *mut switch_network_port_range_t;
extern "C" {
    pub fn old_switch_toupper(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn old_switch_tolower(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_isalnum(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_isalpha(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_iscntrl(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_isdigit(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_isgraph(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_islower(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_isprint(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_ispunct(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_isspace(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_isupper(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_isxdigit(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ip_t {
    pub v4: u32,
    pub v6: in6_addr,
}
#[test]
fn bindgen_test_layout_ip_t() {
    const UNINIT: ::std::mem::MaybeUninit<ip_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_t>(),
        16usize,
        concat!("Size of: ", stringify!(ip_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v4) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ip_t), "::", stringify!(v4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v6) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ip_t), "::", stringify!(v6))
    );
}
extern "C" {
    pub fn switch_testv6_subnet(_ip: ip_t, _net: ip_t, _mask: ip_t) -> switch_bool_t;
}
extern "C" {
    pub fn switch_print_host(
        addr: *mut switch_sockaddr_t,
        buf: *mut ::std::os::raw::c_char,
        len: switch_size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_b64_encode(
        in_: *mut ::std::os::raw::c_uchar,
        ilen: switch_size_t,
        out: *mut ::std::os::raw::c_uchar,
        olen: switch_size_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_b64_decode(
        in_: *const ::std::os::raw::c_char,
        out: *mut ::std::os::raw::c_char,
        olen: switch_size_t,
    ) -> switch_size_t;
}
extern "C" {
    pub fn switch_amp_encode(
        s: *mut ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_char,
        len: switch_size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_fd_read_line(
        fd: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        len: switch_size_t,
    ) -> switch_size_t;
}
extern "C" {
    pub fn switch_fd_read_dline(
        fd: ::std::os::raw::c_int,
        buf: *mut *mut ::std::os::raw::c_char,
        len: *mut switch_size_t,
    ) -> switch_size_t;
}
extern "C" {
    pub fn switch_fp_read_dline(
        fd: *mut FILE,
        buf: *mut *mut ::std::os::raw::c_char,
        len: *mut switch_size_t,
    ) -> switch_size_t;
}
extern "C" {
    pub fn switch_frame_alloc(
        frame: *mut *mut switch_frame_t,
        size: switch_size_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_frame_dup(
        orig: *mut switch_frame_t,
        clone: *mut *mut switch_frame_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_frame_free(frame: *mut *mut switch_frame_t) -> switch_status_t;
}
extern "C" {
    #[doc = " \\brief Check if a 32 bit unsigned number is in a range.\n \\param str string to check. Should not contain non-digit characters.\n \\param from start of range including this number\n \\param to end of range including this number\n \\return true or false"]
    pub fn switch_is_uint_in_range(
        str_: *const ::std::os::raw::c_char,
        from: ::std::os::raw::c_uint,
        to: ::std::os::raw::c_uint,
    ) -> switch_bool_t;
}
extern "C" {
    pub fn switch_is_number(str_: *const ::std::os::raw::c_char) -> switch_bool_t;
}
extern "C" {
    pub fn switch_is_leading_number(str_: *const ::std::os::raw::c_char) -> switch_bool_t;
}
extern "C" {
    pub fn switch_find_parameter(
        str_: *const ::std::os::raw::c_char,
        param: *const ::std::os::raw::c_char,
        pool: *mut switch_memory_pool_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_resolve_host(
        host: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief find local ip of the box\n\\param buf the buffer to write the ip address found into\n\\param len the length of the buf\n\\param mask the CIDR found (AF_INET only)\n\\param family the address family to return (AF_INET or AF_INET6)\n\\return SWITCH_STATUS_SUCCESSS for success, otherwise failure"]
    pub fn switch_find_local_ip(
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        mask: *mut ::std::os::raw::c_int,
        family: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief find primary ip of the specified interface\n\\param buf the buffer to write the ip address found into\n\\param len the length of the buf\n\\param mask the CIDR found (AF_INET only)\n\\param ifname interface name to check\n\\param family the address family to return (AF_INET or AF_INET6)\n\\return SWITCH_STATUS_SUCCESSS for success, otherwise failure"]
    pub fn switch_find_interface_ip(
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        mask: *mut ::std::os::raw::c_int,
        ifname: *const ::std::os::raw::c_char,
        family: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief find the char representation of an ip adress\n\\param buf the buffer to write the ip adress found into\n\\param len the length of the buf\n\\param sa the struct sockaddr * to get the adress from\n\\param salen the length of sa\n\\return the ip adress string"]
    pub fn get_addr(
        buf: *mut ::std::os::raw::c_char,
        len: switch_size_t,
        sa: *mut sockaddr,
        salen: socklen_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_addr6(
        buf: *mut ::std::os::raw::c_char,
        len: switch_size_t,
        sa: *mut sockaddr_in6,
        salen: socklen_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_addr_int(sa: *mut switch_sockaddr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_cmp_addr(
        sa1: *mut switch_sockaddr_t,
        sa2: *mut switch_sockaddr_t,
        ip_only: switch_bool_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_cp_addr(
        sa1: *mut switch_sockaddr_t,
        sa2: *mut switch_sockaddr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief get the port number of an ip address\n\\param sa the struct sockaddr * to get the port from\n\\return the ip adress string"]
    pub fn get_port(sa: *mut sockaddr) -> ::std::os::raw::c_ushort;
}
pub const switch_uri_flags_SWITCH_URI_NUMERIC_HOST: switch_uri_flags = 1;
pub const switch_uri_flags_SWITCH_URI_NUMERIC_PORT: switch_uri_flags = 2;
pub const switch_uri_flags_SWITCH_URI_NO_SCOPE: switch_uri_flags = 4;
#[doc = "\\brief flags to be used with switch_build_uri()"]
pub type switch_uri_flags = ::std::os::raw::c_uint;
extern "C" {
    #[doc = "\\brief build a URI string from components\n\\param uri output string\n\\param size maximum size of output string (including trailing null)\n\\param scheme URI scheme\n\\param user user part or null if none\n\\param sa host address\n\\param flags logical OR-ed combination of flags from \\ref switch_uri_flags\n\\return number of characters printed (not including the trailing null)"]
    pub fn switch_build_uri(
        uri: *mut ::std::os::raw::c_char,
        size: switch_size_t,
        scheme: *const ::std::os::raw::c_char,
        user: *const ::std::os::raw::c_char,
        sa: *const switch_sockaddr_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Return a printable name of a switch_priority_t\n\\param priority the priority to get the name of\n\\return the printable form of the priority"]
    pub fn switch_priority_name(priority: switch_priority_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Return the RFC2833 character based on an event id\n\\param event the event id to convert\n\\return the character represented by the event or null for an invalid event"]
    pub fn switch_rfc2833_to_char(event: ::std::os::raw::c_int) -> ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Return the RFC2833 event based on an key character\n\\param key the charecter to encode\n\\return the event id for the specified character or -1 on an invalid input"]
    pub fn switch_char_to_rfc2833(key: ::std::os::raw::c_char) -> ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = "\\brief Converts a string representation of a date into a switch_time_t\n\\param in the string\n\\return the epoch time in usec"]
    pub fn switch_str_time(in_: *const ::std::os::raw::c_char) -> switch_time_t;
}
extern "C" {
    #[doc = "\\brief Separate a string into an array based on a character delimiter\n\\param buf the string to parse\n\\param delim the character delimiter\n\\param array the array to split the values into\n\\param arraylen the max number of elements in the array\n\\return the number of elements added to the array"]
    pub fn switch_separate_string(
        buf: *mut ::std::os::raw::c_char,
        delim: ::std::os::raw::c_char,
        array: *mut *mut ::std::os::raw::c_char,
        arraylen: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn switch_separate_string_string(
        buf: *mut ::std::os::raw::c_char,
        delim: *mut ::std::os::raw::c_char,
        array: *mut *mut ::std::os::raw::c_char,
        arraylen: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn switch_strip_spaces(
        str_: *mut ::std::os::raw::c_char,
        dup: switch_bool_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_strip_whitespace(
        str_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_strip_commas(
        in_: *mut ::std::os::raw::c_char,
        out: *mut ::std::os::raw::c_char,
        len: switch_size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_strip_nonnumerics(
        in_: *mut ::std::os::raw::c_char,
        out: *mut ::std::os::raw::c_char,
        len: switch_size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_separate_paren_args(
        str_: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_stristr(
        instr: *const ::std::os::raw::c_char,
        str_: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_is_lan_addr(ip: *const ::std::os::raw::c_char) -> switch_bool_t;
}
extern "C" {
    pub fn switch_replace_char(
        str_: *mut ::std::os::raw::c_char,
        from: ::std::os::raw::c_char,
        to: ::std::os::raw::c_char,
        dup: switch_bool_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_ast2regex(
        pat: *const ::std::os::raw::c_char,
        rbuf: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> switch_bool_t;
}
extern "C" {
    pub fn switch_pool_strip_whitespace(
        pool: *mut switch_memory_pool_t,
        str_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Escape a string by prefixing a list of characters with an escape character\n\\param pool a memory pool to use\n\\param in the string\n\\param delim the list of characters to escape\n\\param esc the escape character\n\\return the escaped string"]
    pub fn switch_escape_char(
        pool: *mut switch_memory_pool_t,
        in_: *mut ::std::os::raw::c_char,
        delim: *const ::std::os::raw::c_char,
        esc: ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_escape_string(
        in_: *const ::std::os::raw::c_char,
        out: *mut ::std::os::raw::c_char,
        outlen: switch_size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_escape_string_pool(
        in_: *const ::std::os::raw::c_char,
        pool: *mut switch_memory_pool_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Wait for a socket\n\\param poll the pollfd to wait on\n\\param ms the number of milliseconds to wait\n\\return the requested condition"]
    pub fn switch_socket_waitfor(
        poll: *mut switch_pollfd_t,
        ms: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Create a pointer to the file name in a given file path eliminating the directory name\n\\return the pointer to the next character after the final / or \\\\ characters"]
    pub fn switch_cut_path(in_: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_string_replace(
        string: *const ::std::os::raw::c_char,
        search: *const ::std::os::raw::c_char,
        replace: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_string_match(
        string: *const ::std::os::raw::c_char,
        string_len: usize,
        search: *const ::std::os::raw::c_char,
        search_len: usize,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_strcasecmp_any(str_: *const ::std::os::raw::c_char, ...)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Quote shell argument\n\\param string the string to quote (example: a ' b\"' c)\n\\return the quoted string (gives: 'a '\\'' b\"'\\'' c' for unices, \"a ' b ' c\" for MS Windows), should be freed"]
    pub fn switch_util_quote_shell_arg(
        string: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Quote shell argument, allocating from pool if provided\n\\param string the string to quote (example: a ' b\"' c)\n\\param pool a memory pool to use\n\\return the quoted string (gives: 'a '\\'' b\"'\\'' c' for unices, \"a ' b ' c\" for MS Windows), if pool not provided, returned value should be freed"]
    pub fn switch_util_quote_shell_arg_pool(
        string: *const ::std::os::raw::c_char,
        pool: *mut switch_memory_pool_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_url_encode_opt(
        url: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_char,
        len: usize,
        double_encode: switch_bool_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_url_encode(
        url: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_url_decode(s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_core_url_encode_opt(
        pool: *mut switch_memory_pool_t,
        url: *const ::std::os::raw::c_char,
        double_encode: switch_bool_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_core_url_encode(
        pool: *mut switch_memory_pool_t,
        url: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_core_session_url_encode_opt(
        session: *mut switch_core_session_t,
        url: *const ::std::os::raw::c_char,
        double_encode: switch_bool_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_core_session_url_encode(
        session: *mut switch_core_session_t,
        url: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_simple_email(
        to: *const ::std::os::raw::c_char,
        from: *const ::std::os::raw::c_char,
        headers: *const ::std::os::raw::c_char,
        body: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        convert_cmd: *const ::std::os::raw::c_char,
        convert_ext: *const ::std::os::raw::c_char,
    ) -> switch_bool_t;
}
extern "C" {
    pub fn switch_find_end_paren(
        s: *const ::std::os::raw::c_char,
        open: ::std::os::raw::c_char,
        close: ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_parse_cidr(
        string: *const ::std::os::raw::c_char,
        ip: *mut ip_t,
        mask: *mut ip_t,
        bitp: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_network_list_create(
        list: *mut *mut switch_network_list_t,
        name: *const ::std::os::raw::c_char,
        default_type: switch_bool_t,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_network_list_add_cidr_token(
        list: *mut switch_network_list_t,
        cidr_str: *const ::std::os::raw::c_char,
        ok: switch_bool_t,
        token: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_network_ipv4_mapped_ipv6_addr(
        ip_str: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_network_list_add_host_mask(
        list: *mut switch_network_list_t,
        host: *const ::std::os::raw::c_char,
        mask_str: *const ::std::os::raw::c_char,
        ok: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_network_list_add_cidr_port_token(
        list: *mut switch_network_list_t,
        cidr_str: *const ::std::os::raw::c_char,
        ok: switch_bool_t,
        token: *const ::std::os::raw::c_char,
        port: switch_network_port_range_p,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_network_list_add_host_port_mask(
        list: *mut switch_network_list_t,
        host: *const ::std::os::raw::c_char,
        mask_str: *const ::std::os::raw::c_char,
        ok: switch_bool_t,
        port: switch_network_port_range_p,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_network_list_validate_ip_port_token(
        list: *mut switch_network_list_t,
        ip: u32,
        port: ::std::os::raw::c_int,
        token: *mut *const ::std::os::raw::c_char,
    ) -> switch_bool_t;
}
extern "C" {
    pub fn switch_network_list_validate_ip6_port_token(
        list: *mut switch_network_list_t,
        ip: ip_t,
        port: ::std::os::raw::c_int,
        token: *mut *const ::std::os::raw::c_char,
    ) -> switch_bool_t;
}
extern "C" {
    pub fn switch_network_list_validate_ip_token(
        list: *mut switch_network_list_t,
        ip: u32,
        token: *mut *const ::std::os::raw::c_char,
    ) -> switch_bool_t;
}
extern "C" {
    pub fn switch_network_list_validate_ip6_token(
        list: *mut switch_network_list_t,
        ip: ip_t,
        token: *mut *const ::std::os::raw::c_char,
    ) -> switch_bool_t;
}
extern "C" {
    pub fn switch_inet_pton(
        af: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_dow_int2str(val: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_dow_str2int(exp: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_dow_cmp(
        exp: *const ::std::os::raw::c_char,
        val: ::std::os::raw::c_int,
    ) -> switch_bool_t;
}
extern "C" {
    pub fn switch_number_cmp(
        exp: *const ::std::os::raw::c_char,
        val: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_tod_cmp(
        exp: *const ::std::os::raw::c_char,
        val: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_fulldate_cmp(
        exp: *const ::std::os::raw::c_char,
        ts: *mut switch_time_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_split_date(
        exp: *const ::std::os::raw::c_char,
        year: *mut ::std::os::raw::c_int,
        month: *mut ::std::os::raw::c_int,
        day: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn switch_split_time(
        exp: *const ::std::os::raw::c_char,
        hour: *mut ::std::os::raw::c_int,
        min: *mut ::std::os::raw::c_int,
        sec: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "\\brief Split a user@domain string as user and domain\n\\param in the input string\n\\param user the string to put the user into\n\\param domain the string to put the domain into\n\\return 1 if successfull\n\\note Extended formats protocol:user@domain:port (Example: sip:toto@example.org)"]
    pub fn switch_split_user_domain(
        in_: *mut ::std::os::raw::c_char,
        user: *mut *mut ::std::os::raw::c_char,
        domain: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_calloc(nmemb: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn switch_uuid_str(
        buf: *mut ::std::os::raw::c_char,
        len: switch_size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_format_number(num: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_atoui(nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn switch_atoul(nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Portable version of strerror_r(), work around for the incompatible\n return type of GNU and XSI variants.\n \\param[in]\terrnum\tError number\n \\param[both]\tbuf\tBuffer for error message\n \\param[in]\tbuflen\tSize of message buffer\n \\return\tPointer to message buffer, returning error message or \"Unknown error xxx\" if none found"]
    pub fn switch_strerror_r(
        errnum: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        buflen: switch_size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_wait_sock(
        sock: switch_os_socket_t,
        ms: u32,
        flags: switch_poll_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_wait_socklist(
        waitlist: *mut switch_waitlist_t,
        len: u32,
        ms: u32,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_http_request_s {
    pub method: *const ::std::os::raw::c_char,
    pub uri: *const ::std::os::raw::c_char,
    pub qs: *const ::std::os::raw::c_char,
    pub host: *const ::std::os::raw::c_char,
    pub port: switch_port_t,
    pub from: *const ::std::os::raw::c_char,
    pub user_agent: *const ::std::os::raw::c_char,
    pub referer: *const ::std::os::raw::c_char,
    pub user: *const ::std::os::raw::c_char,
    pub keepalive: switch_bool_t,
    pub content_type: *const ::std::os::raw::c_char,
    pub content_length: switch_size_t,
    pub bytes_header: switch_size_t,
    pub bytes_read: switch_size_t,
    pub bytes_buffered: switch_size_t,
    pub headers: *mut switch_event_t,
    pub user_data: *mut ::std::os::raw::c_void,
    pub _buffer: *mut ::std::os::raw::c_char,
    pub _destroy_headers: switch_bool_t,
}
#[test]
fn bindgen_test_layout_switch_http_request_s() {
    const UNINIT: ::std::mem::MaybeUninit<switch_http_request_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_http_request_s>(),
        152usize,
        concat!("Size of: ", stringify!(switch_http_request_s))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_http_request_s>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_http_request_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_http_request_s),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uri) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_http_request_s),
            "::",
            stringify!(uri)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_http_request_s),
            "::",
            stringify!(qs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_http_request_s),
            "::",
            stringify!(host)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_http_request_s),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).from) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_http_request_s),
            "::",
            stringify!(from)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_agent) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_http_request_s),
            "::",
            stringify!(user_agent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).referer) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_http_request_s),
            "::",
            stringify!(referer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_http_request_s),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keepalive) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_http_request_s),
            "::",
            stringify!(keepalive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content_type) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_http_request_s),
            "::",
            stringify!(content_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content_length) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_http_request_s),
            "::",
            stringify!(content_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes_header) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_http_request_s),
            "::",
            stringify!(bytes_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes_read) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_http_request_s),
            "::",
            stringify!(bytes_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes_buffered) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_http_request_s),
            "::",
            stringify!(bytes_buffered)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).headers) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_http_request_s),
            "::",
            stringify!(headers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_http_request_s),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._buffer) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_http_request_s),
            "::",
            stringify!(_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._destroy_headers) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_http_request_s),
            "::",
            stringify!(_destroy_headers)
        )
    );
}
pub type switch_http_request_t = switch_http_request_s;
extern "C" {
    #[doc = " parse http headers in a buffer\n return status of success or not\n \\param[in]\tbuffer the buffer start from the very begining of the http request, e.g. 'GET '\n \\param[in]\tdatalen the buffer length\n \\param[out]\tthe http request pointer or null, need destroy later if got non-NULL pointer\n \\return\tSWITCH_STATUS_SUCCESS | SWITCH_STATUS_FALSE"]
    pub fn switch_http_parse_header(
        buffer: *mut ::std::os::raw::c_char,
        datalen: u32,
        request: *mut switch_http_request_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_http_free_request(request: *mut switch_http_request_t);
}
extern "C" {
    pub fn switch_http_dump_request(request: *mut switch_http_request_t);
}
extern "C" {
    #[doc = " parse http query string\n \\param[in]\trequest the http request object\n \\param[in]\tqs the query string buffer\n\n qs buffer will be modified, so be sure to dup the qs before passing into this function if you want to keep the original string untouched\n if qs is NULL, the it will parse request->qs, request->qs will be duplicated before parse to avoid being modified"]
    pub fn switch_http_parse_qs(
        request: *mut switch_http_request_t,
        qs: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn switch_frame_buffer_free(
        fb: *mut switch_frame_buffer_t,
        frameP: *mut *mut switch_frame_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_frame_buffer_dup(
        fb: *mut switch_frame_buffer_t,
        orig: *mut switch_frame_t,
        clone: *mut *mut switch_frame_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_frame_buffer_destroy(fbP: *mut *mut switch_frame_buffer_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_frame_buffer_create(
        fbP: *mut *mut switch_frame_buffer_t,
        qlen: switch_size_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_frame_buffer_push(
        fb: *mut switch_frame_buffer_t,
        ptr: *mut ::std::os::raw::c_void,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_frame_buffer_trypush(
        fb: *mut switch_frame_buffer_t,
        ptr: *mut ::std::os::raw::c_void,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_frame_buffer_pop(
        fb: *mut switch_frame_buffer_t,
        ptr: *mut *mut ::std::os::raw::c_void,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_frame_buffer_trypop(
        fb: *mut switch_frame_buffer_t,
        ptr: *mut *mut ::std::os::raw::c_void,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_frame_buffer_size(fb: *mut switch_frame_buffer_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_cputime {
    pub userms: i64,
    pub kernelms: i64,
}
#[test]
fn bindgen_test_layout_switch_cputime() {
    const UNINIT: ::std::mem::MaybeUninit<switch_cputime> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_cputime>(),
        16usize,
        concat!("Size of: ", stringify!(switch_cputime))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_cputime>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_cputime))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).userms) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_cputime),
            "::",
            stringify!(userms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kernelms) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_cputime),
            "::",
            stringify!(kernelms)
        )
    );
}
extern "C" {
    #[doc = "/ Return used CPU time in this process for user and kernel code"]
    pub fn switch_getcputime(t: *mut switch_cputime);
}
extern "C" {
    pub fn switch_html_strip(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_getpid() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn switch_digest(
        digest_name: *const ::std::os::raw::c_char,
        digest: *mut *mut ::std::os::raw::c_uchar,
        input: *const ::std::os::raw::c_void,
        inputLen: switch_size_t,
        outputlen: *mut ::std::os::raw::c_uint,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_digest_string(
        digest_name: *const ::std::os::raw::c_char,
        digest_str: *mut *mut ::std::os::raw::c_char,
        input: *const ::std::os::raw::c_void,
        inputLen: switch_size_t,
        outputlen: *mut ::std::os::raw::c_uint,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_must_strdup(_s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_memory_usage_stream(
        stream: *mut switch_stream_handle_t,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct profile_node_s {
    pub var: *mut ::std::os::raw::c_char,
    pub val: *mut ::std::os::raw::c_char,
    pub next: *mut profile_node_s,
}
#[test]
fn bindgen_test_layout_profile_node_s() {
    const UNINIT: ::std::mem::MaybeUninit<profile_node_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<profile_node_s>(),
        24usize,
        concat!("Size of: ", stringify!(profile_node_s))
    );
    assert_eq!(
        ::std::mem::align_of::<profile_node_s>(),
        8usize,
        concat!("Alignment of ", stringify!(profile_node_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).var) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(profile_node_s),
            "::",
            stringify!(var)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(profile_node_s),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(profile_node_s),
            "::",
            stringify!(next)
        )
    );
}
pub type profile_node_t = profile_node_s;
#[doc = " \\brief Call Specific Data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_caller_profile {
    #[doc = " The Call's User Name"]
    pub username: *const ::std::os::raw::c_char,
    #[doc = " The name of the dialplan"]
    pub dialplan: *const ::std::os::raw::c_char,
    #[doc = " Caller ID Name"]
    pub caller_id_name: *const ::std::os::raw::c_char,
    #[doc = " Caller ID Number"]
    pub caller_id_number: *const ::std::os::raw::c_char,
    #[doc = " Original Caller ID Name"]
    pub orig_caller_id_name: *const ::std::os::raw::c_char,
    #[doc = " Original Caller ID Number"]
    pub orig_caller_id_number: *const ::std::os::raw::c_char,
    #[doc = " Callee ID Name"]
    pub callee_id_name: *const ::std::os::raw::c_char,
    #[doc = " Callee ID Number"]
    pub callee_id_number: *const ::std::os::raw::c_char,
    pub caller_ton: u8,
    pub caller_numplan: u8,
    #[doc = " Caller Network Address (when applicable)"]
    pub network_addr: *const ::std::os::raw::c_char,
    #[doc = " ANI (when applicable)"]
    pub ani: *const ::std::os::raw::c_char,
    pub ani_ton: u8,
    pub ani_numplan: u8,
    #[doc = " ANI II (when applicable)"]
    pub aniii: *const ::std::os::raw::c_char,
    #[doc = " RDNIS"]
    pub rdnis: *const ::std::os::raw::c_char,
    pub rdnis_ton: u8,
    pub rdnis_numplan: u8,
    #[doc = " Destination Number"]
    pub destination_number: *mut ::std::os::raw::c_char,
    pub destination_number_ton: u8,
    pub destination_number_numplan: u8,
    #[doc = " channel type"]
    pub source: *const ::std::os::raw::c_char,
    #[doc = " channel name"]
    pub chan_name: *mut ::std::os::raw::c_char,
    #[doc = " unique id"]
    pub uuid: *mut ::std::os::raw::c_char,
    #[doc = " context"]
    pub context: *const ::std::os::raw::c_char,
    #[doc = " profile index"]
    pub profile_index: *const ::std::os::raw::c_char,
    #[doc = " flags"]
    pub flags: switch_caller_profile_flag_t,
    pub originator_caller_profile: *mut switch_caller_profile,
    pub originatee_caller_profile: *mut switch_caller_profile,
    pub origination_caller_profile: *mut switch_caller_profile,
    pub hunt_caller_profile: *mut switch_caller_profile,
    pub times: *mut switch_channel_timetable,
    pub old_times: *mut switch_channel_timetable,
    pub caller_extension: *mut switch_caller_extension,
    pub pool: *mut switch_memory_pool_t,
    pub next: *mut switch_caller_profile,
    pub direction: switch_call_direction_t,
    pub logical_direction: switch_call_direction_t,
    pub soft: *mut profile_node_t,
    pub uuid_str: *mut ::std::os::raw::c_char,
    pub clone_of: *mut ::std::os::raw::c_char,
    pub transfer_source: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_switch_caller_profile() {
    const UNINIT: ::std::mem::MaybeUninit<switch_caller_profile> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_caller_profile>(),
        296usize,
        concat!("Size of: ", stringify!(switch_caller_profile))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_caller_profile>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_caller_profile))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).username) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(username)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dialplan) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(dialplan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).caller_id_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(caller_id_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).caller_id_number) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(caller_id_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).orig_caller_id_name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(orig_caller_id_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).orig_caller_id_number) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(orig_caller_id_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callee_id_name) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(callee_id_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callee_id_number) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(callee_id_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).caller_ton) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(caller_ton)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).caller_numplan) as usize - ptr as usize },
        65usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(caller_numplan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).network_addr) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(network_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ani) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(ani)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ani_ton) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(ani_ton)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ani_numplan) as usize - ptr as usize },
        89usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(ani_numplan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aniii) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(aniii)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rdnis) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(rdnis)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rdnis_ton) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(rdnis_ton)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rdnis_numplan) as usize - ptr as usize },
        113usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(rdnis_numplan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destination_number) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(destination_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destination_number_ton) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(destination_number_ton)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destination_number_numplan) as usize - ptr as usize },
        129usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(destination_number_numplan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chan_name) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(chan_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uuid) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profile_index) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(profile_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).originator_caller_profile) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(originator_caller_profile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).originatee_caller_profile) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(originatee_caller_profile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).origination_caller_profile) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(origination_caller_profile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hunt_caller_profile) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(hunt_caller_profile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).times) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(times)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).old_times) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(old_times)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).caller_extension) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(caller_extension)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).direction) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logical_direction) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(logical_direction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).soft) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(soft)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uuid_str) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(uuid_str)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clone_of) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(clone_of)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transfer_source) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_profile),
            "::",
            stringify!(transfer_source)
        )
    );
}
#[doc = " \\brief An Abstract Representation of a dialplan Application"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_caller_application {
    #[doc = " The name of the registered application to call"]
    pub application_name: *mut ::std::os::raw::c_char,
    #[doc = " An optional argument string to pass to the application"]
    pub application_data: *mut ::std::os::raw::c_char,
    #[doc = " A function pointer to the application"]
    pub application_function: switch_application_function_t,
    pub next: *mut switch_caller_application,
}
#[test]
fn bindgen_test_layout_switch_caller_application() {
    const UNINIT: ::std::mem::MaybeUninit<switch_caller_application> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_caller_application>(),
        32usize,
        concat!("Size of: ", stringify!(switch_caller_application))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_caller_application>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_caller_application))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).application_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_application),
            "::",
            stringify!(application_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).application_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_application),
            "::",
            stringify!(application_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).application_function) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_application),
            "::",
            stringify!(application_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_application),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " \\brief An Abstract Representation of a dialplan extension"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_caller_extension {
    #[doc = " The name of the extension"]
    pub extension_name: *mut ::std::os::raw::c_char,
    #[doc = " The number of the extension"]
    pub extension_number: *mut ::std::os::raw::c_char,
    #[doc = " Pointer to the current application for this extension"]
    pub current_application: *mut switch_caller_application_t,
    #[doc = " Pointer to the last application for this extension"]
    pub last_application: *mut switch_caller_application_t,
    #[doc = " Pointer to the entire stack of applications for this extension"]
    pub applications: *mut switch_caller_application_t,
    pub children: *mut switch_caller_profile,
    pub next: *mut switch_caller_extension,
}
#[test]
fn bindgen_test_layout_switch_caller_extension() {
    const UNINIT: ::std::mem::MaybeUninit<switch_caller_extension> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_caller_extension>(),
        56usize,
        concat!("Size of: ", stringify!(switch_caller_extension))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_caller_extension>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_caller_extension))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extension_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_extension),
            "::",
            stringify!(extension_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extension_number) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_extension),
            "::",
            stringify!(extension_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_application) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_extension),
            "::",
            stringify!(current_application)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_application) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_extension),
            "::",
            stringify!(last_application)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).applications) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_extension),
            "::",
            stringify!(applications)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).children) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_extension),
            "::",
            stringify!(children)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_caller_extension),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    #[doc = "\\brief Create a new extension with desired parameters\n\\param session session associated with the extension (bound by scope)\n\\param extension_name extension name\n\\param extension_number extension number\n\\return a new extension object allocated from the session's memory pool"]
    pub fn switch_caller_extension_new(
        session: *mut switch_core_session_t,
        extension_name: *const ::std::os::raw::c_char,
        extension_number: *const ::std::os::raw::c_char,
    ) -> *mut switch_caller_extension_t;
}
extern "C" {
    pub fn switch_caller_extension_clone(
        new_ext: *mut *mut switch_caller_extension_t,
        orig: *mut switch_caller_extension_t,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Add an application (instruction) to the given extension\n\\param session session associated with the extension (bound by scope)\n\\param caller_extension extension to add the application to\n\\param application_name the name of the application\n\\param extra_data optional argument to the application"]
    pub fn switch_caller_extension_add_application(
        session: *mut switch_core_session_t,
        caller_extension: *mut switch_caller_extension_t,
        application_name: *const ::std::os::raw::c_char,
        extra_data: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "\\brief Add an application (instruction) to the given extension\n\\param session session associated with the extension (bound by scope)\n\\param caller_extension extension to add the application to\n\\param application_name the name of the application\n\\param fmt optional argument to the application (printf format string)"]
    pub fn switch_caller_extension_add_application_printf(
        session: *mut switch_core_session_t,
        caller_extension: *mut switch_caller_extension_t,
        application_name: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = "\\brief Get the value of a field in a caller profile based on it's name\n\\param caller_profile The caller profile\n\\param name the name\n\\note this function is meant for situations where the name paramater is the contents of the variable"]
    pub fn switch_caller_get_field_by_name(
        caller_profile: *mut switch_caller_profile_t,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Create a new caller profile object\n\\param pool memory pool to use\n\\param username tne username of the caller\n\\param dialplan name of the dialplan module in use\n\\param caller_id_name caller ID name\n\\param caller_id_number caller ID number\n\\param network_addr network address\n\\param ani ANI information\n\\param aniii ANI II information\n\\param rdnis RDNIS\n\\param source the source\n\\param context a logical context\n\\param destination_number destination number\n\\return a new profile object allocated from the session's memory pool"]
    pub fn switch_caller_profile_new(
        pool: *mut switch_memory_pool_t,
        username: *const ::std::os::raw::c_char,
        dialplan: *const ::std::os::raw::c_char,
        caller_id_name: *const ::std::os::raw::c_char,
        caller_id_number: *const ::std::os::raw::c_char,
        network_addr: *const ::std::os::raw::c_char,
        ani: *const ::std::os::raw::c_char,
        aniii: *const ::std::os::raw::c_char,
        rdnis: *const ::std::os::raw::c_char,
        source: *const ::std::os::raw::c_char,
        context: *const ::std::os::raw::c_char,
        destination_number: *const ::std::os::raw::c_char,
    ) -> *mut switch_caller_profile_t;
}
extern "C" {
    #[doc = "\\brief Clone an existing caller profile object\n\\param session session associated with the profile (bound by scope)\n\\param tocopy the existing profile"]
    pub fn switch_caller_profile_clone(
        session: *mut switch_core_session_t,
        tocopy: *mut switch_caller_profile_t,
    ) -> *mut switch_caller_profile_t;
}
extern "C" {
    #[doc = "\\brief Duplicate an existing caller profile object\n\\param pool pool to duplicate with\n\\param tocopy the existing profile"]
    pub fn switch_caller_profile_dup(
        pool: *mut switch_memory_pool_t,
        tocopy: *mut switch_caller_profile_t,
    ) -> *mut switch_caller_profile_t;
}
extern "C" {
    #[doc = "\\brief Add headers to an existing event in regards to a specific profile\n\\param caller_profile the desired profile\n\\param prefix a prefix string to all of the field names (for uniqueness)\n\\param event the event to add the information to"]
    pub fn switch_caller_profile_event_set_data(
        caller_profile: *mut switch_caller_profile_t,
        prefix: *const ::std::os::raw::c_char,
        event: *mut switch_event_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_rtcp_report_block_frame {
    pub ssrc: u32,
    pub fraction: u8,
    pub lost: i32,
    pub highest_sequence_number_received: u32,
    pub jitter: u32,
    pub lsr: u32,
    pub dlsr: u32,
    pub loss_avg: u32,
    pub rtt_avg: f64,
}
#[test]
fn bindgen_test_layout_switch_rtcp_report_block_frame() {
    const UNINIT: ::std::mem::MaybeUninit<switch_rtcp_report_block_frame> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_rtcp_report_block_frame>(),
        40usize,
        concat!("Size of: ", stringify!(switch_rtcp_report_block_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_rtcp_report_block_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_rtcp_report_block_frame))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ssrc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_report_block_frame),
            "::",
            stringify!(ssrc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fraction) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_report_block_frame),
            "::",
            stringify!(fraction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lost) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_report_block_frame),
            "::",
            stringify!(lost)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).highest_sequence_number_received) as usize - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_report_block_frame),
            "::",
            stringify!(highest_sequence_number_received)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).jitter) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_report_block_frame),
            "::",
            stringify!(jitter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lsr) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_report_block_frame),
            "::",
            stringify!(lsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dlsr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_report_block_frame),
            "::",
            stringify!(dlsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loss_avg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_report_block_frame),
            "::",
            stringify!(loss_avg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rtt_avg) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_report_block_frame),
            "::",
            stringify!(rtt_avg)
        )
    );
}
#[doc = " \\brief An abstraction of a rtcp frame"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_rtcp_frame {
    pub report_count: u16,
    pub packet_type: u16,
    pub ssrc: u32,
    pub ntp_msw: u32,
    pub ntp_lsw: u32,
    pub timestamp: u32,
    pub packet_count: u32,
    pub octect_count: u32,
    pub nb_reports: u32,
    pub reports: [switch_rtcp_report_block_frame; 5usize],
}
#[test]
fn bindgen_test_layout_switch_rtcp_frame() {
    const UNINIT: ::std::mem::MaybeUninit<switch_rtcp_frame> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_rtcp_frame>(),
        232usize,
        concat!("Size of: ", stringify!(switch_rtcp_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_rtcp_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_rtcp_frame))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).report_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_frame),
            "::",
            stringify!(report_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packet_type) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_frame),
            "::",
            stringify!(packet_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ssrc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_frame),
            "::",
            stringify!(ssrc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ntp_msw) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_frame),
            "::",
            stringify!(ntp_msw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ntp_lsw) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_frame),
            "::",
            stringify!(ntp_lsw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_frame),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packet_count) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_frame),
            "::",
            stringify!(packet_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).octect_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_frame),
            "::",
            stringify!(octect_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_reports) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_frame),
            "::",
            stringify!(nb_reports)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reports) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtcp_frame),
            "::",
            stringify!(reports)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_channel_timetable {
    pub profile_created: switch_time_t,
    pub created: switch_time_t,
    pub answered: switch_time_t,
    pub progress: switch_time_t,
    pub progress_media: switch_time_t,
    pub hungup: switch_time_t,
    pub transferred: switch_time_t,
    pub resurrected: switch_time_t,
    pub bridged: switch_time_t,
    pub last_hold: switch_time_t,
    pub hold_accum: switch_time_t,
    pub next: *mut switch_channel_timetable,
}
#[test]
fn bindgen_test_layout_switch_channel_timetable() {
    const UNINIT: ::std::mem::MaybeUninit<switch_channel_timetable> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_channel_timetable>(),
        96usize,
        concat!("Size of: ", stringify!(switch_channel_timetable))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_channel_timetable>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_channel_timetable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profile_created) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_channel_timetable),
            "::",
            stringify!(profile_created)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).created) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_channel_timetable),
            "::",
            stringify!(created)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).answered) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_channel_timetable),
            "::",
            stringify!(answered)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).progress) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_channel_timetable),
            "::",
            stringify!(progress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).progress_media) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_channel_timetable),
            "::",
            stringify!(progress_media)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hungup) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_channel_timetable),
            "::",
            stringify!(hungup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transferred) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_channel_timetable),
            "::",
            stringify!(transferred)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resurrected) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_channel_timetable),
            "::",
            stringify!(resurrected)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bridged) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_channel_timetable),
            "::",
            stringify!(bridged)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_hold) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_channel_timetable),
            "::",
            stringify!(last_hold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hold_accum) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_channel_timetable),
            "::",
            stringify!(hold_accum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_channel_timetable),
            "::",
            stringify!(next)
        )
    );
}
pub type switch_channel_timetable_t = switch_channel_timetable;
extern "C" {
    #[doc = "\\brief Get the current state of a channel in the state engine\n\\param channel channel to retrieve state from\n\\return current state of channel"]
    pub fn switch_channel_get_state(channel: *mut switch_channel_t) -> switch_channel_state_t;
}
extern "C" {
    pub fn switch_channel_get_running_state(
        channel: *mut switch_channel_t,
    ) -> switch_channel_state_t;
}
extern "C" {
    pub fn switch_channel_check_signal(
        channel: *mut switch_channel_t,
        in_thread_only: switch_bool_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Determine if a channel is ready for io\n\\param channel channel to test\n\\return true if the channel is ready"]
    pub fn switch_channel_test_ready(
        channel: *mut switch_channel_t,
        check_ready: switch_bool_t,
        check_media: switch_bool_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_channel_wait_for_state(
        channel: *mut switch_channel_t,
        other_channel: *mut switch_channel_t,
        want_state: switch_channel_state_t,
    );
}
extern "C" {
    pub fn switch_channel_wait_for_state_timeout(
        other_channel: *mut switch_channel_t,
        want_state: switch_channel_state_t,
        timeout: u32,
    );
}
extern "C" {
    pub fn switch_channel_wait_for_flag(
        channel: *mut switch_channel_t,
        want_flag: switch_channel_flag_t,
        pres: switch_bool_t,
        to: u32,
        super_channel: *mut switch_channel_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_wait_for_app_flag(
        channel: *mut switch_channel_t,
        app_flag: u32,
        key: *const ::std::os::raw::c_char,
        pres: switch_bool_t,
        to: u32,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_perform_set_state(
        channel: *mut switch_channel_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        state: switch_channel_state_t,
    ) -> switch_channel_state_t;
}
extern "C" {
    pub fn switch_channel_perform_set_running_state(
        channel: *mut switch_channel_t,
        state: switch_channel_state_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> switch_channel_state_t;
}
extern "C" {
    #[doc = "\\brief return a cause code for a given string\n\\param str the string to check\n\\return the code"]
    pub fn switch_channel_str2cause(str_: *const ::std::os::raw::c_char) -> switch_call_cause_t;
}
extern "C" {
    #[doc = "\\brief return the cause code for a given channel\n\\param channel the channel\n\\return the code"]
    pub fn switch_channel_get_cause(channel: *mut switch_channel_t) -> switch_call_cause_t;
}
extern "C" {
    pub fn switch_channel_cause_q850(cause: switch_call_cause_t) -> switch_call_cause_t;
}
extern "C" {
    pub fn switch_channel_get_cause_q850(channel: *mut switch_channel_t) -> switch_call_cause_t;
}
extern "C" {
    pub fn switch_channel_get_cause_ptr(channel: *mut switch_channel_t)
        -> *mut switch_call_cause_t;
}
extern "C" {
    #[doc = "\\brief return a cause string for a given cause\n\\param cause the code to check\n\\return the string"]
    pub fn switch_channel_cause2str(cause: switch_call_cause_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief View the timetable of a channel\n\\param channel channel to retrieve timetable from\n\\return a pointer to the channel's timetable (created, answered, etc..)"]
    pub fn switch_channel_get_timetable(
        channel: *mut switch_channel_t,
    ) -> *mut switch_channel_timetable_t;
}
extern "C" {
    #[doc = "\\brief Allocate a new channel\n\\param channel NULL pointer to allocate channel to\n\\param pool memory_pool to use for allocation\n\\return SWITCH_STATUS_SUCCESS if successful"]
    pub fn switch_channel_alloc(
        channel: *mut *mut switch_channel_t,
        direction: switch_call_direction_t,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Connect a newly allocated channel to a session object and setup it's initial state\n\\param channel the channel to initilize\n\\param session the session to connect the channel to\n\\param state the initial state of the channel\n\\param flags the initial channel flags"]
    pub fn switch_channel_init(
        channel: *mut switch_channel_t,
        session: *mut switch_core_session_t,
        state: switch_channel_state_t,
        flag: switch_channel_flag_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Takes presence_data_cols as a parameter or as a channel variable and copies them to channel profile variables\n\\param channel the channel on which to set the channel profile variables\n\\param presence_data_cols is a colon separated list of channel variables to copy to channel profile variables"]
    pub fn switch_channel_set_presence_data_vals(
        channel: *mut switch_channel_t,
        presence_data_cols: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "\\brief Fire A presence event for the channel\n\\param channel the channel to initilize\n\\param rpid the rpid if for the icon to use\n\\param status the status message\n\\param id presence id"]
    pub fn switch_channel_perform_presence(
        channel: *mut switch_channel_t,
        rpid: *const ::std::os::raw::c_char,
        status: *const ::std::os::raw::c_char,
        id: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "\\brief Uninitalize a channel\n\\param channel the channel to uninit"]
    pub fn switch_channel_uninit(channel: *mut switch_channel_t);
}
extern "C" {
    #[doc = "\\brief Set the given channel's caller profile\n\\param channel channel to assign the profile to\n\\param caller_profile the profile to assign"]
    pub fn switch_channel_set_caller_profile(
        channel: *mut switch_channel_t,
        caller_profile: *mut switch_caller_profile_t,
    );
}
extern "C" {
    pub fn switch_channel_step_caller_profile(channel: *mut switch_channel_t);
}
extern "C" {
    #[doc = "\\brief Retrieve the given channel's caller profile\n\\param channel channel to retrieve the profile from\n\\return the requested profile"]
    pub fn switch_channel_get_caller_profile(
        channel: *mut switch_channel_t,
    ) -> *mut switch_caller_profile_t;
}
extern "C" {
    #[doc = "\\brief Set the given channel's originator caller profile\n\\param channel channel to assign the profile to\n\\param caller_profile the profile to assign"]
    pub fn switch_channel_set_originator_caller_profile(
        channel: *mut switch_channel_t,
        caller_profile: *mut switch_caller_profile_t,
    );
}
extern "C" {
    pub fn switch_channel_set_hunt_caller_profile(
        channel: *mut switch_channel_t,
        caller_profile: *mut switch_caller_profile_t,
    );
}
extern "C" {
    #[doc = "\\brief Retrieve the given channel's originator caller profile\n\\param channel channel to retrieve the profile from\n\\return the requested profile"]
    pub fn switch_channel_get_originator_caller_profile(
        channel: *mut switch_channel_t,
    ) -> *mut switch_caller_profile_t;
}
extern "C" {
    #[doc = "\\brief Set the given channel's originatee caller profile\n\\param channel channel to assign the profile to\n\\param caller_profile the profile to assign"]
    pub fn switch_channel_set_originatee_caller_profile(
        channel: *mut switch_channel_t,
        caller_profile: *mut switch_caller_profile_t,
    );
}
extern "C" {
    #[doc = "\\brief Retrieve the given channel's originatee caller profile\n\\param channel channel to retrieve the profile from\n\\return the requested profile"]
    pub fn switch_channel_get_originatee_caller_profile(
        channel: *mut switch_channel_t,
    ) -> *mut switch_caller_profile_t;
}
extern "C" {
    #[doc = "\\brief Set the given channel's origination caller profile\n\\param channel channel to assign the profile to\n\\param caller_profile the profile to assign"]
    pub fn switch_channel_set_origination_caller_profile(
        channel: *mut switch_channel_t,
        caller_profile: *mut switch_caller_profile_t,
    );
}
extern "C" {
    #[doc = "\\brief Retrieve the given channel's origination caller profile\n\\param channel channel to retrieve the profile from\n\\return the requested profile"]
    pub fn switch_channel_get_origination_caller_profile(
        channel: *mut switch_channel_t,
    ) -> *mut switch_caller_profile_t;
}
extern "C" {
    #[doc = "\\brief Retrieve the given channel's unique id\n\\param channel channel to retrieve the unique id from\n\\return the unique id"]
    pub fn switch_channel_get_uuid(channel: *mut switch_channel_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Set a variable on a given channel\n\\param channel channel to set variable on\n\\param varname the name of the variable\n\\param value the value of the variable\n\\returns SWITCH_STATUS_SUCCESS if successful"]
    pub fn switch_channel_set_profile_var(
        channel: *mut switch_channel_t,
        name: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_set_log_tag(
        channel: *mut switch_channel_t,
        tagname: *const ::std::os::raw::c_char,
        tagvalue: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_get_log_tags(
        channel: *mut switch_channel_t,
        log_tags: *mut *mut switch_event_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_set_variable_var_check(
        channel: *mut switch_channel_t,
        varname: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        var_check: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_set_variable_strip_quotes_var_check(
        channel: *mut switch_channel_t,
        varname: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        var_check: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_add_variable_var_check(
        channel: *mut switch_channel_t,
        varname: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        var_check: switch_bool_t,
        stack: switch_stack_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_set_variable_printf(
        channel: *mut switch_channel_t,
        varname: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_set_variable_name_printf(
        channel: *mut switch_channel_t,
        val: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_set_variable_partner_var_check(
        channel: *mut switch_channel_t,
        varname: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        var_check: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_get_variable_partner(
        channel: *mut switch_channel_t,
        varname: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_channel_get_hold_music(
        channel: *mut switch_channel_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_channel_get_hold_music_partner(
        channel: *mut switch_channel_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_channel_del_variable_prefix(
        channel: *mut switch_channel_t,
        prefix: *const ::std::os::raw::c_char,
    ) -> u32;
}
extern "C" {
    pub fn switch_channel_transfer_variable_prefix(
        orig_channel: *mut switch_channel_t,
        new_channel: *mut switch_channel_t,
        prefix: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_export_variable_var_check(
        channel: *mut switch_channel_t,
        varname: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
        export_varname: *const ::std::os::raw::c_char,
        var_check: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_process_export(
        channel: *mut switch_channel_t,
        peer_channel: *mut switch_channel_t,
        var_event: *mut switch_event_t,
        export_varname: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn switch_channel_export_variable_printf(
        channel: *mut switch_channel_t,
        varname: *const ::std::os::raw::c_char,
        export_varname: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_set_scope_variables(
        channel: *mut switch_channel_t,
        event: *mut *mut switch_event_t,
    );
}
extern "C" {
    pub fn switch_channel_get_scope_variables(
        channel: *mut switch_channel_t,
        event: *mut *mut switch_event_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Retrieve a variable from a given channel\n\\param channel channel to retrieve variable from\n\\param varname the name of the variable\n\\return the value of the requested variable"]
    pub fn switch_channel_get_variable_dup(
        channel: *mut switch_channel_t,
        varname: *const ::std::os::raw::c_char,
        dup: switch_bool_t,
        idx: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Retrieve a copy of a variable from a given channel. switch_safe_free() call will be required.\n\\param channel channel to retrieve variable from\n\\param varname the name of the variable\n\\return a strdup copy the value of the requested variable without using a memory pool."]
    pub fn switch_channel_get_variable_strdup(
        channel: *mut switch_channel_t,
        varname: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Retrieve a variable from a given channel to a pre-allocated buffer without using a memory pool.\n\\param channel channel to retrieve variable from\n\\param varname the name of the variable\n\\param buf a pre allocated buffer to put the value to\n\\param buflen size of the buffer\n\\return SWITCH_STATUS_SUCCESS if the value was copied to the buffer and it is not NULL, SWITCH_STATUS_FALSE otherwise."]
    pub fn switch_channel_get_variable_buf(
        channel: *mut switch_channel_t,
        varname: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_char,
        buflen: switch_size_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_get_variables(
        channel: *mut switch_channel_t,
        event: *mut *mut switch_event_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_get_variables_prefix(
        channel: *mut switch_channel_t,
        prefix: *const ::std::os::raw::c_char,
        event: *mut *mut switch_event_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_pass_callee_id(
        channel: *mut switch_channel_t,
        other_channel: *mut switch_channel_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " \\brief Start iterating over the entries in the channel variable list.\n \\param channel the channel to iterate the variables for\n \\remark This function locks the profile mutex, use switch_channel_variable_last to unlock"]
    pub fn switch_channel_variable_first(
        channel: *mut switch_channel_t,
    ) -> *mut switch_event_header_t;
}
extern "C" {
    #[doc = " \\brief Stop iterating over channel variables.\n \\remark Unlocks the profile mutex initially locked in switch_channel_variable_first"]
    pub fn switch_channel_variable_last(channel: *mut switch_channel_t);
}
extern "C" {
    pub fn switch_channel_restart(channel: *mut switch_channel_t);
}
extern "C" {
    pub fn switch_channel_caller_extension_masquerade(
        orig_channel: *mut switch_channel_t,
        new_channel: *mut switch_channel_t,
        offset: u32,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Assign a caller extension to a given channel\n\\param channel channel to assign extension to\n\\param caller_extension extension to assign"]
    pub fn switch_channel_set_caller_extension(
        channel: *mut switch_channel_t,
        caller_extension: *mut switch_caller_extension_t,
    );
}
extern "C" {
    pub fn switch_channel_invert_cid(channel: *mut switch_channel_t);
}
extern "C" {
    pub fn switch_channel_flip_cid(channel: *mut switch_channel_t);
}
extern "C" {
    pub fn switch_channel_sort_cid(channel: *mut switch_channel_t);
}
extern "C" {
    #[doc = "\\brief Retrieve caller extension from a given channel\n\\param channel channel to retrieve extension from\n\\return the requested extension"]
    pub fn switch_channel_get_caller_extension(
        channel: *mut switch_channel_t,
    ) -> *mut switch_caller_extension_t;
}
extern "C" {
    #[doc = "\\brief Test for presence of given flag on a given channel\n\\param channel channel to test\n\\param flag to test\n\\return TRUE if flags were present"]
    pub fn switch_channel_test_flag(
        channel: *mut switch_channel_t,
        flag: switch_channel_flag_t,
    ) -> u32;
}
extern "C" {
    #[doc = "\\brief Set given flag(s) on a given channel\n\\param channel channel on which to set flag\n\\param flag or'd list of flags to set"]
    pub fn switch_channel_set_flag_value(
        channel: *mut switch_channel_t,
        flag: switch_channel_flag_t,
        value: u32,
    );
}
extern "C" {
    pub fn switch_channel_set_flag_recursive(
        channel: *mut switch_channel_t,
        flag: switch_channel_flag_t,
    );
}
extern "C" {
    pub fn switch_channel_set_cap_value(
        channel: *mut switch_channel_t,
        cap: switch_channel_cap_t,
        value: u32,
    );
}
extern "C" {
    pub fn switch_channel_clear_cap(channel: *mut switch_channel_t, cap: switch_channel_cap_t);
}
extern "C" {
    pub fn switch_channel_test_cap(
        channel: *mut switch_channel_t,
        cap: switch_channel_cap_t,
    ) -> u32;
}
extern "C" {
    pub fn switch_channel_test_cap_partner(
        channel: *mut switch_channel_t,
        cap: switch_channel_cap_t,
    ) -> u32;
}
extern "C" {
    #[doc = "\\brief Set given flag(s) on a given channel's bridge partner\n\\param channel channel to derive the partner channel to set flag on\n\\param flag to set\n\\return true if the flag was set"]
    pub fn switch_channel_set_flag_partner(
        channel: *mut switch_channel_t,
        flag: switch_channel_flag_t,
    ) -> switch_bool_t;
}
extern "C" {
    #[doc = "\\brief Clears given flag(s) on a given channel's bridge partner\n\\param channel channel to derive the partner channel to clear flag(s) from\n\\param flag the flag to clear\n\\return true if the flag was cleared"]
    pub fn switch_channel_clear_flag_partner(
        channel: *mut switch_channel_t,
        flag: switch_channel_flag_t,
    ) -> switch_bool_t;
}
extern "C" {
    pub fn switch_channel_test_flag_partner(
        channel: *mut switch_channel_t,
        flag: switch_channel_flag_t,
    ) -> u32;
}
extern "C" {
    #[doc = "\\brief Set given flag(s) on a given channel to be applied on the next state change\n\\param channel channel on which to set flag(s)\n\\param flag flag to set"]
    pub fn switch_channel_set_state_flag(
        channel: *mut switch_channel_t,
        flag: switch_channel_flag_t,
    );
}
extern "C" {
    pub fn switch_channel_clear_state_flag(
        channel: *mut switch_channel_t,
        flag: switch_channel_flag_t,
    );
}
extern "C" {
    #[doc = "\\brief Clear given flag(s) from a channel\n\\param channel channel to clear flags from\n\\param flag flag to clear"]
    pub fn switch_channel_clear_flag(channel: *mut switch_channel_t, flag: switch_channel_flag_t);
}
extern "C" {
    pub fn switch_channel_clear_flag_recursive(
        channel: *mut switch_channel_t,
        flag: switch_channel_flag_t,
    );
}
extern "C" {
    pub fn switch_channel_perform_answer(
        channel: *mut switch_channel_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_perform_mark_answered(
        channel: *mut switch_channel_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_perform_acknowledge_call(
        channel: *mut switch_channel_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_perform_ring_ready_value(
        channel: *mut switch_channel_t,
        rv: switch_ring_ready_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_perform_pre_answer(
        channel: *mut switch_channel_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_perform_mark_pre_answered(
        channel: *mut switch_channel_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_perform_mark_ring_ready_value(
        channel: *mut switch_channel_t,
        rv: switch_ring_ready_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief add a state handler table to a given channel\n\\param channel channel on which to add the state handler table\n\\param state_handler table of state handler functions\n\\return the index number/priority of the table negative value indicates failure"]
    pub fn switch_channel_add_state_handler(
        channel: *mut switch_channel_t,
        state_handler: *const switch_state_handler_table_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief clear a state handler table from a given channel\n\\param channel channel from which to clear the state handler table\n\\param state_handler table of state handler functions"]
    pub fn switch_channel_clear_state_handler(
        channel: *mut switch_channel_t,
        state_handler: *const switch_state_handler_table_t,
    );
}
extern "C" {
    #[doc = "\\brief Retrieve an state handler tablefrom a given channel at given index level\n\\param channel channel from which to retrieve the state handler table\n\\param index the index of the state handler table (start from 0)\n\\return given channel's state handler table at given index or NULL if requested index does not exist."]
    pub fn switch_channel_get_state_handler(
        channel: *mut switch_channel_t,
        index: ::std::os::raw::c_int,
    ) -> *const switch_state_handler_table_t;
}
extern "C" {
    #[doc = "\\brief Set private data on channel\n\\param channel channel on which to set data\n\\param key unique keyname to associate your private data to\n\\param private_info void pointer to private data\n\\return SWITCH_STATUS_SUCCESS if data was set\n\\remarks set NULL to delete your private data"]
    pub fn switch_channel_set_private(
        channel: *mut switch_channel_t,
        key: *const ::std::os::raw::c_char,
        private_info: *const ::std::os::raw::c_void,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Retrieve private from a given channel\n\\param channel channel to retrieve data from\n\\param key unique keyname to retrieve your private data\n\\return void pointer to channel's private data"]
    pub fn switch_channel_get_private(
        channel: *mut switch_channel_t,
        key: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn switch_channel_get_private_partner(
        channel: *mut switch_channel_t,
        key: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "\\brief Assign a name to a given channel\n\\param channel channel to assign name to\n\\param name name to assign\n\\return SWITCH_STATUS_SUCCESS if name was assigned"]
    pub fn switch_channel_set_name(
        channel: *mut switch_channel_t,
        name: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Retrieve the name of a given channel\n\\param channel channel to get name of\n\\return the channel's name"]
    pub fn switch_channel_get_name(channel: *mut switch_channel_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_channel_perform_hangup(
        channel: *mut switch_channel_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        hangup_cause: switch_call_cause_t,
    ) -> switch_channel_state_t;
}
extern "C" {
    #[doc = "\\brief Test for presence of DTMF on a given channel\n\\param channel channel to test\n\\return number of digits in the queue"]
    pub fn switch_channel_has_dtmf(channel: *mut switch_channel_t) -> switch_size_t;
}
extern "C" {
    pub fn switch_channel_dtmf_lock(channel: *mut switch_channel_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_try_dtmf_lock(channel: *mut switch_channel_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_dtmf_unlock(channel: *mut switch_channel_t) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Queue DTMF on a given channel\n\\param channel channel to queue DTMF to\n\\param dtmf digit\n\\return SWITCH_STATUS_SUCCESS if successful"]
    pub fn switch_channel_queue_dtmf(
        channel: *mut switch_channel_t,
        dtmf: *const switch_dtmf_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_queue_dtmf_string(
        channel: *mut switch_channel_t,
        dtmf_string: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Retrieve DTMF digits from a given channel\n\\param channel channel to retrieve digits from\n\\param dtmf digit\n\\return number of bytes read into the buffer"]
    pub fn switch_channel_dequeue_dtmf(
        channel: *mut switch_channel_t,
        dtmf: *mut switch_dtmf_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_flush_dtmf(channel: *mut switch_channel_t);
}
extern "C" {
    pub fn switch_channel_dequeue_dtmf_string(
        channel: *mut switch_channel_t,
        dtmf_str: *mut ::std::os::raw::c_char,
        len: switch_size_t,
    ) -> switch_size_t;
}
extern "C" {
    #[doc = "\\brief Render the name of the provided state enum\n\\param state state to get name of\n\\return the string representation of the state"]
    pub fn switch_channel_state_name(
        state: switch_channel_state_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Render the enum of the provided state name\n\\param name the name of the state\n\\return the enum value (numeric)"]
    pub fn switch_channel_name_state(name: *const ::std::os::raw::c_char)
        -> switch_channel_state_t;
}
extern "C" {
    #[doc = "\\brief Add information about a given channel to an event object\n\\param channel channel to add information about\n\\param event event to add information to"]
    pub fn switch_channel_event_set_data(
        channel: *mut switch_channel_t,
        event: *mut switch_event_t,
    );
}
extern "C" {
    pub fn switch_channel_event_set_basic_data(
        channel: *mut switch_channel_t,
        event: *mut switch_event_t,
    );
}
extern "C" {
    pub fn switch_channel_event_set_extended_data(
        channel: *mut switch_channel_t,
        event: *mut switch_event_t,
    );
}
extern "C" {
    #[doc = "\\brief Expand varaibles in a string based on the variables in a paticular channel\n\\param channel channel to expand the variables from\n\\param in the original string\n\\return the original string if no expansion takes place otherwise a new string that must be freed\n\\note it's necessary to test if the return val is the same as the input and free the string if it is not."]
    pub fn switch_channel_expand_variables_check(
        channel: *mut switch_channel_t,
        in_: *const ::std::os::raw::c_char,
        var_list: *mut switch_event_t,
        api_list: *mut switch_event_t,
        recur: u32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_channel_build_param_string(
        channel: *mut switch_channel_t,
        caller_profile: *mut switch_caller_profile_t,
        prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_channel_set_timestamps(channel: *mut switch_channel_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_perform_audio_sync(
        channel: *mut switch_channel_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn switch_channel_perform_video_sync(
        channel: *mut switch_channel_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn switch_channel_set_private_flag(channel: *mut switch_channel_t, flags: u32);
}
extern "C" {
    pub fn switch_channel_clear_private_flag(channel: *mut switch_channel_t, flags: u32);
}
extern "C" {
    pub fn switch_channel_test_private_flag(
        channel: *mut switch_channel_t,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_channel_set_app_flag_key(
        app: *const ::std::os::raw::c_char,
        channel: *mut switch_channel_t,
        flags: u32,
    );
}
extern "C" {
    pub fn switch_channel_clear_app_flag_key(
        app: *const ::std::os::raw::c_char,
        channel: *mut switch_channel_t,
        flags: u32,
    );
}
extern "C" {
    pub fn switch_channel_test_app_flag_key(
        app: *const ::std::os::raw::c_char,
        channel: *mut switch_channel_t,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_channel_set_bridge_time(channel: *mut switch_channel_t);
}
extern "C" {
    pub fn switch_channel_set_hangup_time(channel: *mut switch_channel_t);
}
extern "C" {
    pub fn switch_channel_direction(channel: *mut switch_channel_t) -> switch_call_direction_t;
}
extern "C" {
    pub fn switch_channel_logical_direction(
        channel: *mut switch_channel_t,
    ) -> switch_call_direction_t;
}
extern "C" {
    pub fn switch_channel_set_direction(
        channel: *mut switch_channel_t,
        direction: switch_call_direction_t,
    );
}
extern "C" {
    pub fn switch_channel_get_session(channel: *mut switch_channel_t)
        -> *mut switch_core_session_t;
}
extern "C" {
    pub fn switch_channel_get_flag_string(
        channel: *mut switch_channel_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_channel_get_cap_string(
        channel: *mut switch_channel_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_channel_state_change_pending(
        channel: *mut switch_channel_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_channel_perform_set_callstate(
        channel: *mut switch_channel_t,
        callstate: switch_channel_callstate_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn switch_channel_get_callstate(
        channel: *mut switch_channel_t,
    ) -> switch_channel_callstate_t;
}
extern "C" {
    pub fn switch_channel_callstate2str(
        callstate: switch_channel_callstate_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_channel_str2callstate(
        str_: *const ::std::os::raw::c_char,
    ) -> switch_channel_callstate_t;
}
extern "C" {
    pub fn switch_channel_mark_hold(channel: *mut switch_channel_t, on: switch_bool_t);
}
extern "C" {
    #[doc = " @}"]
    pub fn switch_channel_execute_on(
        channel: *mut switch_channel_t,
        variable_prefix: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_execute_on_value(
        channel: *mut switch_channel_t,
        variable_value: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_api_on(
        channel: *mut switch_channel_t,
        variable_prefix: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_process_device_hangup(channel: *mut switch_channel_t);
}
extern "C" {
    pub fn switch_channel_get_queued_extension(
        channel: *mut switch_channel_t,
    ) -> *mut switch_caller_extension_t;
}
extern "C" {
    pub fn switch_channel_transfer_to_extension(
        channel: *mut switch_channel_t,
        caller_extension: *mut switch_caller_extension_t,
    );
}
extern "C" {
    pub fn switch_channel_get_partner_uuid(
        channel: *mut switch_channel_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_channel_get_partner_uuid_copy(
        channel: *mut switch_channel_t,
        buf: *mut ::std::os::raw::c_char,
        blen: switch_size_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_channel_get_hold_record(
        channel: *mut switch_channel_t,
    ) -> *mut switch_hold_record_t;
}
extern "C" {
    pub fn switch_channel_state_thread_lock(channel: *mut switch_channel_t);
}
extern "C" {
    pub fn switch_channel_state_thread_unlock(channel: *mut switch_channel_t);
}
extern "C" {
    pub fn switch_channel_state_thread_trylock(channel: *mut switch_channel_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_handle_cause(channel: *mut switch_channel_t, cause: switch_call_cause_t);
}
extern "C" {
    pub fn switch_channel_global_init(pool: *mut switch_memory_pool_t);
}
extern "C" {
    pub fn switch_channel_global_uninit();
}
extern "C" {
    pub fn switch_channel_set_device_id(
        channel: *mut switch_channel_t,
        device_id: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_channel_clear_device_record(channel: *mut switch_channel_t);
}
extern "C" {
    pub fn switch_channel_get_device_record(
        channel: *mut switch_channel_t,
    ) -> *mut switch_device_record_t;
}
extern "C" {
    pub fn switch_channel_release_device_record(dcdrp: *mut *mut switch_device_record_t);
}
extern "C" {
    pub fn switch_channel_bind_device_state_handler(
        function: switch_device_state_function_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_unbind_device_state_handler(
        function: switch_device_state_function_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_channel_device_state2str(
        device_state: switch_device_state_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_channel_pass_sdp(
        from_channel: *mut switch_channel_t,
        to_channel: *mut switch_channel_t,
        sdp: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_buffer_create_partition(
        pool: *mut switch_memory_pool_t,
        buffer: *mut *mut switch_buffer_t,
        data: *mut ::std::os::raw::c_void,
        datalen: switch_size_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_buffer_set_partition_data(
        buffer: *mut switch_buffer_t,
        data: *mut ::std::os::raw::c_void,
        datalen: switch_size_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_buffer_reset_partition_data(buffer: *mut switch_buffer_t) -> switch_status_t;
}
extern "C" {
    #[doc = " \\brief Allocate a new switch_buffer\n \\param pool Pool to allocate the buffer from\n \\param buffer returned pointer to the new buffer\n \\param max_len length required by the buffer\n \\return status"]
    pub fn switch_buffer_create(
        pool: *mut switch_memory_pool_t,
        buffer: *mut *mut switch_buffer_t,
        max_len: switch_size_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " \\brief Allocate a new dynamic switch_buffer\n \\param buffer returned pointer to the new buffer\n \\param blocksize length to realloc by as data is added\n \\param start_len ammount of memory to reserve initially\n \\param max_len length the buffer is allowed to grow to\n \\return status"]
    pub fn switch_buffer_create_dynamic(
        buffer: *mut *mut switch_buffer_t,
        blocksize: switch_size_t,
        start_len: switch_size_t,
        max_len: switch_size_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_buffer_add_mutex(buffer: *mut switch_buffer_t, mutex: *mut switch_mutex_t);
}
extern "C" {
    pub fn switch_buffer_lock(buffer: *mut switch_buffer_t);
}
extern "C" {
    pub fn switch_buffer_trylock(buffer: *mut switch_buffer_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_buffer_unlock(buffer: *mut switch_buffer_t);
}
extern "C" {
    #[doc = " \\brief Get the length of a switch_buffer_t\n \\param buffer any buffer of type switch_buffer_t\n \\return int size of the buffer."]
    pub fn switch_buffer_len(buffer: *mut switch_buffer_t) -> switch_size_t;
}
extern "C" {
    #[doc = " \\brief Get the freespace of a switch_buffer_t\n \\param buffer any buffer of type switch_buffer_t\n \\return int freespace in the buffer."]
    pub fn switch_buffer_freespace(buffer: *mut switch_buffer_t) -> switch_size_t;
}
extern "C" {
    #[doc = " \\brief Get the in use amount of a switch_buffer_t\n \\param buffer any buffer of type switch_buffer_t\n \\return int ammount of buffer curently in use"]
    pub fn switch_buffer_inuse(buffer: *mut switch_buffer_t) -> switch_size_t;
}
extern "C" {
    #[doc = " \\brief Read data from a switch_buffer_t up to the ammount of datalen if it is available.  Remove read data from buffer.\n \\param buffer any buffer of type switch_buffer_t\n \\param data pointer to the read data to be returned\n \\param datalen amount of data to be returned\n \\return int ammount of data actually read"]
    pub fn switch_buffer_read(
        buffer: *mut switch_buffer_t,
        data: *mut ::std::os::raw::c_void,
        datalen: switch_size_t,
    ) -> switch_size_t;
}
extern "C" {
    #[doc = " \\brief Read data from a switch_buffer_t up to the ammount of datalen if it is available, without removing read data from buffer.\n \\param buffer any buffer of type switch_buffer_t\n \\param data pointer to the read data to be returned\n \\param datalen amount of data to be returned\n \\return int ammount of data actually read"]
    pub fn switch_buffer_peek(
        buffer: *mut switch_buffer_t,
        data: *mut ::std::os::raw::c_void,
        datalen: switch_size_t,
    ) -> switch_size_t;
}
extern "C" {
    pub fn switch_buffer_peek_zerocopy(
        buffer: *mut switch_buffer_t,
        ptr: *mut *const ::std::os::raw::c_void,
    ) -> switch_size_t;
}
extern "C" {
    #[doc = " \\brief Read data endlessly from a switch_buffer_t\n \\param buffer any buffer of type switch_buffer_t\n \\param data pointer to the read data to be returned\n \\param datalen amount of data to be returned\n \\return int ammount of data actually read\n \\note Once you have read all the data from the buffer it will loop around."]
    pub fn switch_buffer_read_loop(
        buffer: *mut switch_buffer_t,
        data: *mut ::std::os::raw::c_void,
        datalen: switch_size_t,
    ) -> switch_size_t;
}
extern "C" {
    #[doc = " \\brief Assign a number of loops to read\n \\param buffer any buffer of type switch_buffer_t\n \\param loops the number of loops (-1 for infinite)"]
    pub fn switch_buffer_set_loops(buffer: *mut switch_buffer_t, loops: i32);
}
extern "C" {
    #[doc = " \\brief Write data into a switch_buffer_t up to the length of datalen\n \\param buffer any buffer of type switch_buffer_t\n \\param data pointer to the data to be written or 0 to fill in with datalen zeros\n \\param datalen amount of data to be written\n \\return int amount of buffer used after the write, or 0 if no space available"]
    pub fn switch_buffer_write(
        buffer: *mut switch_buffer_t,
        data: *const ::std::os::raw::c_void,
        datalen: switch_size_t,
    ) -> switch_size_t;
}
extern "C" {
    #[doc = " \\brief Remove data from the buffer\n \\param buffer any buffer of type switch_buffer_t\n \\param datalen amount of data to be removed\n \\return int size of buffer, or 0 if unable to toss that much data"]
    pub fn switch_buffer_toss(
        buffer: *mut switch_buffer_t,
        datalen: switch_size_t,
    ) -> switch_size_t;
}
extern "C" {
    #[doc = " \\brief Remove all data from the buffer\n \\param buffer any buffer of type switch_buffer_t"]
    pub fn switch_buffer_zero(buffer: *mut switch_buffer_t);
}
extern "C" {
    pub fn switch_buffer_slide_write(
        buffer: *mut switch_buffer_t,
        data: *const ::std::os::raw::c_void,
        datalen: switch_size_t,
    ) -> switch_size_t;
}
extern "C" {
    #[doc = " \\brief Destroy the buffer\n \\param buffer buffer to destroy\n \\note only neccessary on dynamic buffers (noop on pooled ones)"]
    pub fn switch_buffer_destroy(buffer: *mut *mut switch_buffer_t);
}
extern "C" {
    pub fn switch_buffer_zwrite(
        buffer: *mut switch_buffer_t,
        data: *const ::std::os::raw::c_void,
        datalen: switch_size_t,
    ) -> switch_size_t;
}
extern "C" {
    pub fn switch_buffer_get_head_pointer(
        buffer: *mut switch_buffer_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " \\brief An event Header"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_event_header {
    #[doc = " the header name"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = " the header value"]
    pub value: *mut ::std::os::raw::c_char,
    #[doc = " array space"]
    pub array: *mut *mut ::std::os::raw::c_char,
    #[doc = " array index"]
    pub idx: ::std::os::raw::c_int,
    #[doc = " hash of the header name"]
    pub hash: ::std::os::raw::c_ulong,
    pub next: *mut switch_event_header,
}
#[test]
fn bindgen_test_layout_switch_event_header() {
    const UNINIT: ::std::mem::MaybeUninit<switch_event_header> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_event_header>(),
        48usize,
        concat!("Size of: ", stringify!(switch_event_header))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_event_header>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_event_header))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_event_header),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_event_header),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_event_header),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).idx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_event_header),
            "::",
            stringify!(idx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_event_header),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_event_header),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " \\brief Representation of an event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_event {
    #[doc = " the event id (descriptor)"]
    pub event_id: switch_event_types_t,
    #[doc = " the priority of the event"]
    pub priority: switch_priority_t,
    #[doc = " the owner of the event"]
    pub owner: *mut ::std::os::raw::c_char,
    #[doc = " the subclass of the event"]
    pub subclass_name: *mut ::std::os::raw::c_char,
    #[doc = " the event headers"]
    pub headers: *mut switch_event_header_t,
    #[doc = " the event headers tail pointer"]
    pub last_header: *mut switch_event_header_t,
    #[doc = " the body of the event"]
    pub body: *mut ::std::os::raw::c_char,
    #[doc = " user data from the subclass provider"]
    pub bind_user_data: *mut ::std::os::raw::c_void,
    #[doc = " user data from the event sender"]
    pub event_user_data: *mut ::std::os::raw::c_void,
    #[doc = " unique key"]
    pub key: ::std::os::raw::c_ulong,
    pub next: *mut switch_event,
    pub flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_switch_event() {
    const UNINIT: ::std::mem::MaybeUninit<switch_event> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_event>(),
        88usize,
        concat!("Size of: ", stringify!(switch_event))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_event>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_event))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_event),
            "::",
            stringify!(event_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_event),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_event),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subclass_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_event),
            "::",
            stringify!(subclass_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).headers) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_event),
            "::",
            stringify!(headers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_header) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_event),
            "::",
            stringify!(last_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_event),
            "::",
            stringify!(body)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bind_user_data) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_event),
            "::",
            stringify!(bind_user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_user_data) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_event),
            "::",
            stringify!(event_user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_event),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_event),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_event),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_serial_event_s {
    pub event_id: ::std::os::raw::c_int,
    pub priority: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
    pub owner: *mut ::std::os::raw::c_char,
    pub subclass_name: *mut ::std::os::raw::c_char,
    pub body: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_switch_serial_event_s() {
    const UNINIT: ::std::mem::MaybeUninit<switch_serial_event_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_serial_event_s>(),
        40usize,
        concat!("Size of: ", stringify!(switch_serial_event_s))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_serial_event_s>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_serial_event_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_serial_event_s),
            "::",
            stringify!(event_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_serial_event_s),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_serial_event_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).owner) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_serial_event_s),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subclass_name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_serial_event_s),
            "::",
            stringify!(subclass_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_serial_event_s),
            "::",
            stringify!(body)
        )
    );
}
pub type switch_serial_event_t = switch_serial_event_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_serial_event_header_s {
    pub name: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_switch_serial_event_header_s() {
    const UNINIT: ::std::mem::MaybeUninit<switch_serial_event_header_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_serial_event_header_s>(),
        16usize,
        concat!("Size of: ", stringify!(switch_serial_event_header_s))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_serial_event_header_s>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_serial_event_header_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_serial_event_header_s),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_serial_event_header_s),
            "::",
            stringify!(value)
        )
    );
}
pub type switch_serial_event_header_t = switch_serial_event_header_s;
pub const switch_event_flag_t_EF_UNIQ_HEADERS: switch_event_flag_t = 1;
pub const switch_event_flag_t_EF_NO_CHAT_EXEC: switch_event_flag_t = 2;
pub const switch_event_flag_t_EF_DEFAULT_ALLOW: switch_event_flag_t = 4;
pub type switch_event_flag_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = "\\brief Start the eventing system\n\\param pool the memory pool to use for the event system (creates a new one if NULL)\n\\return SWITCH_STATUS_SUCCESS when complete"]
    pub fn switch_event_init(pool: *mut switch_memory_pool_t) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Stop the eventing system\n\\return SWITCH_STATUS_SUCCESS when complete"]
    pub fn switch_event_shutdown() -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Create an event\n\\param event a NULL pointer on which to create the event\n\\param event_id the event id enumeration of the desired event\n\\param subclass_name the subclass name for custom event (only valid when event_id is SWITCH_EVENT_CUSTOM)\n\\return SWITCH_STATUS_SUCCESS on success"]
    pub fn switch_event_create_subclass_detailed(
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        event: *mut *mut switch_event_t,
        event_id: switch_event_types_t,
        subclass_name: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Set the priority of an event\n\\param event the event to set the priority on\n\\param priority the event priority\n\\return SWITCH_STATUS_SUCCESS"]
    pub fn switch_event_set_priority(
        event: *mut switch_event_t,
        priority: switch_priority_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Retrieve a header value from an event\n\\param event the event to read the header from\n\\param header_name the name of the header to read\n\\return the value of the requested header"]
    pub fn switch_event_get_header_ptr(
        event: *mut switch_event_t,
        header_name: *const ::std::os::raw::c_char,
    ) -> *mut switch_event_header_t;
}
extern "C" {
    pub fn switch_event_get_header_idx(
        event: *mut switch_event_t,
        header_name: *const ::std::os::raw::c_char,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_event_rename_header(
        event: *mut switch_event_t,
        header_name: *const ::std::os::raw::c_char,
        new_header_name: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Retrieve the body value from an event\n\\param event the event to read the body from\n\\return the value of the body or NULL"]
    pub fn switch_event_get_body(event: *mut switch_event_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Add a header to an event\n\\param event the event to add the header to\n\\param stack the stack sense (stack it on the top or on the bottom)\n\\param header_name the name of the header to add\n\\param fmt the value of the header (varargs see standard sprintf family)\n\\return SWITCH_STATUS_SUCCESS if the header was added"]
    pub fn switch_event_add_header(
        event: *mut switch_event_t,
        stack: switch_stack_t,
        header_name: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_event_set_subclass_name(
        event: *mut switch_event_t,
        subclass_name: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Add a string header to an event\n\\param event the event to add the header to\n\\param stack the stack sense (stack it on the top or on the bottom)\n\\param header_name the name of the header to add\n\\param data the value of the header\n\\return SWITCH_STATUS_SUCCESS if the header was added"]
    pub fn switch_event_add_header_string(
        event: *mut switch_event_t,
        stack: switch_stack_t,
        header_name: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_event_add_header_string_nodup(
        event: *mut switch_event_t,
        stack: switch_stack_t,
        header_name: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_event_del_header_val(
        event: *mut switch_event_t,
        header_name: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_event_add_array(
        event: *mut switch_event_t,
        var: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Destroy an event\n\\param event pointer to the pointer to event to destroy"]
    pub fn switch_event_destroy(event: *mut *mut switch_event_t);
}
extern "C" {
    #[doc = "\\brief Duplicate an event\n\\param event a NULL pointer on which to duplicate the event\n\\param todup an event to duplicate\n\\return SWITCH_STATUS_SUCCESS if the event was duplicated"]
    pub fn switch_event_dup(
        event: *mut *mut switch_event_t,
        todup: *mut switch_event_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_event_merge(event: *mut switch_event_t, tomerge: *mut switch_event_t);
}
extern "C" {
    pub fn switch_event_dup_reply(
        event: *mut *mut switch_event_t,
        todup: *mut switch_event_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Fire an event with full arguement list\n\\param file the calling file\n\\param func the calling function\n\\param line the calling line number\n\\param event the event to send (will be nulled on success)\n\\param user_data optional private data to pass to the event handlers\n\\return"]
    pub fn switch_event_fire_detailed(
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        event: *mut *mut switch_event_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_event_prep_for_delivery_detailed(
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        event: *mut switch_event_t,
    );
}
extern "C" {
    #[doc = "\\brief Bind an event callback to a specific event\n\\param id an identifier token of the binder\n\\param event the event enumeration to bind to\n\\param subclass_name the event subclass to bind to in the case if SWITCH_EVENT_CUSTOM\n\\param callback the callback functon to bind\n\\param user_data optional user specific data to pass whenever the callback is invoked\n\\return SWITCH_STATUS_SUCCESS if the event was binded"]
    pub fn switch_event_bind(
        id: *const ::std::os::raw::c_char,
        event: switch_event_types_t,
        subclass_name: *const ::std::os::raw::c_char,
        callback: switch_event_callback_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_event_get_custom_events(
        matches: *mut *mut switch_console_callback_match_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Bind an event callback to a specific event\n\\param id an identifier token of the binder\n\\param event the event enumeration to bind to\n\\param subclass_name the event subclass to bind to in the case if SWITCH_EVENT_CUSTOM\n\\param callback the callback functon to bind\n\\param user_data optional user specific data to pass whenever the callback is invoked\n\\param node bind handle to later remove the binding.\n\\return SWITCH_STATUS_SUCCESS if the event was binded"]
    pub fn switch_event_bind_removable(
        id: *const ::std::os::raw::c_char,
        event: switch_event_types_t,
        subclass_name: *const ::std::os::raw::c_char,
        callback: switch_event_callback_t,
        user_data: *mut ::std::os::raw::c_void,
        node: *mut *mut switch_event_node_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Unbind a bound event consumer\n\\param node node to unbind\n\\return SWITCH_STATUS_SUCCESS if the consumer was unbinded"]
    pub fn switch_event_unbind(node: *mut *mut switch_event_node_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_event_unbind_callback(callback: switch_event_callback_t) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Render the name of an event id enumeration\n\\param event the event id to render the name of\n\\return the rendered name"]
    pub fn switch_event_name(event: switch_event_types_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief return the event id that matches a given event name\n\\param name the name of the event\n\\param type the event id to return\n\\return SWITCH_STATUS_SUCCESS if there was a match"]
    pub fn switch_name_event(
        name: *const ::std::os::raw::c_char,
        type_: *mut switch_event_types_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Reserve a subclass name for private use with a custom event\n\\param owner the owner of the event name\n\\param subclass_name the name to reserve\n\\return SWITCH_STATUS_SUCCESS if the name was reserved\n\\note There is nothing to enforce this but I recommend using module::event_name for the subclass names"]
    pub fn switch_event_reserve_subclass_detailed(
        owner: *const ::std::os::raw::c_char,
        subclass_name: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_event_free_subclass_detailed(
        owner: *const ::std::os::raw::c_char,
        subclass_name: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Render a string representation of an event suitable for printing or network transport\n\\param event the event to render\n\\param str a string pointer to point at the allocated data\n\\param encode url encode the headers\n\\return SWITCH_STATUS_SUCCESS if the operation was successful\n\\note you must free the resulting string when you are finished with it"]
    pub fn switch_event_binary_deserialize(
        eventp: *mut *mut switch_event_t,
        data: *mut *mut ::std::os::raw::c_void,
        len: switch_size_t,
        duplicate: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_event_binary_serialize(
        event: *mut switch_event_t,
        data: *mut *mut ::std::os::raw::c_void,
        len: *mut switch_size_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_event_serialize(
        event: *mut switch_event_t,
        str_: *mut *mut ::std::os::raw::c_char,
        encode: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_event_serialize_json(
        event: *mut switch_event_t,
        str_: *mut *mut ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_event_serialize_json_obj(
        event: *mut switch_event_t,
        json: *mut *mut cJSON,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_event_create_json(
        event: *mut *mut switch_event_t,
        json: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_event_create_brackets(
        data: *mut ::std::os::raw::c_char,
        a: ::std::os::raw::c_char,
        b: ::std::os::raw::c_char,
        c: ::std::os::raw::c_char,
        event: *mut *mut switch_event_t,
        new_data: *mut *mut ::std::os::raw::c_char,
        dup: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_event_create_array_pair(
        event: *mut *mut switch_event_t,
        names: *mut *mut ::std::os::raw::c_char,
        vals: *mut *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Render a XML representation of an event suitable for printing or network transport\n\\param event the event to render\n\\param fmt optional body of the event (varargs see standard sprintf family)\n\\return the xml object if the operation was successful\n\\note the body supplied by this function will supersede an existing body the event may have"]
    pub fn switch_event_xmlize(
        event: *mut switch_event_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> switch_xml_t;
}
extern "C" {
    #[doc = "\\brief Determine if the event system has been initialized\n\\return SWITCH_STATUS_SUCCESS if the system is running"]
    pub fn switch_event_running() -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Add a body to an event\n\\param event the event to add to body to\n\\param fmt optional body of the event (varargs see standard sprintf family)\n\\return SWITCH_STATUS_SUCCESS if the body was added to the event\n\\note the body parameter can be shadowed by the switch_event_reserve_subclass_detailed function"]
    pub fn switch_event_add_body(
        event: *mut switch_event_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_event_set_body(
        event: *mut switch_event_t,
        body: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_event_expand_headers_check(
        event: *mut switch_event_t,
        in_: *const ::std::os::raw::c_char,
        var_list: *mut switch_event_t,
        api_list: *mut switch_event_t,
        recur: u32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_event_create_pres_in_detailed(
        file: *mut ::std::os::raw::c_char,
        func: *mut ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        proto: *const ::std::os::raw::c_char,
        login: *const ::std::os::raw::c_char,
        from: *const ::std::os::raw::c_char,
        from_domain: *const ::std::os::raw::c_char,
        status: *const ::std::os::raw::c_char,
        event_type: *const ::std::os::raw::c_char,
        alt_event_type: *const ::std::os::raw::c_char,
        event_count: ::std::os::raw::c_int,
        unique_id: *const ::std::os::raw::c_char,
        channel_state: *const ::std::os::raw::c_char,
        answer_state: *const ::std::os::raw::c_char,
        call_direction: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Deliver an event to all of the registered event listeners\n\\param event the event to send (will be nulled)\n\\note normaly use switch_event_fire for delivering events (only use this when you wish to deliver the event blocking on your thread)"]
    pub fn switch_event_deliver(event: *mut *mut switch_event_t);
}
extern "C" {
    pub fn switch_event_build_param_string(
        event: *mut switch_event_t,
        prefix: *const ::std::os::raw::c_char,
        vars_map: *mut switch_hash_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_event_check_permission_list(
        list: *mut switch_event_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_event_add_presence_data_cols(
        channel: *mut switch_channel_t,
        event: *mut switch_event_t,
        prefix: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn switch_json_add_presence_data_cols(
        event: *mut switch_event_t,
        json: *mut cJSON,
        prefix: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn switch_event_launch_dispatch_threads(max: u32);
}
extern "C" {
    pub fn switch_event_channel_broadcast(
        event_channel: *const ::std::os::raw::c_char,
        json: *mut *mut cJSON,
        key: *const ::std::os::raw::c_char,
        id: switch_event_channel_id_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_event_channel_deliver(
        event_channel: *const ::std::os::raw::c_char,
        json: *mut *mut cJSON,
        key: *const ::std::os::raw::c_char,
        id: switch_event_channel_id_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_event_channel_unbind(
        event_channel: *const ::std::os::raw::c_char,
        func: switch_event_channel_func_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> u32;
}
extern "C" {
    pub fn switch_event_channel_bind(
        event_channel: *const ::std::os::raw::c_char,
        func: switch_event_channel_func_t,
        id: *mut switch_event_channel_id_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> switch_status_t;
}
pub type switch_live_array_command_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        la: *mut switch_live_array_t,
        cmd: *const ::std::os::raw::c_char,
        sessid: *const ::std::os::raw::c_char,
        jla: *mut cJSON,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn switch_live_array_clear(la: *mut switch_live_array_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_live_array_bootstrap(
        la: *mut switch_live_array_t,
        sessid: *const ::std::os::raw::c_char,
        channel_id: switch_event_channel_id_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_live_array_destroy(live_arrayP: *mut *mut switch_live_array_t)
        -> switch_status_t;
}
extern "C" {
    pub fn switch_live_array_create(
        event_channel: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        channel_id: switch_event_channel_id_t,
        live_arrayP: *mut *mut switch_live_array_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_live_array_get(
        la: *mut switch_live_array_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn switch_live_array_get_idx(
        la: *mut switch_live_array_t,
        idx: ::std::os::raw::c_int,
    ) -> *mut cJSON;
}
extern "C" {
    pub fn switch_live_array_del(
        la: *mut switch_live_array_t,
        name: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_live_array_add(
        la: *mut switch_live_array_t,
        name: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
        obj: *mut *mut cJSON,
        destroy: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_live_array_visible(
        la: *mut switch_live_array_t,
        visible: switch_bool_t,
        force: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_live_array_isnew(la: *mut switch_live_array_t) -> switch_bool_t;
}
extern "C" {
    pub fn switch_live_array_lock(la: *mut switch_live_array_t);
}
extern "C" {
    pub fn switch_live_array_unlock(la: *mut switch_live_array_t);
}
extern "C" {
    pub fn switch_live_array_set_user_data(
        la: *mut switch_live_array_t,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn switch_live_array_set_command_handler(
        la: *mut switch_live_array_t,
        command_handler: switch_live_array_command_handler_t,
    );
}
extern "C" {
    pub fn switch_live_array_parse_json(json: *mut cJSON, channel_id: switch_event_channel_id_t);
}
extern "C" {
    pub fn switch_live_array_add_alias(
        la: *mut switch_live_array_t,
        event_channel: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    ) -> switch_bool_t;
}
extern "C" {
    pub fn switch_live_array_clear_alias(
        la: *mut switch_live_array_t,
        event_channel: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    ) -> switch_bool_t;
}
extern "C" {
    pub fn switch_event_channel_permission_verify(
        cookie: *const ::std::os::raw::c_char,
        event_channel: *const ::std::os::raw::c_char,
    ) -> switch_bool_t;
}
extern "C" {
    pub fn switch_event_channel_permission_modify(
        cookie: *const ::std::os::raw::c_char,
        event_channel: *const ::std::os::raw::c_char,
        set: switch_bool_t,
    );
}
extern "C" {
    pub fn switch_event_channel_permission_clear(cookie: *const ::std::os::raw::c_char);
}
pub const switch_core_video_filter_t_SCV_FILTER_GRAY_FG: switch_core_video_filter_t = 1;
pub const switch_core_video_filter_t_SCV_FILTER_GRAY_BG: switch_core_video_filter_t = 2;
pub const switch_core_video_filter_t_SCV_FILTER_SEPIA_FG: switch_core_video_filter_t = 4;
pub const switch_core_video_filter_t_SCV_FILTER_SEPIA_BG: switch_core_video_filter_t = 8;
pub const switch_core_video_filter_t_SCV_FILTER_8BIT_FG: switch_core_video_filter_t = 16;
pub type switch_core_video_filter_t = ::std::os::raw::c_uint;
pub const switch_shade_t_SWITCH_SHADE_NONE: switch_shade_t = 0;
pub const switch_shade_t_SWITCH_SHADE_RED: switch_shade_t = 1;
pub const switch_shade_t_SWITCH_SHADE_GREEN: switch_shade_t = 2;
pub const switch_shade_t_SWITCH_SHADE_BLUE: switch_shade_t = 3;
pub const switch_shade_t_SWITCH_SHADE_AUTO: switch_shade_t = 4;
pub type switch_shade_t = ::std::os::raw::c_uint;
pub const switch_img_position_t_POS_LEFT_TOP: switch_img_position_t = 0;
pub const switch_img_position_t_POS_LEFT_MID: switch_img_position_t = 1;
pub const switch_img_position_t_POS_LEFT_BOT: switch_img_position_t = 2;
pub const switch_img_position_t_POS_CENTER_TOP: switch_img_position_t = 3;
pub const switch_img_position_t_POS_CENTER_MID: switch_img_position_t = 4;
pub const switch_img_position_t_POS_CENTER_BOT: switch_img_position_t = 5;
pub const switch_img_position_t_POS_RIGHT_TOP: switch_img_position_t = 6;
pub const switch_img_position_t_POS_RIGHT_MID: switch_img_position_t = 7;
pub const switch_img_position_t_POS_RIGHT_BOT: switch_img_position_t = 8;
pub const switch_img_position_t_POS_NONE: switch_img_position_t = 9;
pub type switch_img_position_t = ::std::os::raw::c_uint;
pub const switch_img_fit_t_SWITCH_FIT_SIZE: switch_img_fit_t = 0;
pub const switch_img_fit_t_SWITCH_FIT_SCALE: switch_img_fit_t = 1;
pub const switch_img_fit_t_SWITCH_FIT_SIZE_AND_SCALE: switch_img_fit_t = 2;
pub const switch_img_fit_t_SWITCH_FIT_NECESSARY: switch_img_fit_t = 3;
pub const switch_img_fit_t_SWITCH_FIT_NONE: switch_img_fit_t = 4;
pub type switch_img_fit_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_yuv_color_s {
    pub y: u8,
    pub u: u8,
    pub v: u8,
}
#[test]
fn bindgen_test_layout_switch_yuv_color_s() {
    const UNINIT: ::std::mem::MaybeUninit<switch_yuv_color_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_yuv_color_s>(),
        3usize,
        concat!("Size of: ", stringify!(switch_yuv_color_s))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_yuv_color_s>(),
        1usize,
        concat!("Alignment of ", stringify!(switch_yuv_color_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_yuv_color_s),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_yuv_color_s),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_yuv_color_s),
            "::",
            stringify!(v)
        )
    );
}
pub type switch_yuv_color_t = switch_yuv_color_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_rgb_color_s {
    pub b: u8,
    pub g: u8,
    pub r: u8,
    pub a: u8,
}
#[test]
fn bindgen_test_layout_switch_rgb_color_s() {
    const UNINIT: ::std::mem::MaybeUninit<switch_rgb_color_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_rgb_color_s>(),
        4usize,
        concat!("Size of: ", stringify!(switch_rgb_color_s))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_rgb_color_s>(),
        1usize,
        concat!("Alignment of ", stringify!(switch_rgb_color_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rgb_color_s),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rgb_color_s),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rgb_color_s),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rgb_color_s),
            "::",
            stringify!(a)
        )
    );
}
pub type switch_rgb_color_t = switch_rgb_color_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_hsl_color_s {
    pub h: f64,
    pub s: f64,
    pub l: f64,
}
#[test]
fn bindgen_test_layout_switch_hsl_color_s() {
    const UNINIT: ::std::mem::MaybeUninit<switch_hsl_color_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_hsl_color_s>(),
        24usize,
        concat!("Size of: ", stringify!(switch_hsl_color_s))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_hsl_color_s>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_hsl_color_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_hsl_color_s),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_hsl_color_s),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_hsl_color_s),
            "::",
            stringify!(l)
        )
    );
}
pub type switch_hsl_color_t = switch_hsl_color_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_lab_color_t {
    pub l: f64,
    pub a: f64,
    pub b: f64,
}
#[test]
fn bindgen_test_layout_switch_lab_color_t() {
    const UNINIT: ::std::mem::MaybeUninit<switch_lab_color_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_lab_color_t>(),
        24usize,
        concat!("Size of: ", stringify!(switch_lab_color_t))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_lab_color_t>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_lab_color_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_lab_color_t),
            "::",
            stringify!(l)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_lab_color_t),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_lab_color_t),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_xyz_color_t {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
#[test]
fn bindgen_test_layout_switch_xyz_color_t() {
    const UNINIT: ::std::mem::MaybeUninit<switch_xyz_color_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_xyz_color_t>(),
        24usize,
        concat!("Size of: ", stringify!(switch_xyz_color_t))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_xyz_color_t>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_xyz_color_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xyz_color_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xyz_color_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xyz_color_t),
            "::",
            stringify!(z)
        )
    );
}
#[doc = "\\brief Representation of a rectangle on a surface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_image_rect {
    #[doc = "< leftmost column"]
    pub x: ::std::os::raw::c_uint,
    #[doc = "< topmost row"]
    pub y: ::std::os::raw::c_uint,
    #[doc = "< width"]
    pub w: ::std::os::raw::c_uint,
    #[doc = "< height"]
    pub h: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_switch_image_rect() {
    const UNINIT: ::std::mem::MaybeUninit<switch_image_rect> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_image_rect>(),
        16usize,
        concat!("Size of: ", stringify!(switch_image_rect))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_image_rect>(),
        4usize,
        concat!("Alignment of ", stringify!(switch_image_rect))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_image_rect),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_image_rect),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_image_rect),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_image_rect),
            "::",
            stringify!(h)
        )
    );
}
#[doc = "\\brief Representation of a rectangle on a surface"]
pub type switch_image_rect_t = switch_image_rect;
pub const switch_convert_fmt_t_SWITCH_CONVERT_FMT_YUYV: switch_convert_fmt_t = 0;
pub type switch_convert_fmt_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_png_opaque_s {
    _unused: [u8; 0],
}
pub type switch_png_opaque_t = switch_png_opaque_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_png_s {
    pub pvt: *mut switch_png_opaque_t,
    pub w: ::std::os::raw::c_int,
    pub h: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_switch_png_s() {
    const UNINIT: ::std::mem::MaybeUninit<switch_png_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_png_s>(),
        16usize,
        concat!("Size of: ", stringify!(switch_png_s))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_png_s>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_png_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pvt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_png_s),
            "::",
            stringify!(pvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_png_s),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_png_s),
            "::",
            stringify!(h)
        )
    );
}
pub type switch_png_t = switch_png_s;
pub const switch_image_rotation_mode_t_SRM_NONE: switch_image_rotation_mode_t = 0;
pub const switch_image_rotation_mode_t_SRM_90: switch_image_rotation_mode_t = 90;
pub const switch_image_rotation_mode_t_SRM_180: switch_image_rotation_mode_t = 180;
pub const switch_image_rotation_mode_t_SRM_270: switch_image_rotation_mode_t = 270;
pub type switch_image_rotation_mode_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = "\\brief Open a descriptor, allocating storage for the underlying image\n\n Returns a descriptor for storing an image of the given format. The\n storage for the descriptor is allocated on the heap.\n\n \\param[in]    img       Pointer to storage for descriptor. If this parameter\n                         is NULL, the storage for the descriptor will be\n                         allocated on the heap.\n \\param[in]    fmt       Format for the image\n \\param[in]    d_w       Width of the image\n \\param[in]    d_h       Height of the image\n \\param[in]    align     Alignment, in bytes, of the image buffer and\n                         each row in the image(stride).\n\n \\return Returns a pointer to the initialized image descriptor. If the img\n         parameter is non-null, the value of the img parameter will be\n         returned."]
    pub fn switch_img_alloc(
        img: *mut switch_image_t,
        fmt: switch_img_fmt_t,
        d_w: ::std::os::raw::c_uint,
        d_h: ::std::os::raw::c_uint,
        align: ::std::os::raw::c_uint,
    ) -> *mut switch_image_t;
}
extern "C" {
    #[doc = "\\brief Open a descriptor, using existing storage for the underlying image\n\n Returns a descriptor for storing an image of the given format. The\n storage for descriptor has been allocated elsewhere, and a descriptor is\n desired to \"wrap\" that storage.\n\n \\param[in]    img       Pointer to storage for descriptor. If this parameter\n                         is NULL, the storage for the descriptor will be\n                         allocated on the heap.\n \\param[in]    fmt       Format for the image\n \\param[in]    d_w       Width of the image\n \\param[in]    d_h       Height of the image\n \\param[in]    align     Alignment, in bytes, of each row in the image.\n \\param[in]    img_data  Storage to use for the image\n\n \\return Returns a pointer to the initialized image descriptor. If the img\n         parameter is non-null, the value of the img parameter will be\n         returned."]
    pub fn switch_img_wrap(
        img: *mut switch_image_t,
        fmt: switch_img_fmt_t,
        d_w: ::std::os::raw::c_uint,
        d_h: ::std::os::raw::c_uint,
        align: ::std::os::raw::c_uint,
        img_data: *mut ::std::os::raw::c_uchar,
    ) -> *mut switch_image_t;
}
extern "C" {
    #[doc = "\\brief Set the rectangle identifying the displayed portion of the image\n\n Updates the displayed rectangle (aka viewport) on the image surface to\n match the specified coordinates and size.\n\n \\param[in]    img       Image descriptor\n \\param[in]    x         leftmost column\n \\param[in]    y         topmost row\n \\param[in]    w         width\n \\param[in]    h         height\n\n \\return 0 if the requested rectangle is valid, nonzero otherwise."]
    pub fn switch_img_set_rect(
        img: *mut switch_image_t,
        x: ::std::os::raw::c_uint,
        y: ::std::os::raw::c_uint,
        w: ::std::os::raw::c_uint,
        h: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief patch a small img to a big IMG at position x,y\n\n Both IMG and img must be non-NULL\n\n \\param[in]    IMG       The BIG Image descriptor\n \\param[in]    img       The small Image descriptor\n \\param[in]    x         Leftmost pos to patch to\n \\param[in]    y         Topmost pos to patch to"]
    pub fn switch_img_patch(
        IMG: *mut switch_image_t,
        img: *mut switch_image_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn switch_img_attenuate(img: *mut switch_image_t);
}
extern "C" {
    #[doc = "\\brief patch a small img to a big IMG at position x,y\n\n Both IMG and img must be non-NULL\n\n \\param[in]    IMG       The BIG Image descriptor\n \\param[in]    img       The small Image descriptor\n \\param[in]    x         Leftmost pos to patch to\n \\param[in]    y         Topmost pos to patch to\n \\param[in]    noalpha   skip writing to non-transparent pixels"]
    pub fn switch_img_patch_rgb(
        IMG: *mut switch_image_t,
        img: *mut switch_image_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        noalpha: switch_bool_t,
    );
}
extern "C" {
    #[doc = "\\brief patch part of a small img (x,y,w,h) to a big IMG at position X,Y\n\n Both IMG and img must be non-NULL\n\n \\param[in]    IMG       The BIG Image descriptor\n \\param[in]    X         Leftmost pos to patch to IMG\n \\param[in]    Y         Topmost pos to patch to IMG\n \\param[in]    img       The small Image descriptor\n \\param[in]    x         Leftmost pos to be read from img\n \\param[in]    y         Topmost pos to be read from\n \\param[in]    w         Max width to be read from img\n \\param[in]    h         Max height to be read from img"]
    pub fn switch_img_patch_rect(
        IMG: *mut switch_image_t,
        X: ::std::os::raw::c_int,
        Y: ::std::os::raw::c_int,
        img: *mut switch_image_t,
        x: u32,
        y: u32,
        w: u32,
        h: u32,
    );
}
extern "C" {
    #[doc = "\\brief Copy image to a new image\n\n if new_img is NULL, a new image is allocated\n if new_img is not NULL but not the same size as img,\n    new_img is destroyed and a new new_img is allocated\n else, copy the img data to the new_img\n\n \\param[in]    img       Image descriptor\n \\param[out]   new_img   New Image descriptor, NULL if out of memory"]
    pub fn switch_img_copy(img: *mut switch_image_t, new_img: *mut *mut switch_image_t);
}
extern "C" {
    pub fn switch_img_rotate_copy(
        img: *mut switch_image_t,
        new_img: *mut *mut switch_image_t,
        mode: switch_image_rotation_mode_t,
    );
}
extern "C" {
    #[doc = "\\brief Flip the image vertically (top for bottom)\n\n Adjusts the image descriptor's pointers and strides to make the image\n be referenced upside-down.\n\n \\param[in]    img       Image descriptor\n\n \\return 0 if the requested rectangle is valid, nonzero otherwise."]
    pub fn switch_img_rotate(img: *mut *mut switch_image_t, mode: switch_image_rotation_mode_t);
}
extern "C" {
    #[doc = "\\brief Close an image descriptor\n\n Frees all allocated storage associated with an image descriptor.\n\n \\param[in]    img       pointer to pointer of Image descriptor"]
    pub fn switch_img_free(img: *mut *mut switch_image_t);
}
extern "C" {
    pub fn switch_img_draw_text(
        IMG: *mut switch_image_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        color: switch_rgb_color_t,
        font_size: u16,
        text: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn switch_img_add_text(
        buffer: *mut ::std::os::raw::c_void,
        w: ::std::os::raw::c_int,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        s: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "\\brief Copy part of an image to a new image\n\n\n \\param[in]    img       Image descriptor\n \\param[in]    x         Leftmost pos to be read from\n \\param[in]    y         Topmost pos to be read from\n \\param[in]    w         Max width to be read from\n \\param[in]    h         Max height to be read from\n\n \\return NULL if failed to copy, otherwise a valid image descriptor."]
    pub fn switch_img_copy_rect(
        img: *mut switch_image_t,
        x: u32,
        y: u32,
        w: u32,
        h: u32,
    ) -> *mut switch_image_t;
}
extern "C" {
    #[doc = "\\brief Fill image with color\n\n \\param[in]    img       Image descriptor\n \\param[in]    x         Leftmost pos to be read from\n \\param[in]    y         Topmost pos to be read from\n \\param[in]    w         Max width to be read from\n \\param[in]    h         Max height to be read from\n \\param[in]    color     RGB color"]
    pub fn switch_img_fill(
        img: *mut switch_image_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        color: *mut switch_rgb_color_t,
    );
}
extern "C" {
    pub fn switch_img_8bit(img: *mut switch_image_t);
}
extern "C" {
    pub fn switch_img_gray(
        img: *mut switch_image_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn switch_img_sepia(
        img: *mut switch_image_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn switch_img_fill_noalpha(
        img: *mut switch_image_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        color: *mut switch_rgb_color_t,
    );
}
extern "C" {
    #[doc = "\\brief Set RGB color with a string\n\n Color string should be in #RRGGBB format\n\n \\param[out]   color     RGB color pointer\n \\param[in]    color_str Color string in #RRGGBB format"]
    pub fn switch_color_set_rgb(
        color: *mut switch_rgb_color_t,
        color_str: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "\\brief Set YUV color with a string\n\n Color string should be in #RRGGBB format\n\n \\param[out]   color     YUV color pointer\n \\param[in]    color_str Color string in #RRGGBB format"]
    pub fn switch_color_set_yuv(
        color: *mut switch_yuv_color_t,
        color_str: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "\\brief Created a text handle\n\n \\param[out]   handleP     Pointer to the text handle pointer\n \\param[in]    font_family Font family\n \\param[in]    font_color  Font color in #RRGGBB format\n \\param[in]    bgcolor     Background color in #RRGGBB format\n \\param[in]    font_size   Font size in point\n \\param[in]    angle       Angle to rotate\n \\param[in]    pool        APR memory pool"]
    pub fn switch_img_txt_handle_create(
        handleP: *mut *mut switch_img_txt_handle_t,
        font_family: *const ::std::os::raw::c_char,
        font_color: *const ::std::os::raw::c_char,
        bgcolor: *const ::std::os::raw::c_char,
        font_size: u16,
        angle: f64,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Free a text handle\n\n \\param[in]   handleP     Pointer to the text handle pointer"]
    pub fn switch_img_txt_handle_destroy(handleP: *mut *mut switch_img_txt_handle_t);
}
extern "C" {
    #[doc = "\\brief Render text to an img\n\n \\param[in]    handle      Pointer to the text handle pointer\n \\param[in]    img         The image to be render text on\n \\param[in]    x           Leftmost position\n \\param[in]    y           Topmost position\n \\param[in]    text        Text to render\n \\param[in]    font_family Font to use, NULL to use the handle font\n \\param[in]    font_color  Font color, NULL to use the handle color\n \\param[in]    bgcolor     Background color, NULL for transparency\n \\param[in]    font_size   Font size in point\n \\param[in]    angle       Angle to rotate"]
    pub fn switch_img_txt_handle_render(
        handle: *mut switch_img_txt_handle_t,
        img: *mut switch_image_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        text: *const ::std::os::raw::c_char,
        font_family: *const ::std::os::raw::c_char,
        font_color: *const ::std::os::raw::c_char,
        bgcolor: *const ::std::os::raw::c_char,
        font_size: u16,
        angle: f64,
    ) -> u32;
}
extern "C" {
    pub fn switch_img_patch_hole(
        IMG: *mut switch_image_t,
        img: *mut switch_image_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        rect: *mut switch_image_rect_t,
    );
}
extern "C" {
    pub fn switch_png_patch_img(
        use_png: *mut switch_png_t,
        img: *mut switch_image_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_img_read_png(
        file_name: *const ::std::os::raw::c_char,
        img_fmt: switch_img_fmt_t,
    ) -> *mut switch_image_t;
}
extern "C" {
    pub fn switch_img_read_png_from_memory(
        mem: *mut ::std::os::raw::c_void,
        size: usize,
        img_fmt: switch_img_fmt_t,
    ) -> *mut switch_image_t;
}
extern "C" {
    pub fn switch_img_write_png(
        img: *mut switch_image_t,
        file_name: *mut ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_png_open(
        pngP: *mut *mut switch_png_t,
        file_name: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_png_free(pngP: *mut *mut switch_png_t);
}
extern "C" {
    pub fn switch_img_data_url_png(
        img: *mut switch_image_t,
        urlP: *mut *mut ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_img_data_url(
        img: *mut switch_image_t,
        urlP: *mut *mut ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        quality: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Read an image file to switch_image_t"]
    pub fn switch_img_read_from_file(
        file_name: *const ::std::os::raw::c_char,
        img_fmt: switch_img_fmt_t,
    ) -> *mut switch_image_t;
}
extern "C" {
    #[doc = "\\brief Write an image file, supported formats png,jpg,bmp,tga,hdr\n \\param[in]    img       The image descriptor\n \\param[in]    file_name The file_name to write\n \\param[in]    quality   Only used in jpg, 1 ~ 100"]
    pub fn switch_img_write_to_file(
        img: *mut switch_image_t,
        file_name: *const ::std::os::raw::c_char,
        quality: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief put a small img over a big IMG at position x,y, with alpha transparency\n\n Both IMG and img must be non-NULL\n\n \\param[in]    IMG       The BIG Image descriptor\n \\param[in]    img       The small Image descriptor\n \\param[in]    x         Leftmost pos\n \\param[in]    y         Topmost pos\n \\param[in]    percent   Alaha value from 0(completely transparent) to 100(opaque)"]
    pub fn switch_img_overlay(
        IMG: *mut switch_image_t,
        img: *mut switch_image_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        percent: u8,
    );
}
extern "C" {
    pub fn switch_img_mirror(
        src: *mut switch_image_t,
        destP: *mut *mut switch_image_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_img_scale(
        src: *mut switch_image_t,
        destP: *mut *mut switch_image_t,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_img_fit(
        srcP: *mut *mut switch_image_t,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        fit: switch_img_fit_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_img_calc_fit(
        src: *mut switch_image_t,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        new_wP: *mut ::std::os::raw::c_int,
        new_hP: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn parse_img_position(name: *const ::std::os::raw::c_char) -> switch_img_position_t;
}
extern "C" {
    pub fn parse_img_fit(name: *const ::std::os::raw::c_char) -> switch_img_fit_t;
}
extern "C" {
    pub fn switch_img_find_position(
        pos: switch_img_position_t,
        sw: ::std::os::raw::c_int,
        sh: ::std::os::raw::c_int,
        iw: ::std::os::raw::c_int,
        ih: ::std::os::raw::c_int,
        xP: *mut ::std::os::raw::c_int,
        yP: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "\\brief convert img to raw format\n\n dest should be pre-allocated and big enough for the target fmt\n\n \\param[in]    src       The image descriptor\n \\param[in]    dest      The target memory address\n \\param[in]    stride    Bytes in a row for the destination. Pass 0 if the buffer has contiguous rows. Can be negative. A multiple of 16 is optimal.\n \\param[in]    fmt       The target format"]
    pub fn switch_img_to_raw(
        src: *mut switch_image_t,
        dest: *mut ::std::os::raw::c_void,
        stride: ::std::os::raw::c_int,
        fmt: switch_img_fmt_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief convert raw memory to switch_img_t\n\n if dest is NULL then a new img is created, user should destroy it later,\n otherwize it will re-used the dest img, and the dest img size must match the src width and height,\n width and height can be 0 in the latter case and it will figure out according to the dest img\n\n \\param[in]    dest      The image descriptor\n \\param[in]    src       The raw data memory address\n \\param[in]    fmt       The raw data format\n \\param[in]    width     The raw data width\n \\param[in]    height    The raw data height"]
    pub fn switch_img_from_raw(
        destP: *mut *mut switch_image_t,
        src: *mut ::std::os::raw::c_void,
        fmt: switch_img_fmt_t,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_img_write_text_img(
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        full: switch_bool_t,
        text: *const ::std::os::raw::c_char,
    ) -> *mut switch_image_t;
}
extern "C" {
    pub fn switch_img_read_file(file_name: *const ::std::os::raw::c_char) -> *mut switch_image_t;
}
extern "C" {
    pub fn switch_img_letterbox(
        img: *mut switch_image_t,
        imgP: *mut *mut switch_image_t,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        color: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_has_video() -> switch_bool_t;
}
extern "C" {
    #[doc = "\\brief I420 to I420 Copy"]
    pub fn switch_I420_copy(
        src_y: *const u8,
        src_stride_y: ::std::os::raw::c_int,
        src_u: *const u8,
        src_stride_u: ::std::os::raw::c_int,
        src_v: *const u8,
        src_stride_v: ::std::os::raw::c_int,
        dst_y: *mut u8,
        dst_stride_y: ::std::os::raw::c_int,
        dst_u: *mut u8,
        dst_stride_u: ::std::os::raw::c_int,
        dst_v: *mut u8,
        dst_stride_v: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_I420_copy2(
        src_planes: *mut *mut u8,
        src_stride: *mut ::std::os::raw::c_int,
        dst_planes: *mut *mut u8,
        dst_stride: *mut ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief I420 to ARGB Convertion"]
    pub fn switch_I420ToARGB(
        src_y: *const u8,
        src_stride_y: ::std::os::raw::c_int,
        src_u: *const u8,
        src_stride_u: ::std::os::raw::c_int,
        src_v: *const u8,
        src_stride_v: ::std::os::raw::c_int,
        dst_argb: *mut u8,
        dst_stride_argb: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_RGBAToARGB(
        src_frame: *const u8,
        src_stride_frame: ::std::os::raw::c_int,
        dst_argb: *mut u8,
        dst_stride_argb: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ABGRToARGB(
        src_frame: *const u8,
        src_stride_frame: ::std::os::raw::c_int,
        dst_argb: *mut u8,
        dst_stride_argb: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ARGBToARGB(
        src_frame: *const u8,
        src_stride_frame: ::std::os::raw::c_int,
        dst_argb: *mut u8,
        dst_stride_argb: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief chromakey an img, img must be RGBA and return modified img"]
    pub fn switch_img_chromakey(
        img: *mut switch_image_t,
        mask: *mut switch_rgb_color_t,
        threshold: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn switch_chromakey_clear_colors(ck: *mut switch_chromakey_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_chromakey_autocolor(
        ck: *mut switch_chromakey_t,
        autocolor: switch_shade_t,
        threshold: u32,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_chromakey_add_color(
        ck: *mut switch_chromakey_t,
        color: *mut switch_rgb_color_t,
        threshold: u32,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_chromakey_destroy(ckP: *mut *mut switch_chromakey_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_chromakey_create(ckP: *mut *mut switch_chromakey_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_chromakey_set_default_threshold(ck: *mut switch_chromakey_t, threshold: u32);
}
extern "C" {
    pub fn switch_chromakey_process(ck: *mut switch_chromakey_t, img: *mut switch_image_t);
}
extern "C" {
    pub fn switch_chromakey_cache_image(ck: *mut switch_chromakey_t) -> *mut switch_image_t;
}
extern "C" {
    pub fn switch_chromakey_str2shade(
        ck: *mut switch_chromakey_t,
        shade_name: *const ::std::os::raw::c_char,
    ) -> switch_shade_t;
}
extern "C" {
    pub fn switch_core_video_parse_filter_string(
        filters: *mut switch_core_video_filter_t,
        filter_str: *const ::std::os::raw::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_unicast_conninfo {
    pub session: *mut switch_core_session_t,
    pub read_codec: switch_codec_t,
    pub write_frame: switch_frame_t,
    pub write_frame_data: [switch_byte_t; 8192usize],
    pub socket: *mut switch_socket_t,
    pub local_ip: *mut ::std::os::raw::c_char,
    pub local_port: switch_port_t,
    pub remote_ip: *mut ::std::os::raw::c_char,
    pub remote_port: switch_port_t,
    pub local_addr: *mut switch_sockaddr_t,
    pub remote_addr: *mut switch_sockaddr_t,
    pub flag_mutex: *mut switch_mutex_t,
    pub flags: i32,
    pub type_: ::std::os::raw::c_int,
    pub transport: ::std::os::raw::c_int,
    pub stream_id: ::std::os::raw::c_int,
    pub thread: *mut switch_thread_t,
}
#[test]
fn bindgen_test_layout_switch_unicast_conninfo() {
    const UNINIT: ::std::mem::MaybeUninit<switch_unicast_conninfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_unicast_conninfo>(),
        8536usize,
        concat!("Size of: ", stringify!(switch_unicast_conninfo))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_unicast_conninfo>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_unicast_conninfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_unicast_conninfo),
            "::",
            stringify!(session)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_codec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_unicast_conninfo),
            "::",
            stringify!(read_codec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_frame) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_unicast_conninfo),
            "::",
            stringify!(write_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_frame_data) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_unicast_conninfo),
            "::",
            stringify!(write_frame_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).socket) as usize - ptr as usize },
        8448usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_unicast_conninfo),
            "::",
            stringify!(socket)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_ip) as usize - ptr as usize },
        8456usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_unicast_conninfo),
            "::",
            stringify!(local_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_port) as usize - ptr as usize },
        8464usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_unicast_conninfo),
            "::",
            stringify!(local_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_ip) as usize - ptr as usize },
        8472usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_unicast_conninfo),
            "::",
            stringify!(remote_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_port) as usize - ptr as usize },
        8480usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_unicast_conninfo),
            "::",
            stringify!(remote_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_addr) as usize - ptr as usize },
        8488usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_unicast_conninfo),
            "::",
            stringify!(local_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_addr) as usize - ptr as usize },
        8496usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_unicast_conninfo),
            "::",
            stringify!(remote_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flag_mutex) as usize - ptr as usize },
        8504usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_unicast_conninfo),
            "::",
            stringify!(flag_mutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8512usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_unicast_conninfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8516usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_unicast_conninfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transport) as usize - ptr as usize },
        8520usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_unicast_conninfo),
            "::",
            stringify!(transport)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_id) as usize - ptr as usize },
        8524usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_unicast_conninfo),
            "::",
            stringify!(stream_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread) as usize - ptr as usize },
        8528usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_unicast_conninfo),
            "::",
            stringify!(thread)
        )
    );
}
pub type switch_unicast_conninfo_t = switch_unicast_conninfo;
extern "C" {
    #[doc = " @defgroup switch_ivr IVR Library\n @ingroup core1\n\tA group of core functions to do IVR related functions designed to be\n\tbuilding blocks for a higher level IVR interface.\n @{"]
    pub fn switch_ivr_deactivate_unicast(session: *mut switch_core_session_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_activate_unicast(
        session: *mut switch_core_session_t,
        local_ip: *mut ::std::os::raw::c_char,
        local_port: switch_port_t,
        remote_ip: *mut ::std::os::raw::c_char,
        remote_port: switch_port_t,
        transport: *mut ::std::os::raw::c_char,
        flags: *mut ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Generate an JSON CDR report.\n\\param session the session to get the data from.\n\\param json_cdr pointer to the json object\n\\return SWITCH_STATUS_SUCCESS if successful\n\\note on success the json object must be freed"]
    pub fn switch_ivr_generate_json_cdr(
        session: *mut switch_core_session_t,
        json_cdr: *mut *mut cJSON,
        urlencode: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Generate an XML CDR report.\n\\param session the session to get the data from.\n\\param xml_cdr pointer to the xml_record\n\\return SWITCH_STATUS_SUCCESS if successful\n\\note on success the xml object must be freed"]
    pub fn switch_ivr_generate_xml_cdr(
        session: *mut switch_core_session_t,
        xml_cdr: *mut switch_xml_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_set_xml_profile_data(
        xml: switch_xml_t,
        caller_profile: *mut switch_caller_profile_t,
        off: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_ivr_set_xml_chan_vars(
        xml: switch_xml_t,
        channel: *mut switch_channel_t,
        off: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Parse command from an event\n\\param session the session on which to parse the event\n\\param event the event to parse\n\\return SWITCH_STATUS_SUCCESS if successful"]
    pub fn switch_ivr_parse_event(
        session: *mut switch_core_session_t,
        event: *mut switch_event_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Parse all commands from an event\n\\param session the session on which to parse the events\n\\return SWITCH_STATUS_SUCCESS if successful"]
    pub fn switch_ivr_parse_all_events(session: *mut switch_core_session_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_parse_next_event(session: *mut switch_core_session_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_parse_all_messages(session: *mut switch_core_session_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_parse_all_signal_data(session: *mut switch_core_session_t)
        -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_parse_signal_data(
        session: *mut switch_core_session_t,
        all: switch_bool_t,
        only_session_thread: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_parse_next_signal_data(
        session: *mut switch_core_session_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_process_indications(
        session: *mut switch_core_session_t,
        message: *mut switch_core_session_message_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Wait for time to pass for a specified number of milliseconds\n\\param session the session to wait for.\n\\param ms the number of milliseconds\n\\param sync synchronize the channel's audio before waiting\n\\param args arguements to pass for callbacks etc\n\\return SWITCH_STATUS_SUCCESS if the channel is still up"]
    pub fn switch_ivr_sleep(
        session: *mut switch_core_session_t,
        ms: u32,
        sync: switch_bool_t,
        args: *mut switch_input_args_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_park(
        session: *mut switch_core_session_t,
        args: *mut switch_input_args_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Wait for DTMF digits calling a pluggable callback function when digits are collected.\n\\param session the session to read.\n\\param args arguements to pass for callbacks etc\n\\param timeout a timeout in milliseconds\n\\return SWITCH_STATUS_SUCCESS to keep the collection moving."]
    pub fn switch_ivr_collect_digits_callback(
        session: *mut switch_core_session_t,
        args: *mut switch_input_args_t,
        digit_timeout: u32,
        abs_timeout: u32,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Wait for specified number of DTMF digits, untile terminator is received or until the channel hangs up.\n\\param session the session to read.\n\\param buf strig to write to\n\\param buflen max size of buf\n\\param maxdigits max number of digits to read\n\\param terminators digits to end the collection\n\\param terminator actual digit that caused the collection to end (if any)\n\\param first_timeout timeout in ms\n\\param digit_timeout digit timeout in ms\n\\param abs_timeout abs timeout in ms\n\\return SWITCH_STATUS_SUCCESS to keep the collection moving."]
    pub fn switch_ivr_collect_digits_count(
        session: *mut switch_core_session_t,
        buf: *mut ::std::os::raw::c_char,
        buflen: switch_size_t,
        maxdigits: switch_size_t,
        terminators: *const ::std::os::raw::c_char,
        terminator: *mut ::std::os::raw::c_char,
        first_timeout: u32,
        digit_timeout: u32,
        abs_timeout: u32,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief play a file to the session while doing speech recognition.\n\\param session the session to play and detect on\n\\param file the path to the file\n\\param mod_name the module name of the ASR library\n\\param grammar the grammar text, URI, or local file name\n\\param result of speech recognition, allocated from the session pool\n\\param input_timeout time to wait for input\n\\param args arguements to pass for callbacks etc\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_play_and_detect_speech(
        session: *mut switch_core_session_t,
        file: *const ::std::os::raw::c_char,
        mod_name: *const ::std::os::raw::c_char,
        grammar: *const ::std::os::raw::c_char,
        result: *mut *mut ::std::os::raw::c_char,
        input_timeout: u32,
        args: *mut switch_input_args_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Initialize background Speech detection on a session, so that parameters can be set, and grammars loaded.\nAfter calling this function, it is possible to call switch_ivr_set_param_detect_speech() to set recognition parameters.\nCalling switch_ivr_detect_speech_load_grammar() starts the speech recognition.\n\\param session the session to attach\n\\param mod_name the module name of the ASR library\n\\param dest the destination address\n\\param ah an ASR handle to use (NULL to create one)\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_detect_speech_init(
        session: *mut switch_core_session_t,
        mod_name: *const ::std::os::raw::c_char,
        dest: *const ::std::os::raw::c_char,
        ah: *mut switch_asr_handle_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Engage background Speech detection on a session\n\\param session the session to attach\n\\param mod_name the module name of the ASR library\n\\param grammar the grammar text, URI, or local file name\n\\param name the grammar name\n\\param dest the destination address\n\\param ah an ASR handle to use (NULL to create one)\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_detect_speech(
        session: *mut switch_core_session_t,
        mod_name: *const ::std::os::raw::c_char,
        grammar: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        dest: *const ::std::os::raw::c_char,
        ah: *mut switch_asr_handle_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Stop background Speech detection on a session\n\\param session The session to stop detection on\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_stop_detect_speech(session: *mut switch_core_session_t) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Pause background Speech detection on a session\n\\param session The session to pause detection on\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_pause_detect_speech(session: *mut switch_core_session_t) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Resume background Speech detection on a session\n\\param session The session to resume detection on\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_resume_detect_speech(session: *mut switch_core_session_t) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Load a grammar on a background speech detection handle\n\\param session The session to change the grammar on\n\\param grammar the grammar text, URI, or local file name\n\\param name the grammar name\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_detect_speech_load_grammar(
        session: *mut switch_core_session_t,
        grammar: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Unload a grammar on a background speech detection handle\n\\param session The session to change the grammar on\n\\param name the grammar name\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_detect_speech_unload_grammar(
        session: *mut switch_core_session_t,
        name: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Enable a grammar on a background speech detection handle\n\\param session The session to change the grammar on\n\\param name the grammar name\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_detect_speech_enable_grammar(
        session: *mut switch_core_session_t,
        name: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Disable a grammar on a background speech detection handle\n\\param session The session to change the grammar on\n\\param name the grammar name\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_detect_speech_disable_grammar(
        session: *mut switch_core_session_t,
        name: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Disable all grammars on a background speech detection handle\n\\param session The session to change the grammar on\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_detect_speech_disable_all_grammars(
        session: *mut switch_core_session_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_set_param_detect_speech(
        session: *mut switch_core_session_t,
        name: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Start input timers on a background speech detection handle\n\\param session The session to start the timers on\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_detect_speech_start_input_timers(
        session: *mut switch_core_session_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Record a session to disk\n\\param session the session to record\n\\param file the path to the file\n\\param limit stop recording after this amount of time (in ms, 0 = never stop)\n\\param fh file handle to use (NULL for builtin one)\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_record_session(
        session: *mut switch_core_session_t,
        file: *const ::std::os::raw::c_char,
        limit: u32,
        fh: *mut switch_file_handle_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_record_session_event(
        session: *mut switch_core_session_t,
        file: *const ::std::os::raw::c_char,
        limit: u32,
        fh: *mut switch_file_handle_t,
        variables: *mut switch_event_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_transfer_recordings(
        orig_session: *mut switch_core_session_t,
        new_session: *mut switch_core_session_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_eavesdrop_pop_eavesdropper(
        session: *mut switch_core_session_t,
        sessionp: *mut *mut switch_core_session_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_eavesdrop_exec_all(
        session: *mut switch_core_session_t,
        app: *const ::std::os::raw::c_char,
        arg: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_eavesdrop_update_display(
        session: *mut switch_core_session_t,
        name: *const ::std::os::raw::c_char,
        number: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Eavesdrop on a another session\n\\param session our session\n\\param uuid the uuid of the session to spy on\n\\param require_group group name to use to limit by group\n\\param flags tweak read-mux, write-mux and dtmf\n\\return SWITCH_STATUS_SUCESS if all is well"]
    pub fn switch_ivr_eavesdrop_session(
        session: *mut switch_core_session_t,
        uuid: *const ::std::os::raw::c_char,
        require_group: *const ::std::os::raw::c_char,
        flags: switch_eavesdrop_flag_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief displace the media for a session with the audio from a file\n\\param session the session to displace\n\\param file filename\n\\param limit time limit in ms\n\\param flags m (mux) l (loop) or r(read session instead of write session)\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_displace_session(
        session: *mut switch_core_session_t,
        file: *const ::std::os::raw::c_char,
        limit: u32,
        flags: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Stop displacing a session\n\\param session the session\n\\param file file name from the switch_ivr_displace_session call\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_stop_displace_session(
        session: *mut switch_core_session_t,
        file: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Stop Recording a session\n\\param session the session to stop recording\n\\param file the path to the file\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_stop_record_session(
        session: *mut switch_core_session_t,
        file: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_session_audio(
        session: *mut switch_core_session_t,
        cmd: *const ::std::os::raw::c_char,
        direction: *const ::std::os::raw::c_char,
        level: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_stop_session_audio(session: *mut switch_core_session_t) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Start looking for DTMF inband\n\\param session the session to start looking\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_inband_dtmf_session(session: *mut switch_core_session_t) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Stop looking for DTMF inband\n\\param session the session to stop looking\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_stop_inband_dtmf_session(
        session: *mut switch_core_session_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Start generating DTMF inband\n\\param session the session to generate on\n\\param read_stream true to use the session we are reading from, false for the session we are writing to.\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_inband_dtmf_generate_session(
        session: *mut switch_core_session_t,
        read_stream: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Stop generating DTMF inband\n\\param session the session to stop generating\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_stop_inband_dtmf_generate_session(
        session: *mut switch_core_session_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief - NEEDDESC -\n\\param session the session to act on"]
    pub fn switch_ivr_session_echo(
        session: *mut switch_core_session_t,
        args: *mut switch_input_args_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Stop looking for TONES\n\\param session the session to stop looking\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_stop_tone_detect_session(
        session: *mut switch_core_session_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Start looking for TONES\n\\param session the session to start looking\n\\param key the name of the tone.\n\\param tone_spec comma sep list of tone freqs\n\\param flags one or both of 'r' and 'w'\n\\param timeout timeout\n\\param app optional application to execute when tone is found\n\\param data optional data for appliaction\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_tone_detect_session(
        session: *mut switch_core_session_t,
        key: *const ::std::os::raw::c_char,
        tone_spec: *const ::std::os::raw::c_char,
        flags: *const ::std::os::raw::c_char,
        timeout: time_t,
        hits: ::std::os::raw::c_int,
        app: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_char,
        callback: switch_tone_detect_callback_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief play a file from the disk to the session\n\\param session the session to play the file too\n\\param fh file handle to use (NULL for builtin one)\n\\param file the path to the file\n\\param args arguements to pass for callbacks etc\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_play_file(
        session: *mut switch_core_session_t,
        fh: *mut switch_file_handle_t,
        file: *const ::std::os::raw::c_char,
        args: *mut switch_input_args_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_detect_audio(
        session: *mut switch_core_session_t,
        thresh: u32,
        audio_hits: u32,
        timeout_ms: u32,
        file: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_detect_silence(
        session: *mut switch_core_session_t,
        thresh: u32,
        silence_hits: u32,
        timeout_ms: u32,
        file: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_wait_for_silence(
        session: *mut switch_core_session_t,
        thresh: u32,
        silence_hits: u32,
        listen_hits: u32,
        timeout_ms: u32,
        file: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_gentones(
        session: *mut switch_core_session_t,
        script: *const ::std::os::raw::c_char,
        loops: i32,
        args: *mut switch_input_args_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief record a file from the session to a file\n\\param session the session to record from\n\\param fh file handle to use\n\\param file the path to the file\n\\param args arguements to pass for callbacks etc\n\\param limit max limit to record for (0 for infinite)\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_record_file(
        session: *mut switch_core_session_t,
        fh: *mut switch_file_handle_t,
        file: *const ::std::os::raw::c_char,
        args: *mut switch_input_args_t,
        limit: u32,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief record a file from the session to a file\n\\param session the session to record from\n\\param fh file handle to use\n\\param file the path to the file\n\\param args arguements to pass for callbacks etc\n\\param limit max limit to record for (0 for infinite)\n\\param vars vars to add to RECORD_START and RECORD_STOP automatically prefixed with Recording-Variable-\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_record_file_event(
        session: *mut switch_core_session_t,
        fh: *mut switch_file_handle_t,
        file: *const ::std::os::raw::c_char,
        args: *mut switch_input_args_t,
        limit: u32,
        vars: *mut switch_event_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Play a sound and gather digits with the number of retries specified if the user doesn't give digits in the set time\n\\param session the current session to play sound to and collect digits\n\\param min_digits the fewest digits allowed for the response to be valid\n\\param max_digits the max number of digits to accept\n\\param max_tries number of times to replay the sound and capture digits\n\\param timeout time to wait for input (this is per iteration, so total possible time = max_tries * (timeout + audio playback length)\n\\param valid_terminators for input that can include # or * (useful for variable length prompts)\n\\param audio_file file to play\n\\param bad_input_audio_file file to play if the input from the user was invalid\n\\param var_name variable name to put results in\n\\param digit_buffer variable digits captured will be put back into (empty if capture failed)\n\\param digit_buffer_length length of the buffer for digits (should be the same or larger than max_digits)\n\\param digits_regex the qualifying regex\n\\return switch status, used to note status of channel (will still return success if digit capture failed)\n\\note to test for digit capture failure look for \\\\0 in the first position of the buffer"]
    pub fn switch_play_and_get_digits(
        session: *mut switch_core_session_t,
        min_digits: u32,
        max_digits: u32,
        max_tries: u32,
        timeout: u32,
        valid_terminators: *const ::std::os::raw::c_char,
        audio_file: *const ::std::os::raw::c_char,
        bad_input_audio_file: *const ::std::os::raw::c_char,
        var_name: *const ::std::os::raw::c_char,
        digit_buffer: *mut ::std::os::raw::c_char,
        digit_buffer_length: u32,
        digits_regex: *const ::std::os::raw::c_char,
        digit_timeout: u32,
        transfer_on_failure: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_speak_text_handle(
        session: *mut switch_core_session_t,
        sh: *mut switch_speech_handle_t,
        codec: *mut switch_codec_t,
        timer: *mut switch_timer_t,
        text: *const ::std::os::raw::c_char,
        args: *mut switch_input_args_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_clear_speech_cache(session: *mut switch_core_session_t);
}
extern "C" {
    #[doc = "\\brief Speak given text with given tts engine\n\\param session the session to speak on\n\\param tts_name the desired tts module\n\\param voice_name the desired voice\n\\param text the text to speak\n\\param args arguements to pass for callbacks etc\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_speak_text(
        session: *mut switch_core_session_t,
        tts_name: *const ::std::os::raw::c_char,
        voice_name: *const ::std::os::raw::c_char,
        text: *const ::std::os::raw::c_char,
        args: *mut switch_input_args_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Make an outgoing call\n\\param session originating session\n\\param bleg B leg session\n\\param cause a pointer to hold call cause\n\\param bridgeto the desired remote callstring\n\\param timelimit_sec timeout in seconds for outgoing call\n\\param table optional state handler table to install on the channel\n\\param cid_name_override override the caller id name\n\\param cid_num_override override the caller id number\n\\param caller_profile_override override the entire calling caller profile\n\\param ovars variables to be set on the outgoing channel\n\\param flags flags to pass\n\\return SWITCH_STATUS_SUCCESS if bleg is a running session.\n\\note bleg will be read locked which must be unlocked with switch_core_session_rwunlock() before losing scope"]
    pub fn switch_ivr_originate(
        session: *mut switch_core_session_t,
        bleg: *mut *mut switch_core_session_t,
        cause: *mut switch_call_cause_t,
        bridgeto: *const ::std::os::raw::c_char,
        timelimit_sec: u32,
        table: *const switch_state_handler_table_t,
        cid_name_override: *const ::std::os::raw::c_char,
        cid_num_override: *const ::std::os::raw::c_char,
        caller_profile_override: *mut switch_caller_profile_t,
        ovars: *mut switch_event_t,
        flags: switch_originate_flag_t,
        cancel_cause: *mut switch_call_cause_t,
        dh: *mut switch_dial_handle_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_enterprise_originate(
        session: *mut switch_core_session_t,
        bleg: *mut *mut switch_core_session_t,
        cause: *mut switch_call_cause_t,
        bridgeto: *const ::std::os::raw::c_char,
        timelimit_sec: u32,
        table: *const switch_state_handler_table_t,
        cid_name_override: *const ::std::os::raw::c_char,
        cid_num_override: *const ::std::os::raw::c_char,
        caller_profile_override: *mut switch_caller_profile_t,
        ovars: *mut switch_event_t,
        flags: switch_originate_flag_t,
        cancel_cause: *mut switch_call_cause_t,
        hl: *mut switch_dial_handle_list_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_bridge_display(
        session: *mut switch_core_session_t,
        peer_session: *mut switch_core_session_t,
    );
}
extern "C" {
    #[doc = "\\brief Bridge Audio from one session to another\n\\param session one session\n\\param peer_session the other session\n\\param dtmf_callback a callback for messages and dtmf\n\\param session_data data to pass to the DTMF callback for session\n\\param peer_session_data data to pass to the DTMF callback for peer_session\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_multi_threaded_bridge(
        session: *mut switch_core_session_t,
        peer_session: *mut switch_core_session_t,
        dtmf_callback: switch_input_callback_function_t,
        session_data: *mut ::std::os::raw::c_void,
        peer_session_data: *mut ::std::os::raw::c_void,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Bridge leaving b-leg in the control of another thread.  Call from b-leg first then call switch_ivr_multi_threaded_bridge on a-leg and b-leg.\n\\param session b-leg session\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_bridge_bleg(
        session: *mut switch_core_session_t,
        peer_session: *mut switch_core_session_t,
        max_wait_ms: u32,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Bridge Signalling from one session to another\n\\param session one session\n\\param peer_session the other session\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_signal_bridge(
        session: *mut switch_core_session_t,
        peer_session: *mut switch_core_session_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_check_hold(session: *mut switch_core_session_t);
}
extern "C" {
    #[doc = "\\brief Transfer an existing session to another location\n\\param session the session to transfer\n\\param extension the new extension\n\\param dialplan the new dialplan (OPTIONAL, may be NULL)\n\\param context the new context (OPTIONAL, may be NULL)"]
    pub fn switch_ivr_session_transfer(
        session: *mut switch_core_session_t,
        extension: *const ::std::os::raw::c_char,
        dialplan: *const ::std::os::raw::c_char,
        context: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Transfer an existing session to another location in the future\n\\param runtime the time (int epoch seconds) to transfer the call\n\\param uuid the uuid of the session to transfer\n\\param extension the new extension\n\\param dialplan the new dialplan (OPTIONAL, may be NULL)\n\\param context the new context (OPTIONAL, may be NULL)\n\\return the id of the task"]
    pub fn switch_ivr_schedule_transfer(
        runtime: time_t,
        uuid: *const ::std::os::raw::c_char,
        extension: *mut ::std::os::raw::c_char,
        dialplan: *mut ::std::os::raw::c_char,
        context: *mut ::std::os::raw::c_char,
    ) -> u32;
}
extern "C" {
    #[doc = "\\brief Hangup an existing session in the future\n\\param runtime the time (int epoch seconds) to transfer the call\n\\param uuid the uuid of the session to hangup\n\\param cause the hanup cause code\n\\param bleg hangup up the B-Leg if possible\n\\return the id of the task"]
    pub fn switch_ivr_schedule_hangup(
        runtime: time_t,
        uuid: *const ::std::os::raw::c_char,
        cause: switch_call_cause_t,
        bleg: switch_bool_t,
    ) -> u32;
}
extern "C" {
    #[doc = "\\brief Bridge two existing sessions\n\\param originator_uuid the uuid of the originator\n\\param originatee_uuid the uuid of the originator\n\\remark Any custom state handlers on both channels will be deleted\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_uuid_bridge(
        originator_uuid: *const ::std::os::raw::c_char,
        originatee_uuid: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Signal a session to request direct media access to it's remote end\n\\param uuid the uuid of the session to request\n\\param flags flags to influence behaviour (SMF_REBRIDGE to rebridge the call in media mode)\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_media(
        uuid: *const ::std::os::raw::c_char,
        flags: switch_media_flag_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_3p_media(
        uuid: *const ::std::os::raw::c_char,
        flags: switch_media_flag_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Signal a session to request indirect media allowing it to exchange media directly with another device\n\\param uuid the uuid of the session to request\n\\param flags flags to influence behaviour (SMF_REBRIDGE to rebridge the call in no_media mode)\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_nomedia(
        uuid: *const ::std::os::raw::c_char,
        flags: switch_media_flag_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_3p_nomedia(
        uuid: *const ::std::os::raw::c_char,
        flags: switch_media_flag_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_bg_media(
        uuid: *const ::std::os::raw::c_char,
        flags: switch_media_flag_t,
        on: switch_bool_t,
        is3p: switch_bool_t,
        delay: u32,
    );
}
extern "C" {
    #[doc = "\\brief Signal the session with a protocol specific hold message.\n\\param uuid the uuid of the session to hold\n\\param message optional message\n\\param moh play music-on-hold\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_hold_uuid(
        uuid: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
        moh: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Toggles channel hold state of session\n\\param uuid the uuid of the session to hold\n\\param message optional message\n\\param moh play music-on-hold\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_hold_toggle_uuid(
        uuid: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
        moh: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Signal the session with a protocol specific unhold message.\n\\param uuid the uuid of the session to hold\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_unhold_uuid(uuid: *const ::std::os::raw::c_char) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Signal the session with a protocol specific hold message.\n\\param session the session to hold\n\\param message optional message\n\\param moh play music-on-hold\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_hold(
        session: *mut switch_core_session_t,
        message: *const ::std::os::raw::c_char,
        moh: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Signal the session with a protocol specific unhold message.\n\\param session the session to unhold\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_unhold(session: *mut switch_core_session_t) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Signal the session to broadcast audio in the future\n\\param runtime when (in epoch time) to run the broadcast\n\\param uuid the uuid of the session to broadcast on\n\\param path the path data of the broadcast \"/path/to/file.wav [<timer name>]\" or \"speak:<engine>|<voice>|<Text to say>\"\n\\param flags flags to send to the request (SMF_ECHO_BRIDGED to send the broadcast to both sides of the call)\n\\return the id of the task"]
    pub fn switch_ivr_schedule_broadcast(
        runtime: time_t,
        uuid: *const ::std::os::raw::c_char,
        path: *const ::std::os::raw::c_char,
        flags: switch_media_flag_t,
    ) -> u32;
}
extern "C" {
    #[doc = "\\brief Signal the session to broadcast audio\n\\param uuid the uuid of the session to broadcast on\n\\param path the path data of the broadcast \"/path/to/file.wav [<timer name>]\" or \"speak:<engine>|<voice>|<Text to say>\"\n\\param flags flags to send to the request (SMF_ECHO_BRIDGED to send the broadcast to both sides of the call)\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_broadcast(
        uuid: *const ::std::os::raw::c_char,
        path: *const ::std::os::raw::c_char,
        flags: switch_media_flag_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_broadcast_in_thread(
        session: *mut switch_core_session_t,
        app: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "\\brief Transfer variables from one session to another\n\\param sessa the original session\n\\param sessb the new session\n\\param var the name of the variable to transfer (NULL for all)\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_transfer_variable(
        sessa: *mut switch_core_session_t,
        sessb: *mut switch_core_session_t,
        var: *mut ::std::os::raw::c_char,
    ) -> switch_status_t;
}
pub type switch_ivr_digit_stream_parser_t = switch_ivr_digit_stream_parser;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_ivr_digit_stream {
    _unused: [u8; 0],
}
pub type switch_ivr_digit_stream_t = switch_ivr_digit_stream;
extern "C" {
    #[doc = "\\brief Create a digit stream parser object\n\\param pool the pool to use for the new hash\n\\param parser a pointer to the object pointer\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_digit_stream_parser_new(
        pool: *mut switch_memory_pool_t,
        parser: *mut *mut switch_ivr_digit_stream_parser_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Destroy a digit stream parser object\n\\param parser a pointer to the parser object\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_digit_stream_parser_destroy(
        parser: *mut switch_ivr_digit_stream_parser_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Create a new digit stream object\n\\param parser a pointer to the parser object created by switch_ivr_digit_stream_parser_new\n\\param stream a pointer to the stream object pointer\n\\return NULL if no match found or consumer data that was associated with a given digit string when matched"]
    pub fn switch_ivr_digit_stream_new(
        parser: *mut switch_ivr_digit_stream_parser_t,
        stream: *mut *mut switch_ivr_digit_stream_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Destroys a digit stream object\n\\param stream a pointer to the stream object\n\\return NULL if no match found or consumer data that was associated with a given digit string when matched"]
    pub fn switch_ivr_digit_stream_destroy(
        stream: *mut *mut switch_ivr_digit_stream_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Set a digit string to action mapping\n\\param parser a pointer to the parser object created by switch_ivr_digit_stream_parser_new\n\\param digits a string of digits to associate with an action\n\\param data consumer data attached to this digit string\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_digit_stream_parser_set_event(
        parser: *mut switch_ivr_digit_stream_parser_t,
        digits: *mut ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Delete a string to action mapping\n\\param parser a pointer to the parser object created by switch_ivr_digit_stream_parser_new\n\\param digits the digit string to be removed from the map\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_digit_stream_parser_del_event(
        parser: *mut switch_ivr_digit_stream_parser_t,
        digits: *mut ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Feed digits collected into the stream for event match testing\n\\param parser a pointer to the parser object created by switch_ivr_digit_stream_parser_new\n\\param stream a stream to write data to\n\\param digit a digit to collect and test against the map of digit strings\n\\return NULL if no match found or consumer data that was associated with a given digit string when matched"]
    pub fn switch_ivr_digit_stream_parser_feed(
        parser: *mut switch_ivr_digit_stream_parser_t,
        stream: *mut switch_ivr_digit_stream_t,
        digit: ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "\\brief Reset the collected digit stream to nothing\n\\param stream a pointer to the parser stream object created by switch_ivr_digit_stream_new\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_digit_stream_reset(stream: *mut switch_ivr_digit_stream_t)
        -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Set a digit string terminator\n\\param parser a pointer to the parser object created by switch_ivr_digit_stream_parser_new\n\\param digit the terminator digit\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_digit_stream_parser_set_terminator(
        parser: *mut switch_ivr_digit_stream_parser_t,
        digit: ::std::os::raw::c_char,
    ) -> switch_status_t;
}
pub const switch_ivr_menu_flags_SWITCH_IVR_MENU_FLAG_FALLTOMAIN: switch_ivr_menu_flags = 1;
pub const switch_ivr_menu_flags_SWITCH_IVR_MENU_FLAG_FREEPOOL: switch_ivr_menu_flags = 2;
pub const switch_ivr_menu_flags_SWITCH_IVR_MENU_FLAG_STACK: switch_ivr_menu_flags = 4;
#[doc = " @defgroup switch_ivr_menu IVR Menu Library\n @ingroup switch_ivr\n\tIVR menu functions\n\n @{"]
pub type switch_ivr_menu_flags = ::std::os::raw::c_uint;
pub const switch_ivr_action_t_SWITCH_IVR_ACTION_DIE: switch_ivr_action_t = 0;
pub const switch_ivr_action_t_SWITCH_IVR_ACTION_EXECMENU: switch_ivr_action_t = 1;
pub const switch_ivr_action_t_SWITCH_IVR_ACTION_EXECAPP: switch_ivr_action_t = 2;
pub const switch_ivr_action_t_SWITCH_IVR_ACTION_PLAYSOUND: switch_ivr_action_t = 3;
pub const switch_ivr_action_t_SWITCH_IVR_ACTION_BACK: switch_ivr_action_t = 4;
pub const switch_ivr_action_t_SWITCH_IVR_ACTION_TOMAIN: switch_ivr_action_t = 5;
pub const switch_ivr_action_t_SWITCH_IVR_ACTION_NOOP: switch_ivr_action_t = 6;
pub type switch_ivr_action_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_ivr_menu {
    _unused: [u8; 0],
}
pub type switch_ivr_menu_action_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut switch_ivr_menu,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: usize,
        arg5: *mut ::std::os::raw::c_void,
    ) -> switch_ivr_action_t,
>;
pub type switch_ivr_menu_t = switch_ivr_menu;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_ivr_menu_action {
    _unused: [u8; 0],
}
pub type switch_ivr_menu_action_t = switch_ivr_menu_action;
extern "C" {
    #[doc = "\\brief Create a new menu object.\n\\param new_menu the pointer to the new menu\n\\param main The top level menu, (NULL if this is the top level one).\n\\param name A pointer to the name of this menu.\n\\param greeting_sound Optional pointer to a main sound (press 1 for this 2 for that).\n\\param short_greeting_sound Optional pointer to a shorter main sound for subsequent loops.\n\\param invalid_sound Optional pointer to a sound to play after invalid input.\n\\param exit_sound Optional pointer to a sound to play upon exiting the menu.\n\\param transfer_sound Optional pointer to a sound to play upon transfer away from the menu.\n\\param confirm_macro phrase macro name to confirm input\n\\param confirm_key the dtmf key required for positive confirmation\n\\param tts_engine the tts engine to use for this menu\n\\param tts_voice the tts voice to use for this menu\n\\param confirm_attempts number of times to prompt to confirm input before failure\n\\param inter_timeout inter-digit timeout\n\\param digit_len max number of digits\n\\param timeout A number of milliseconds to pause before looping.\n\\param max_failures Maximum number of failures to withstand before hangingup This resets everytime you enter the menu.\n\\param pool memory pool (NULL to create one).\n\\return SWITCH_STATUS_SUCCESS if the menu was created."]
    pub fn switch_ivr_menu_init(
        new_menu: *mut *mut switch_ivr_menu_t,
        main: *mut switch_ivr_menu_t,
        name: *const ::std::os::raw::c_char,
        greeting_sound: *const ::std::os::raw::c_char,
        short_greeting_sound: *const ::std::os::raw::c_char,
        invalid_sound: *const ::std::os::raw::c_char,
        exit_sound: *const ::std::os::raw::c_char,
        transfer_sound: *const ::std::os::raw::c_char,
        confirm_macro: *const ::std::os::raw::c_char,
        confirm_key: *const ::std::os::raw::c_char,
        tts_engine: *const ::std::os::raw::c_char,
        tts_voice: *const ::std::os::raw::c_char,
        confirm_attempts: ::std::os::raw::c_int,
        inter_timeout: ::std::os::raw::c_int,
        digit_len: ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_int,
        max_failures: ::std::os::raw::c_int,
        max_timeouts: ::std::os::raw::c_int,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief switch_ivr_menu_bind_action: Bind a keystroke to an action.\n\\param menu The menu obj you wish to bind to.\n\\param ivr_action switch_ivr_action_t enum of what you want to do.\n\\param arg Optional (sometimes necessary) string arguement.\n\\param bind KeyStrokes to bind the action to.\n\\return SWUTCH_STATUS_SUCCESS if the action was binded"]
    pub fn switch_ivr_menu_bind_action(
        menu: *mut switch_ivr_menu_t,
        ivr_action: switch_ivr_action_t,
        arg: *const ::std::os::raw::c_char,
        bind: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Bind a keystroke to a callback function.\n\\param menu The menu obj you wish to bind to.\n\\param function The function to call [int proto(struct switch_ivr_menu *, char *, size_t, void *)]\n\\param arg Optional (sometimes necessary) string arguement.\n\\param bind KeyStrokes to bind the action to.\n\\note The function is passed a buffer to fill in with any required argument data.\n\\note The function is also passed an optional void pointer to an object set upon menu execution. (think threads)\n\\note The function returns an switch_ivr_action_t enum of what you want to do. and looks to your buffer for args.\n\\return SWUTCH_STATUS_SUCCESS if the function was binded"]
    pub fn switch_ivr_menu_bind_function(
        menu: *mut switch_ivr_menu_t,
        function: switch_ivr_menu_action_function_t,
        arg: *const ::std::os::raw::c_char,
        bind: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Execute a menu.\n\\param session The session running the menu.\n\\param stack The top-level menu object (the first one you created.)\n\\param name A pointer to the name of the menu.\n\\param obj A void pointer to an object you want to make avaliable to your callback functions that you may have binded with switch_ivr_menu_bind_function.\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_menu_execute(
        session: *mut switch_core_session_t,
        stack: *mut switch_ivr_menu_t,
        name: *mut ::std::os::raw::c_char,
        obj: *mut ::std::os::raw::c_void,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief free a stack of menu objects.\n\\param stack The top level menu you wish to destroy.\n\\return SWITCH_STATUS_SUCCESS if the object was a top level menu and it was freed"]
    pub fn switch_ivr_menu_stack_free(stack: *mut switch_ivr_menu_t) -> switch_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_ivr_menu_xml_ctx {
    _unused: [u8; 0],
}
pub type switch_ivr_menu_xml_ctx_t = switch_ivr_menu_xml_ctx;
extern "C" {
    #[doc = "\\brief Build a menu stack from an xml source\n\\param xml_menu_ctx The XML menu parser context previously created by switch_ivr_menu_stack_xml_init\n\\param menu_stack The menu stack object that will be created for you\n\\param xml_menus The xml Menus source\n\\param xml_menu The xml Menu source of the menu to be created\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_menu_stack_xml_build(
        xml_menu_ctx: *mut switch_ivr_menu_xml_ctx_t,
        menu_stack: *mut *mut switch_ivr_menu_t,
        xml_menus: switch_xml_t,
        xml_menu: switch_xml_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_menu_str2action(
        action_name: *const ::std::os::raw::c_char,
        action: *mut switch_ivr_action_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\param xml_menu_ctx The XML menu parser context previously created by switch_ivr_menu_stack_xml_init\n\\param name The xml tag name to add to the parser engine\n\\param function The menu function callback that will be executed when menu digits are bound to this name\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_menu_stack_xml_add_custom(
        xml_menu_ctx: *mut switch_ivr_menu_xml_ctx_t,
        name: *const ::std::os::raw::c_char,
        function: switch_ivr_menu_action_function_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\param xml_menu_ctx A pointer of a XML menu parser context to be created\n\\param pool memory pool (NULL to create one)\n\\return SWITCH_STATUS_SUCCESS if all is well"]
    pub fn switch_ivr_menu_stack_xml_init(
        xml_menu_ctx: *mut *mut switch_ivr_menu_xml_ctx_t,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_phrase_macro_event(
        session: *mut switch_core_session_t,
        macro_name: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_char,
        event: *mut switch_event_t,
        lang: *const ::std::os::raw::c_char,
        args: *mut switch_input_args_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_delay_echo(session: *mut switch_core_session_t, delay_ms: u32);
}
extern "C" {
    pub fn switch_ivr_find_bridged_uuid(
        uuid: *const ::std::os::raw::c_char,
        b_uuid: *mut ::std::os::raw::c_char,
        blen: switch_size_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_intercept_session(
        session: *mut switch_core_session_t,
        uuid: *const ::std::os::raw::c_char,
        bleg: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_park_session(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_ivr_wait_for_answer(
        session: *mut switch_core_session_t,
        peer_session: *mut switch_core_session_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_read(
        session: *mut switch_core_session_t,
        min_digits: u32,
        max_digits: u32,
        prompt_audio_file: *const ::std::os::raw::c_char,
        var_name: *const ::std::os::raw::c_char,
        digit_buffer: *mut ::std::os::raw::c_char,
        digit_buffer_length: switch_size_t,
        timeout: u32,
        valid_terminators: *const ::std::os::raw::c_char,
        digit_timeout: u32,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_block_dtmf_session(session: *mut switch_core_session_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_unblock_dtmf_session(session: *mut switch_core_session_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_bind_dtmf_meta_session(
        session: *mut switch_core_session_t,
        key: u32,
        bind_flags: switch_bind_flag_t,
        app: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_unbind_dtmf_meta_session(
        session: *mut switch_core_session_t,
        key: u32,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_soft_hold(
        session: *mut switch_core_session_t,
        unhold_key: *const ::std::os::raw::c_char,
        moh_a: *const ::std::os::raw::c_char,
        moh_b: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_say(
        session: *mut switch_core_session_t,
        tosay: *const ::std::os::raw::c_char,
        module_name: *const ::std::os::raw::c_char,
        say_type: *const ::std::os::raw::c_char,
        say_method: *const ::std::os::raw::c_char,
        say_gender: *const ::std::os::raw::c_char,
        args: *mut switch_input_args_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_say_string(
        session: *mut switch_core_session_t,
        lang: *const ::std::os::raw::c_char,
        ext: *const ::std::os::raw::c_char,
        tosay: *const ::std::os::raw::c_char,
        module_name: *const ::std::os::raw::c_char,
        say_type: *const ::std::os::raw::c_char,
        say_method: *const ::std::os::raw::c_char,
        say_gender: *const ::std::os::raw::c_char,
        rstr: *mut *mut ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_get_say_method_by_name(
        name: *const ::std::os::raw::c_char,
    ) -> switch_say_method_t;
}
extern "C" {
    pub fn switch_ivr_get_say_gender_by_name(
        name: *const ::std::os::raw::c_char,
    ) -> switch_say_gender_t;
}
extern "C" {
    pub fn switch_ivr_get_say_type_by_name(
        name: *const ::std::os::raw::c_char,
    ) -> switch_say_type_t;
}
extern "C" {
    pub fn switch_ivr_say_spell(
        session: *mut switch_core_session_t,
        tosay: *mut ::std::os::raw::c_char,
        say_args: *mut switch_say_args_t,
        args: *mut switch_input_args_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_say_ip(
        session: *mut switch_core_session_t,
        tosay: *mut ::std::os::raw::c_char,
        number_func: switch_say_callback_t,
        say_args: *mut switch_say_args_t,
        args: *mut switch_input_args_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_set_user(
        session: *mut switch_core_session_t,
        data: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_set_user_extended(
        session: *mut switch_core_session_t,
        data: *const ::std::os::raw::c_char,
        params: *mut switch_event_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_set_user_xml(
        session: *mut switch_core_session_t,
        prefix: *const ::std::os::raw::c_char,
        user: *const ::std::os::raw::c_char,
        domain: *const ::std::os::raw::c_char,
        x_user: switch_xml_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_sound_test(session: *mut switch_core_session_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_process_import(
        session: *mut switch_core_session_t,
        peer_channel: *mut switch_channel_t,
        varname: *const ::std::os::raw::c_char,
        prefix: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn switch_ivr_uuid_exists(uuid: *const ::std::os::raw::c_char) -> switch_bool_t;
}
extern "C" {
    pub fn switch_ivr_uuid_force_exists(uuid: *const ::std::os::raw::c_char) -> switch_bool_t;
}
extern "C" {
    pub fn switch_ivr_dmachine_is_parsing(dmachine: *mut switch_ivr_dmachine_t) -> switch_bool_t;
}
extern "C" {
    pub fn switch_ivr_dmachine_last_ping(dmachine: *mut switch_ivr_dmachine_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_dmachine_get_name(
        dmachine: *mut switch_ivr_dmachine_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_ivr_dmachine_set_match_callback(
        dmachine: *mut switch_ivr_dmachine_t,
        match_callback: switch_ivr_dmachine_callback_t,
    );
}
extern "C" {
    pub fn switch_ivr_dmachine_set_nonmatch_callback(
        dmachine: *mut switch_ivr_dmachine_t,
        nonmatch_callback: switch_ivr_dmachine_callback_t,
    );
}
extern "C" {
    pub fn switch_ivr_dmachine_create(
        dmachine_p: *mut *mut switch_ivr_dmachine_t,
        name: *const ::std::os::raw::c_char,
        pool: *mut switch_memory_pool_t,
        digit_timeout: u32,
        input_timeout: u32,
        match_callback: switch_ivr_dmachine_callback_t,
        nonmatch_callback: switch_ivr_dmachine_callback_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_dmachine_destroy(dmachine: *mut *mut switch_ivr_dmachine_t);
}
extern "C" {
    pub fn switch_ivr_dmachine_bind(
        dmachine: *mut switch_ivr_dmachine_t,
        realm: *const ::std::os::raw::c_char,
        digits: *const ::std::os::raw::c_char,
        is_priority: switch_byte_t,
        key: i32,
        callback: switch_ivr_dmachine_callback_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_dmachine_feed(
        dmachine: *mut switch_ivr_dmachine_t,
        digits: *const ::std::os::raw::c_char,
        match_: *mut *mut switch_ivr_dmachine_match_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_dmachine_clear(dmachine: *mut switch_ivr_dmachine_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_dmachine_ping(
        dmachine: *mut switch_ivr_dmachine_t,
        match_p: *mut *mut switch_ivr_dmachine_match_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_dmachine_get_match(
        dmachine: *mut switch_ivr_dmachine_t,
    ) -> *mut switch_ivr_dmachine_match_t;
}
extern "C" {
    pub fn switch_ivr_dmachine_get_failed_digits(
        dmachine: *mut switch_ivr_dmachine_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_ivr_dmachine_set_digit_timeout_ms(
        dmachine: *mut switch_ivr_dmachine_t,
        digit_timeout_ms: u32,
    );
}
extern "C" {
    pub fn switch_ivr_dmachine_set_input_timeout_ms(
        dmachine: *mut switch_ivr_dmachine_t,
        input_timeout_ms: u32,
    );
}
extern "C" {
    pub fn switch_ivr_dmachine_clear_realm(
        dmachine: *mut switch_ivr_dmachine_t,
        realm: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_dmachine_set_realm(
        dmachine: *mut switch_ivr_dmachine_t,
        realm: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_get_file_handle(
        session: *mut switch_core_session_t,
        fh: *mut *mut switch_file_handle_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_release_file_handle(
        session: *mut switch_core_session_t,
        fh: *mut *mut switch_file_handle_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_process_fh(
        session: *mut switch_core_session_t,
        cmd: *const ::std::os::raw::c_char,
        fhp: *mut switch_file_handle_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_insert_file(
        session: *mut switch_core_session_t,
        file: *const ::std::os::raw::c_char,
        insert_file: *const ::std::os::raw::c_char,
        sample_point: switch_size_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_create_message_reply(
        reply: *mut *mut switch_event_t,
        message: *mut switch_event_t,
        new_proto: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_check_presence_mapping(
        exten_name: *const ::std::os::raw::c_char,
        domain_name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_ivr_kill_uuid(
        uuid: *const ::std::os::raw::c_char,
        cause: switch_call_cause_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_blind_transfer_ack(
        session: *mut switch_core_session_t,
        success: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_record_session_mask(
        session: *mut switch_core_session_t,
        file: *const ::std::os::raw::c_char,
        on: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_record_session_pause(
        session: *mut switch_core_session_t,
        file: *const ::std::os::raw::c_char,
        on: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_stop_video_write_overlay_session(
        session: *mut switch_core_session_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_video_write_overlay_session(
        session: *mut switch_core_session_t,
        img_path: *const ::std::os::raw::c_char,
        pos: switch_img_position_t,
        alpha: u8,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_capture_text(
        session: *mut switch_core_session_t,
        on: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_dial_handle_create(handle: *mut *mut switch_dial_handle_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_dial_handle_create_json_obj(
        handle: *mut *mut switch_dial_handle_t,
        json: *mut cJSON,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_dial_handle_create_json(
        handle: *mut *mut switch_dial_handle_t,
        handle_string: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_dial_handle_destroy(handle: *mut *mut switch_dial_handle_t);
}
extern "C" {
    pub fn switch_dial_handle_serialize_json_obj(
        handle: *mut switch_dial_handle_t,
        json: *mut *mut cJSON,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_dial_handle_serialize_json(
        handle: *mut switch_dial_handle_t,
        str_: *mut *mut ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_dial_handle_add_leg_list(
        handle: *mut switch_dial_handle_t,
        leg_listP: *mut *mut switch_dial_leg_list_t,
    );
}
extern "C" {
    pub fn switch_dial_leg_list_add_leg(
        parent: *mut switch_dial_leg_list_t,
        legP: *mut *mut switch_dial_leg_t,
        dial_string: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn switch_dial_leg_list_add_leg_printf(
        parent: *mut switch_dial_leg_list_t,
        legP: *mut *mut switch_dial_leg_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn switch_dial_handle_add_global_var(
        handle: *mut switch_dial_handle_t,
        var: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn switch_dial_handle_add_global_var_printf(
        handle: *mut switch_dial_handle_t,
        var: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn switch_dial_handle_add_leg_var(
        leg: *mut switch_dial_leg_t,
        var: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_dial_handle_add_leg_var_printf(
        leg: *mut switch_dial_leg_t,
        var: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_dial_handle_get_peers(
        handle: *mut switch_dial_handle_t,
        idx: ::std::os::raw::c_int,
        array: *mut *mut ::std::os::raw::c_char,
        max: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_dial_handle_get_vars(
        handle: *mut switch_dial_handle_t,
        idx: ::std::os::raw::c_int,
        array: *mut *mut switch_event_t,
        max: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_dial_handle_get_global_vars(
        handle: *mut switch_dial_handle_t,
    ) -> *mut switch_event_t;
}
extern "C" {
    pub fn switch_dial_leg_get_vars(leg: *mut switch_dial_leg_t) -> *mut switch_event_t;
}
extern "C" {
    pub fn switch_dial_leg_get_var(
        leg: *mut switch_dial_leg_t,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_dial_handle_get_total(handle: *mut switch_dial_handle_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_dial_handle_list_serialize_json_obj(
        hl: *mut switch_dial_handle_list_t,
        json: *mut *mut cJSON,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_dial_handle_list_serialize_json(
        hl: *mut switch_dial_handle_list_t,
        str_: *mut *mut ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_dial_handle_list_create_json_obj(
        handle: *mut *mut switch_dial_handle_list_t,
        json: *mut cJSON,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_dial_handle_list_create_json(
        handle: *mut *mut switch_dial_handle_list_t,
        handle_string: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_dial_handle_list_create(
        hl: *mut *mut switch_dial_handle_list_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_dial_handle_list_create_handle(
        hl: *mut switch_dial_handle_list_t,
        handle: *mut *mut switch_dial_handle_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_dial_handle_list_destroy(hl: *mut *mut switch_dial_handle_list_t);
}
extern "C" {
    pub fn switch_dial_handle_list_add_global_var(
        hl: *mut switch_dial_handle_list_t,
        var: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn switch_dial_handle_list_add_global_var_printf(
        hl: *mut switch_dial_handle_list_t,
        var: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn switch_ivr_enterprise_orig_and_bridge(
        session: *mut switch_core_session_t,
        data: *const ::std::os::raw::c_char,
        hl: *mut switch_dial_handle_list_t,
        cause: *mut switch_call_cause_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_orig_and_bridge(
        session: *mut switch_core_session_t,
        data: *const ::std::os::raw::c_char,
        dh: *mut switch_dial_handle_t,
        cause: *mut switch_call_cause_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_send_prompt(
        session: *mut switch_core_session_t,
        type_: *const ::std::os::raw::c_char,
        text: *const ::std::os::raw::c_char,
        regex: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_ivr_play_and_collect_input(
        session: *mut switch_core_session_t,
        prompt: *const ::std::os::raw::c_char,
        recognizer_mod_name: *const ::std::os::raw::c_char,
        recognizer_grammar: *const ::std::os::raw::c_char,
        min_digits: ::std::os::raw::c_int,
        max_digits: ::std::os::raw::c_int,
        terminators: *const ::std::os::raw::c_char,
        digit_timeout: u32,
        recognition_result: *mut *mut cJSON,
        digits_collected: *mut *mut ::std::os::raw::c_char,
        terminator_collected: *mut ::std::os::raw::c_char,
        args: *mut switch_input_args_t,
    ) -> switch_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_rtp_packet_t {
    pub header: switch_rtp_hdr_t,
    pub body: [::std::os::raw::c_char; 16396usize],
    pub ext: *mut switch_rtp_hdr_ext_t,
    pub ebody: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_switch_rtp_packet_t() {
    const UNINIT: ::std::mem::MaybeUninit<switch_rtp_packet_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_rtp_packet_t>(),
        16424usize,
        concat!("Size of: ", stringify!(switch_rtp_packet_t))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_rtp_packet_t>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_rtp_packet_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_packet_t),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_packet_t),
            "::",
            stringify!(body)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ext) as usize - ptr as usize },
        16408usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_packet_t),
            "::",
            stringify!(ext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ebody) as usize - ptr as usize },
        16416usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_packet_t),
            "::",
            stringify!(ebody)
        )
    );
}
pub const switch_rtp_crypto_direction_t_SWITCH_RTP_CRYPTO_SEND: switch_rtp_crypto_direction_t = 0;
pub const switch_rtp_crypto_direction_t_SWITCH_RTP_CRYPTO_RECV: switch_rtp_crypto_direction_t = 1;
pub const switch_rtp_crypto_direction_t_SWITCH_RTP_CRYPTO_SEND_RTCP: switch_rtp_crypto_direction_t =
    2;
pub const switch_rtp_crypto_direction_t_SWITCH_RTP_CRYPTO_RECV_RTCP: switch_rtp_crypto_direction_t =
    3;
pub const switch_rtp_crypto_direction_t_SWITCH_RTP_CRYPTO_MAX: switch_rtp_crypto_direction_t = 4;
pub type switch_rtp_crypto_direction_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_srtp_crypto_suite_s {
    pub name: *mut ::std::os::raw::c_char,
    pub alias: *const ::std::os::raw::c_char,
    pub type_: switch_rtp_crypto_key_type_t,
    pub keysalt_len: ::std::os::raw::c_int,
    pub salt_len: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_switch_srtp_crypto_suite_s() {
    const UNINIT: ::std::mem::MaybeUninit<switch_srtp_crypto_suite_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_srtp_crypto_suite_s>(),
        32usize,
        concat!("Size of: ", stringify!(switch_srtp_crypto_suite_s))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_srtp_crypto_suite_s>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_srtp_crypto_suite_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_srtp_crypto_suite_s),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alias) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_srtp_crypto_suite_s),
            "::",
            stringify!(alias)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_srtp_crypto_suite_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keysalt_len) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_srtp_crypto_suite_s),
            "::",
            stringify!(keysalt_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).salt_len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_srtp_crypto_suite_s),
            "::",
            stringify!(salt_len)
        )
    );
}
pub type switch_srtp_crypto_suite_t = switch_srtp_crypto_suite_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_rtp_crypto_key {
    pub index: u32,
    pub type_: switch_rtp_crypto_key_type_t,
    pub keysalt: [::std::os::raw::c_uchar; 64usize],
    pub keylen: switch_size_t,
    pub next: *mut switch_rtp_crypto_key,
}
#[test]
fn bindgen_test_layout_switch_rtp_crypto_key() {
    const UNINIT: ::std::mem::MaybeUninit<switch_rtp_crypto_key> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_rtp_crypto_key>(),
        88usize,
        concat!("Size of: ", stringify!(switch_rtp_crypto_key))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_rtp_crypto_key>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_rtp_crypto_key))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_crypto_key),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_crypto_key),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keysalt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_crypto_key),
            "::",
            stringify!(keysalt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keylen) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_crypto_key),
            "::",
            stringify!(keylen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_rtp_crypto_key),
            "::",
            stringify!(next)
        )
    );
}
pub type switch_rtp_crypto_key_t = switch_rtp_crypto_key;
pub const ice_proto_t_IPR_RTP: ice_proto_t = 0;
pub const ice_proto_t_IPR_RTCP: ice_proto_t = 1;
pub type ice_proto_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icand_s {
    pub foundation: *mut ::std::os::raw::c_char,
    pub component_id: ::std::os::raw::c_int,
    pub transport: *mut ::std::os::raw::c_char,
    pub priority: u32,
    pub con_addr: *mut ::std::os::raw::c_char,
    pub con_port: switch_port_t,
    pub cand_type: *mut ::std::os::raw::c_char,
    pub raddr: *mut ::std::os::raw::c_char,
    pub rport: switch_port_t,
    pub generation: *mut ::std::os::raw::c_char,
    pub ready: u8,
}
#[test]
fn bindgen_test_layout_icand_s() {
    const UNINIT: ::std::mem::MaybeUninit<icand_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<icand_s>(),
        88usize,
        concat!("Size of: ", stringify!(icand_s))
    );
    assert_eq!(
        ::std::mem::align_of::<icand_s>(),
        8usize,
        concat!("Alignment of ", stringify!(icand_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).foundation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(icand_s),
            "::",
            stringify!(foundation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).component_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(icand_s),
            "::",
            stringify!(component_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transport) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(icand_s),
            "::",
            stringify!(transport)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(icand_s),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).con_addr) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(icand_s),
            "::",
            stringify!(con_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).con_port) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(icand_s),
            "::",
            stringify!(con_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cand_type) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(icand_s),
            "::",
            stringify!(cand_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raddr) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(icand_s),
            "::",
            stringify!(raddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rport) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(icand_s),
            "::",
            stringify!(rport)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).generation) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(icand_s),
            "::",
            stringify!(generation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ready) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(icand_s),
            "::",
            stringify!(ready)
        )
    );
}
pub type icand_t = icand_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ice_s {
    pub cands: [[icand_t; 2usize]; 50usize],
    pub cand_idx: [::std::os::raw::c_int; 2usize],
    pub chosen: [::std::os::raw::c_int; 2usize],
    pub is_chosen: [::std::os::raw::c_int; 2usize],
    pub ufrag: *mut ::std::os::raw::c_char,
    pub pwd: *mut ::std::os::raw::c_char,
    pub options: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ice_s() {
    const UNINIT: ::std::mem::MaybeUninit<ice_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ice_s>(),
        8848usize,
        concat!("Size of: ", stringify!(ice_s))
    );
    assert_eq!(
        ::std::mem::align_of::<ice_s>(),
        8usize,
        concat!("Alignment of ", stringify!(ice_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cands) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ice_s),
            "::",
            stringify!(cands)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cand_idx) as usize - ptr as usize },
        8800usize,
        concat!(
            "Offset of field: ",
            stringify!(ice_s),
            "::",
            stringify!(cand_idx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chosen) as usize - ptr as usize },
        8808usize,
        concat!(
            "Offset of field: ",
            stringify!(ice_s),
            "::",
            stringify!(chosen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_chosen) as usize - ptr as usize },
        8816usize,
        concat!(
            "Offset of field: ",
            stringify!(ice_s),
            "::",
            stringify!(is_chosen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ufrag) as usize - ptr as usize },
        8824usize,
        concat!(
            "Offset of field: ",
            stringify!(ice_s),
            "::",
            stringify!(ufrag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pwd) as usize - ptr as usize },
        8832usize,
        concat!(
            "Offset of field: ",
            stringify!(ice_s),
            "::",
            stringify!(pwd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).options) as usize - ptr as usize },
        8840usize,
        concat!(
            "Offset of field: ",
            stringify!(ice_s),
            "::",
            stringify!(options)
        )
    );
}
pub type ice_t = ice_s;
pub const rtcp_pt_t__RTCP_PT_FIR: rtcp_pt_t = 192;
pub const rtcp_pt_t__RTCP_PT_IJ: rtcp_pt_t = 195;
pub const rtcp_pt_t__RTCP_PT_SR: rtcp_pt_t = 200;
pub const rtcp_pt_t__RTCP_PT_RR: rtcp_pt_t = 201;
pub const rtcp_pt_t__RTCP_PT_SDES: rtcp_pt_t = 202;
pub const rtcp_pt_t__RTCP_PT_BYE: rtcp_pt_t = 203;
pub const rtcp_pt_t__RTCP_PT_APP: rtcp_pt_t = 204;
pub const rtcp_pt_t__RTCP_PT_RTPFB: rtcp_pt_t = 205;
pub const rtcp_pt_t__RTCP_PT_PSFB: rtcp_pt_t = 206;
pub const rtcp_pt_t__RTCP_PT_XR: rtcp_pt_t = 207;
pub const rtcp_pt_t__RTCP_PT_AVB: rtcp_pt_t = 208;
pub const rtcp_pt_t__RTCP_PT_RSI: rtcp_pt_t = 209;
pub const rtcp_pt_t__RTCP_PT_TOKEN: rtcp_pt_t = 210;
pub const rtcp_pt_t__RTCP_PT_IDMS: rtcp_pt_t = 211;
pub const rtcp_pt_t__RTCP_PT_LAST: rtcp_pt_t = 255;
pub type rtcp_pt_t = ::std::os::raw::c_uint;
pub const rtcp_sdes_t__RTCP_SDES_END: rtcp_sdes_t = 0;
pub const rtcp_sdes_t__RTCP_SDES_CNAME: rtcp_sdes_t = 1;
pub const rtcp_sdes_t__RTCP_SDES_NAME: rtcp_sdes_t = 2;
pub const rtcp_sdes_t__RTCP_SDES_EMAIL: rtcp_sdes_t = 3;
pub const rtcp_sdes_t__RTCP_SDES_PHONE: rtcp_sdes_t = 4;
pub const rtcp_sdes_t__RTCP_SDES_LOC: rtcp_sdes_t = 5;
pub const rtcp_sdes_t__RTCP_SDES_TOOL: rtcp_sdes_t = 6;
pub const rtcp_sdes_t__RTCP_SDES_NOTE: rtcp_sdes_t = 7;
pub const rtcp_sdes_t__RTCP_SDES_PRIV: rtcp_sdes_t = 8;
pub const rtcp_sdes_t__RTCP_SDES_H323: rtcp_sdes_t = 9;
pub const rtcp_sdes_t__RTCP_SDES_APSI: rtcp_sdes_t = 10;
pub type rtcp_sdes_t = ::std::os::raw::c_uint;
pub const rtcp_rtpfb_t__RTCP_RTPFB_NACK: rtcp_rtpfb_t = 1;
pub const rtcp_rtpfb_t__RTCP_RTPFB_TMMBR: rtcp_rtpfb_t = 3;
pub const rtcp_rtpfb_t__RTCP_RTPFB_TMMBN: rtcp_rtpfb_t = 4;
pub const rtcp_rtpfb_t__RTCP_RTPFB_SR_REQ: rtcp_rtpfb_t = 5;
pub const rtcp_rtpfb_t__RTCP_RTPFB_RAMS: rtcp_rtpfb_t = 6;
pub const rtcp_rtpfb_t__RTCP_RTPFB_TLLEI: rtcp_rtpfb_t = 7;
pub const rtcp_rtpfb_t__RTCP_RTPFB_ECN_FB: rtcp_rtpfb_t = 8;
pub type rtcp_rtpfb_t = ::std::os::raw::c_uint;
pub const rtcp_psfb_t__RTCP_PSFB_PLI: rtcp_psfb_t = 1;
pub const rtcp_psfb_t__RTCP_PSFB_SLI: rtcp_psfb_t = 2;
pub const rtcp_psfb_t__RTCP_PSFB_RPSI: rtcp_psfb_t = 3;
pub const rtcp_psfb_t__RTCP_PSFB_FIR: rtcp_psfb_t = 4;
pub const rtcp_psfb_t__RTCP_PSFB_TSTR: rtcp_psfb_t = 5;
pub const rtcp_psfb_t__RTCP_PSFB_TSTN: rtcp_psfb_t = 6;
pub const rtcp_psfb_t__RTCP_PSFB_VBCM: rtcp_psfb_t = 7;
pub const rtcp_psfb_t__RTCP_PSFB_PSLEI: rtcp_psfb_t = 8;
pub const rtcp_psfb_t__RTCP_PSFB_AFB: rtcp_psfb_t = 15;
pub type rtcp_psfb_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn switch_rtp_add_crypto_key(
        rtp_session: *mut switch_rtp_t,
        direction: switch_rtp_crypto_direction_t,
        index: u32,
        ssec: *mut switch_secure_settings_t,
    ) -> switch_status_t;
}
#[doc = "\\defgroup rtp RTP (RealTime Transport Protocol)\n\\ingroup core1\n\\{"]
pub type switch_rtp_invalid_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        rtp_session: *mut switch_rtp_t,
        sock: *mut switch_socket_t,
        data: *mut ::std::os::raw::c_void,
        datalen: switch_size_t,
        from_addr: *mut switch_sockaddr_t,
    ),
>;
extern "C" {
    pub fn switch_rtp_get_random(buf: *mut ::std::os::raw::c_void, len: u32);
}
extern "C" {
    #[doc = "\\brief Initilize the RTP System\n\\param pool the memory pool to use for long term allocations\n\\note Generally called by the core_init"]
    pub fn switch_rtp_init(pool: *mut switch_memory_pool_t);
}
extern "C" {
    pub fn switch_rtp_shutdown();
}
extern "C" {
    #[doc = "\\brief Set/Get RTP start port\n\\param port new value (if > 0)\n\\return the current RTP start port"]
    pub fn switch_rtp_set_start_port(port: switch_port_t) -> switch_port_t;
}
extern "C" {
    pub fn switch_rtp_set_ssrc(rtp_session: *mut switch_rtp_t, ssrc: u32) -> switch_status_t;
}
extern "C" {
    pub fn switch_rtp_set_remote_ssrc(rtp_session: *mut switch_rtp_t, ssrc: u32)
        -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Set/Get RTP end port\n\\param port new value (if > 0)\n\\return the current RTP end port"]
    pub fn switch_rtp_set_end_port(port: switch_port_t) -> switch_port_t;
}
extern "C" {
    #[doc = "\\brief Request a new port to be used for media\n\\param ip the ip to request a port from\n\\return the new port to use"]
    pub fn switch_rtp_request_port(ip: *const ::std::os::raw::c_char) -> switch_port_t;
}
extern "C" {
    pub fn switch_rtp_release_port(ip: *const ::std::os::raw::c_char, port: switch_port_t);
}
extern "C" {
    pub fn switch_rtp_set_interval(
        rtp_session: *mut switch_rtp_t,
        ms_per_packet: u32,
        samples_per_interval: u32,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_rtp_change_interval(
        rtp_session: *mut switch_rtp_t,
        ms_per_packet: u32,
        samples_per_interval: u32,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief create a new RTP session handle\n\\param new_rtp_session a poiter to aim at the new session\n\\param payload the IANA payload number\n\\param samples_per_interval the default samples_per_interval\n\\param ms_per_packet time in microseconds per packet\n\\param flags flags to control behaviour\n\\param timer_name timer interface to use\n\\param err a pointer to resolve error messages\n\\param pool a memory pool to use for the session\n\\return the new RTP session or NULL on failure"]
    pub fn switch_rtp_create(
        new_rtp_session: *mut *mut switch_rtp_t,
        payload: switch_payload_t,
        samples_per_interval: u32,
        ms_per_packet: u32,
        flags: *mut switch_rtp_flag_t,
        timer_name: *mut ::std::os::raw::c_char,
        err: *mut *const ::std::os::raw::c_char,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief prepare a new RTP session handle and fully initilize it\n\\param rx_host the local address\n\\param rx_port the local port\n\\param tx_host the remote address\n\\param tx_port the remote port\n\\param payload the IANA payload number\n\\param samples_per_interval the default samples_per_interval\n\\param ms_per_packet time in microseconds per packet\n\\param flags flags to control behaviour\n\\param timer_name timer interface to use\n\\param err a pointer to resolve error messages\n\\param pool a memory pool to use for the session\n\\param bundle_port port used by bundled stream locally, for video thread this is the port where it will forward audio (internal bundle port on which audio is listening), and for audio this is the port where it will send RTP (external bundle port where video is listening)\n\\return the new RTP session or NULL on failure"]
    pub fn switch_rtp_new(
        rx_host: *const ::std::os::raw::c_char,
        rx_port: switch_port_t,
        tx_host: *const ::std::os::raw::c_char,
        tx_port: switch_port_t,
        payload: switch_payload_t,
        samples_per_interval: u32,
        ms_per_packet: u32,
        flags: *mut switch_rtp_flag_t,
        timer_name: *mut ::std::os::raw::c_char,
        err: *mut *const ::std::os::raw::c_char,
        pool: *mut switch_memory_pool_t,
        bundle_internal_ports: switch_port_t,
        bundle_external_port: switch_port_t,
    ) -> *mut switch_rtp_t;
}
extern "C" {
    #[doc = "\\brief Assign a remote address to the RTP session\n\\param rtp_session an RTP session to assign the remote address to\n\\param host the ip or fqhn of the remote address\n\\param port the remote port\n\\param err pointer for error messages"]
    pub fn switch_rtp_set_remote_address(
        rtp_session: *mut switch_rtp_t,
        host: *const ::std::os::raw::c_char,
        port: switch_port_t,
        remote_rtcp_port: switch_port_t,
        change_adv_addr: switch_bool_t,
        err: *mut *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_rtp_reset_jb(rtp_session: *mut switch_rtp_t);
}
extern "C" {
    pub fn switch_rtp_get_remote_host(
        rtp_session: *mut switch_rtp_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_rtp_get_remote_port(rtp_session: *mut switch_rtp_t) -> switch_port_t;
}
extern "C" {
    pub fn switch_rtp_reset_media_timer(rtp_session: *mut switch_rtp_t);
}
extern "C" {
    pub fn switch_rtp_set_max_missed_packets(rtp_session: *mut switch_rtp_t, max: u32);
}
extern "C" {
    pub fn switch_rtp_set_media_timeout(rtp_session: *mut switch_rtp_t, ms: u32);
}
extern "C" {
    pub fn switch_rtp_udptl_mode(rtp_session: *mut switch_rtp_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_rtp_reset(rtp_session: *mut switch_rtp_t);
}
extern "C" {
    #[doc = "\\brief Assign a local address to the RTP session\n\\param rtp_session an RTP session to assign the local address to\n\\param host the ip or fqhn of the local address\n\\param port the local port\n\\param change_adv_addr change the advertised address for doing compare\n\\param err pointer for error messages\n\\note this call also binds the RTP session's socket to the new address"]
    pub fn switch_rtp_set_local_address(
        rtp_session: *mut switch_rtp_t,
        host: *const ::std::os::raw::c_char,
        port: switch_port_t,
        err: *mut *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Kill the socket on an existing RTP session\n\\param rtp_session an RTP session to kill the socket of"]
    pub fn switch_rtp_kill_socket(rtp_session: *mut switch_rtp_t);
}
extern "C" {
    pub fn switch_rtp_break(rtp_session: *mut switch_rtp_t);
}
extern "C" {
    pub fn switch_rtp_flush(rtp_session: *mut switch_rtp_t);
}
extern "C" {
    #[doc = "\\brief Test if an RTP session is ready\n\\param rtp_session an RTP session to test\n\\return a true value if it's ready"]
    pub fn switch_rtp_ready(rtp_session: *mut switch_rtp_t) -> u8;
}
extern "C" {
    #[doc = "\\brief Destroy an RTP session\n\\param rtp_session an RTP session to destroy"]
    pub fn switch_rtp_destroy(rtp_session: *mut *mut switch_rtp_t);
}
extern "C" {
    pub fn switch_rtp_sync_stats(rtp_session: *mut switch_rtp_t) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Acvite ICE on an RTP session\n\\return SWITCH_STATUS_SUCCESS"]
    pub fn switch_rtp_activate_ice(
        rtp_session: *mut switch_rtp_t,
        login: *mut ::std::os::raw::c_char,
        rlogin: *mut ::std::os::raw::c_char,
        password: *const ::std::os::raw::c_char,
        rpassword: *const ::std::os::raw::c_char,
        proto: ice_proto_t,
        type_: switch_core_media_ice_type_t,
        ice_params: *mut ice_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Activate sending RTCP Sender Reports (SR's)\n\\param send_rate interval in milliseconds to send at\n\\return SWITCH_STATUS_SUCCESS"]
    pub fn switch_rtp_activate_rtcp(
        rtp_session: *mut switch_rtp_t,
        send_rate: ::std::os::raw::c_int,
        remote_port: switch_port_t,
        mux: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_rtp_get_media_timer(rtp_session: *mut switch_rtp_t) -> *mut switch_timer_t;
}
extern "C" {
    pub fn switch_rtp_set_video_buffer_size(
        rtp_session: *mut switch_rtp_t,
        frames: u32,
        max_frames: u32,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_rtp_get_video_buffer_size(
        rtp_session: *mut switch_rtp_t,
        min_frame_len: *mut u32,
        max_frame_len: *mut u32,
        cur_frame_len: *mut u32,
        highest_frame_len: *mut u32,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Acvite a jitter buffer on an RTP session\n\\param rtp_session the rtp session\n\\param queue_frames the number of frames to delay\n\\return SWITCH_STATUS_SUCCESS"]
    pub fn switch_rtp_activate_jitter_buffer(
        rtp_session: *mut switch_rtp_t,
        queue_frames: u32,
        max_queue_frames: u32,
        samples_per_packet: u32,
        samples_per_second: u32,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_rtp_debug_jitter_buffer(
        rtp_session: *mut switch_rtp_t,
        name: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_rtp_deactivate_jitter_buffer(rtp_session: *mut switch_rtp_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_rtp_pause_jitter_buffer(
        rtp_session: *mut switch_rtp_t,
        pause: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_rtp_get_jitter_buffer(rtp_session: *mut switch_rtp_t) -> *mut switch_jb_t;
}
extern "C" {
    #[doc = "\\brief Set an RTP Flag\n\\param rtp_session the RTP session\n\\param flags the flags to set"]
    pub fn switch_rtp_set_flag(rtp_session: *mut switch_rtp_t, flag: switch_rtp_flag_t);
}
extern "C" {
    pub fn switch_rtp_set_flags(rtp_session: *mut switch_rtp_t, flags: *mut switch_rtp_flag_t);
}
extern "C" {
    pub fn switch_rtp_clear_flags(rtp_session: *mut switch_rtp_t, flags: *mut switch_rtp_flag_t);
}
extern "C" {
    #[doc = "\\brief Test an RTP Flag\n\\param rtp_session the RTP session\n\\param flags the flags to test\n\\return TRUE or FALSE"]
    pub fn switch_rtp_test_flag(rtp_session: *mut switch_rtp_t, flags: switch_rtp_flag_t) -> u32;
}
extern "C" {
    #[doc = "\\brief Clear an RTP Flag\n\\param rtp_session the RTP session\n\\param flags the flags to clear"]
    pub fn switch_rtp_clear_flag(rtp_session: *mut switch_rtp_t, flag: switch_rtp_flag_t);
}
extern "C" {
    #[doc = "\\brief Retrieve the socket from an existing RTP session\n\\param rtp_session the RTP session to retrieve the socket from\n\\return the socket from the RTP session"]
    pub fn switch_rtp_get_rtp_socket(rtp_session: *mut switch_rtp_t) -> *mut switch_socket_t;
}
extern "C" {
    pub fn switch_rtp_ping(rtp_session: *mut switch_rtp_t);
}
extern "C" {
    #[doc = "\\brief Get the default samples per interval for a given RTP session\n\\param rtp_session the RTP session to get the samples per interval from\n\\return the default samples per interval of the RTP session"]
    pub fn switch_rtp_get_default_samples_per_interval(rtp_session: *mut switch_rtp_t) -> u32;
}
extern "C" {
    #[doc = "\\brief Set the default payload number for a given RTP session\n\\param rtp_session the RTP session to set the payload number on\n\\param payload the new default payload number"]
    pub fn switch_rtp_set_default_payload(
        rtp_session: *mut switch_rtp_t,
        payload: switch_payload_t,
    );
}
extern "C" {
    #[doc = "\\brief Get the default payload number for a given RTP session\n\\param rtp_session the RTP session to get the payload number from\n\\return the default payload of the RTP session"]
    pub fn switch_rtp_get_default_payload(rtp_session: *mut switch_rtp_t) -> u32;
}
extern "C" {
    #[doc = "\\brief Set a callback function to execute when an invalid RTP packet is encountered\n\\param rtp_session the RTP session\n\\param on_invalid the function to set\n\\return"]
    pub fn switch_rtp_set_invalid_handler(
        rtp_session: *mut switch_rtp_t,
        on_invalid: switch_rtp_invalid_handler_t,
    );
}
extern "C" {
    #[doc = "\\brief Read data from a given RTP session\n\\param rtp_session the RTP session to read from\n\\param data the data to read\n\\param datalen a pointer to the datalen\n\\param payload_type the IANA payload of the packet\n\\param flags flags\n\\param io_flags i/o flags\n\\return the number of bytes read"]
    pub fn switch_rtp_read(
        rtp_session: *mut switch_rtp_t,
        data: *mut ::std::os::raw::c_void,
        datalen: *mut u32,
        payload_type: *mut switch_payload_t,
        flags: *mut switch_frame_flag_t,
        io_flags: switch_io_flag_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Queue RFC2833 DTMF data into an RTP Session\n\\param rtp_session the rtp session to use\n\\param dtmf the dtmf digits to queue\n\\return SWITCH_STATUS_SUCCESS on success"]
    pub fn switch_rtp_queue_rfc2833(
        rtp_session: *mut switch_rtp_t,
        dtmf: *const switch_dtmf_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Queue RFC2833 DTMF data into an RTP Session\n\\param rtp_session the rtp session to use\n\\param dtmf the dtmf digits to queue\n\\return SWITCH_STATUS_SUCCESS on success"]
    pub fn switch_rtp_queue_rfc2833_in(
        rtp_session: *mut switch_rtp_t,
        dtmf: *const switch_dtmf_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Test for presence of DTMF on a given RTP session\n\\param rtp_session session to test\n\\return number of digits in the queue"]
    pub fn switch_rtp_has_dtmf(rtp_session: *mut switch_rtp_t) -> switch_size_t;
}
extern "C" {
    #[doc = "\\brief Retrieve DTMF digits from a given RTP session\n\\param rtp_session RTP session to retrieve digits from\n\\param dtmf the dtmf\n\\return number of bytes read into the buffer"]
    pub fn switch_rtp_dequeue_dtmf(
        rtp_session: *mut switch_rtp_t,
        dtmf: *mut switch_dtmf_t,
    ) -> switch_size_t;
}
extern "C" {
    #[doc = "\\brief Read data from a given RTP session without copying\n\\param rtp_session the RTP session to read from\n\\param data a pointer to point directly to the RTP read buffer\n\\param datalen a pointer to the datalen\n\\param payload_type the IANA payload of the packet\n\\param flags flags\n\\param io_flags i/o flags\n\\return the number of bytes read"]
    pub fn switch_rtp_zerocopy_read(
        rtp_session: *mut switch_rtp_t,
        data: *mut *mut ::std::os::raw::c_void,
        datalen: *mut u32,
        payload_type: *mut switch_payload_t,
        flags: *mut switch_frame_flag_t,
        io_flags: switch_io_flag_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Read data from a given RTP session without copying\n\\param rtp_session the RTP session to read from\n\\param frame a frame to populate with information\n\\param io_flags i/o flags\n\\return the number of bytes read"]
    pub fn switch_rtp_zerocopy_read_frame(
        rtp_session: *mut switch_rtp_t,
        frame: *mut switch_frame_t,
        io_flags: switch_io_flag_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Read RTCP data from a given RTP session without copying\n\\param rtp_session the RTP session to read from\n\\param frame an RTCP frame to populate with information\n\\return the number of bytes read"]
    pub fn switch_rtcp_zerocopy_read_frame(
        rtp_session: *mut switch_rtp_t,
        frame: *mut switch_rtcp_frame_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn rtp_flush_read_buffer(rtp_session: *mut switch_rtp_t, flush: switch_rtp_flush_t);
}
extern "C" {
    #[doc = "\\brief Enable VAD on an RTP Session\n\\param rtp_session the RTP session\n\\param session the core session associated with the RTP session\n\\param codec the codec the channel is currenty using\n\\param flags flags for control\n\\return SWITCH_STAUTS_SUCCESS on success"]
    pub fn switch_rtp_enable_vad(
        rtp_session: *mut switch_rtp_t,
        session: *mut switch_core_session_t,
        codec: *mut switch_codec_t,
        flags: switch_vad_flag_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Disable VAD on an RTP Session\n\\param rtp_session the RTP session\n\\return SWITCH_STAUTS_SUCCESS on success"]
    pub fn switch_rtp_disable_vad(rtp_session: *mut switch_rtp_t) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Write data to a given RTP session\n\\param rtp_session the RTP session to write to\n\\param frame the frame to write\n\\return the number of bytes written"]
    pub fn switch_rtp_write_frame(
        rtp_session: *mut switch_rtp_t,
        frame: *mut switch_frame_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Write data with a specified payload and sequence number to a given RTP session\n\\param rtp_session the RTP session to write to\n\\param data data to write\n\\param datalen the size of the data\n\\param m set mark bit or not\n\\param payload the IANA payload number\n\\param ts then number of bytes to increment the timestamp by\n\\param flags frame flags\n\\return the number of bytes written"]
    pub fn switch_rtp_write_manual(
        rtp_session: *mut switch_rtp_t,
        data: *mut ::std::os::raw::c_void,
        datalen: u32,
        m: u8,
        payload: switch_payload_t,
        ts: u32,
        flags: *mut switch_frame_flag_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_rtp_write_raw(
        rtp_session: *mut switch_rtp_t,
        data: *mut ::std::os::raw::c_void,
        bytes: *mut switch_size_t,
        process_encryption: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Retrieve the SSRC from a given RTP session\n\\param rtp_session the RTP session to retrieve from\n\\return the SSRC"]
    pub fn switch_rtp_get_ssrc(rtp_session: *mut switch_rtp_t) -> u32;
}
extern "C" {
    #[doc = "\\brief Associate an arbitrary data pointer with and RTP session\n\\param rtp_session the RTP session to assign the pointer to\n\\param private_data the private data to assign"]
    pub fn switch_rtp_set_private(
        rtp_session: *mut switch_rtp_t,
        private_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "\\brief Set the payload type to consider RFC2833 DTMF\n\\param rtp_session the RTP session to modify\n\\param te the payload type"]
    pub fn switch_rtp_set_telephony_event(rtp_session: *mut switch_rtp_t, te: switch_payload_t);
}
extern "C" {
    pub fn switch_rtp_set_telephony_recv_event(
        rtp_session: *mut switch_rtp_t,
        te: switch_payload_t,
    );
}
extern "C" {
    #[doc = "\\brief Set the payload type for comfort noise\n\\param rtp_session the RTP session to modify\n\\param pt the payload type"]
    pub fn switch_rtp_set_cng_pt(rtp_session: *mut switch_rtp_t, pt: switch_payload_t);
}
extern "C" {
    #[doc = "\\brief Retrieve the private data from a given RTP session\n\\param rtp_session the RTP session to retrieve the data from\n\\return the pointer to the private data"]
    pub fn switch_rtp_get_private(rtp_session: *mut switch_rtp_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn switch_rtp_set_payload_map(
        rtp_session: *mut switch_rtp_t,
        pmap: *mut *mut payload_map_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_rtp_intentional_bugs(rtp_session: *mut switch_rtp_t, bugs: switch_rtp_bug_flag_t);
}
extern "C" {
    pub fn switch_rtp_get_stats(
        rtp_session: *mut switch_rtp_t,
        pool: *mut switch_memory_pool_t,
    ) -> *mut switch_rtp_stats_t;
}
extern "C" {
    pub fn switch_rtp_check_auto_adj(rtp_session: *mut switch_rtp_t) -> switch_byte_t;
}
extern "C" {
    pub fn switch_rtp_set_interdigit_delay(rtp_session: *mut switch_rtp_t, delay: u32);
}
extern "C" {
    pub fn switch_rtp_add_dtls(
        rtp_session: *mut switch_rtp_t,
        local_fp: *mut dtls_fingerprint_t,
        remote_fp: *mut dtls_fingerprint_t,
        type_: dtls_type_t,
        want_DTLSv1_2: u8,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_rtp_del_dtls(
        rtp_session: *mut switch_rtp_t,
        type_: dtls_type_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_rtp_dtls_state(
        rtp_session: *mut switch_rtp_t,
        type_: dtls_type_t,
    ) -> dtls_state_t;
}
extern "C" {
    pub fn switch_rtp_has_dtls() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_rtp_req_bitrate(rtp_session: *mut switch_rtp_t, bps: u32) -> switch_status_t;
}
extern "C" {
    pub fn switch_rtp_ack_bitrate(rtp_session: *mut switch_rtp_t, bps: u32) -> switch_status_t;
}
extern "C" {
    pub fn switch_rtp_video_refresh(rtp_session: *mut switch_rtp_t);
}
extern "C" {
    pub fn switch_rtp_video_loss(rtp_session: *mut switch_rtp_t);
}
extern "C" {
    pub fn switch_rtp_get_core_session(
        rtp_session: *mut switch_rtp_t,
    ) -> *mut switch_core_session_t;
}
pub const switch_xml_flag_t_SWITCH_XML_ROOT: switch_xml_flag_t = 1;
pub const switch_xml_flag_t_SWITCH_XML_NAMEM: switch_xml_flag_t = 2;
pub const switch_xml_flag_t_SWITCH_XML_TXTM: switch_xml_flag_t = 4;
pub const switch_xml_flag_t_SWITCH_XML_DUP: switch_xml_flag_t = 8;
pub const switch_xml_flag_t_SWITCH_XML_CDATA: switch_xml_flag_t = 16;
pub type switch_xml_flag_t = ::std::os::raw::c_uint;
#[doc = " \\brief A representation of an XML tree"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_xml {
    #[doc = " tag name"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = " tag attributes { name, value, name, value, ... NULL }"]
    pub attr: *mut *mut ::std::os::raw::c_char,
    #[doc = " tag character content, empty string if none"]
    pub txt: *mut ::std::os::raw::c_char,
    #[doc = " path to free on destroy"]
    pub free_path: *mut ::std::os::raw::c_char,
    #[doc = " tag offset from start of parent tag character content"]
    pub off: switch_size_t,
    #[doc = " next tag with same name in this section at this depth"]
    pub next: switch_xml_t,
    #[doc = " next tag with different name in same section and depth"]
    pub sibling: switch_xml_t,
    #[doc = " next tag, same section and depth, in original order"]
    pub ordered: switch_xml_t,
    #[doc = " head of sub tag list, NULL if none"]
    pub child: switch_xml_t,
    #[doc = " parent tag, NULL if current tag is root tag"]
    pub parent: switch_xml_t,
    #[doc = " flags"]
    pub flags: u32,
    #[doc = " is_switch_xml_root bool"]
    pub is_switch_xml_root_t: switch_bool_t,
    pub refs: u32,
    #[doc = " pointer to end of opening tag, '>', in the original parsed text"]
    pub open: *const ::std::os::raw::c_char,
    #[doc = " pointer to start of closing tag, '<', in the original parsed text"]
    pub close: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_switch_xml() {
    const UNINIT: ::std::mem::MaybeUninit<switch_xml> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_xml>(),
        112usize,
        concat!("Size of: ", stringify!(switch_xml))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_xml>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_xml))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml),
            "::",
            stringify!(attr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).txt) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml),
            "::",
            stringify!(txt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_path) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml),
            "::",
            stringify!(free_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).off) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml),
            "::",
            stringify!(off)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sibling) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml),
            "::",
            stringify!(sibling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ordered) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml),
            "::",
            stringify!(ordered)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).child) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_switch_xml_root_t) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml),
            "::",
            stringify!(is_switch_xml_root_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refs) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).open) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml),
            "::",
            stringify!(close)
        )
    );
}
extern "C" {
    #[doc = " \\brief Parses a string into a switch_xml_t, ensuring the memory will be freed with switch_xml_free\n \\param s The string to parse\n \\param dup true if you want the string to be strdup()'d automatically\n \\return the switch_xml_t or NULL if an error occured"]
    pub fn switch_xml_parse_str_dynamic(
        s: *mut ::std::os::raw::c_char,
        dup: switch_bool_t,
    ) -> switch_xml_t;
}
extern "C" {
    #[doc = "\\brief Given a string of xml data and its length, parses it and creates an switch_xml\n\\ structure. For efficiency, modifies the data by adding null terminators\n\\ and decoding ampersand sequences. If you don't want this, copy the data and\n\\ pass in the copy. Returns NULL on failure.\n\\param s a string\n\\param len the length of the string\n\\return a formated xml node or NULL"]
    pub fn switch_xml_parse_str(s: *mut ::std::os::raw::c_char, len: switch_size_t)
        -> switch_xml_t;
}
extern "C" {
    #[doc = "\\brief A wrapper for switch_xml_parse_str() that accepts a file descriptor. First\n\\ attempts to mem map the file. Failing that, reads the file into memory.\n\\ Returns NULL on failure.\n\\param fd\n\\return a formated xml node or NULL"]
    pub fn switch_xml_parse_fd(fd: ::std::os::raw::c_int) -> switch_xml_t;
}
extern "C" {
    #[doc = "\\brief a wrapper for switch_xml_parse_fd() that accepts a file name\n\\param file a file to parse\n\\return a formated xml node or NULL"]
    pub fn switch_xml_parse_file(file: *const ::std::os::raw::c_char) -> switch_xml_t;
}
extern "C" {
    pub fn switch_xml_parse_file_simple(file: *const ::std::os::raw::c_char) -> switch_xml_t;
}
extern "C" {
    #[doc = "\\brief Wrapper for switch_xml_parse_str() that accepts a file stream. Reads the entire\n\\ stream into memory and then parses it. For xml files, use switch_xml_parse_file()\n\\ or switch_xml_parse_fd()\n\\param fp a FILE pointer to parse\n\\return an xml node or NULL"]
    pub fn switch_xml_parse_fp(fp: *mut FILE) -> switch_xml_t;
}
extern "C" {
    #[doc = "\\brief returns the first child tag (one level deeper) with the given name or NULL\n\\ if not found\n\\param xml an xml node\n\\param name the name of the child tag\n\\return an xml node or NULL"]
    pub fn switch_xml_child(xml: switch_xml_t, name: *const ::std::os::raw::c_char)
        -> switch_xml_t;
}
extern "C" {
    #[doc = "\\brief find a child tag in a node called 'childname' with an attribute 'attrname' which equals 'value'\n\\param node the xml node\n\\param childname the child tag name\n\\param attrname the attribute name\n\\param value the value\n\\return an xml node or NULL"]
    pub fn switch_xml_find_child(
        node: switch_xml_t,
        childname: *const ::std::os::raw::c_char,
        attrname: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> switch_xml_t;
}
extern "C" {
    pub fn switch_xml_find_child_multi(
        node: switch_xml_t,
        childname: *const ::std::os::raw::c_char,
        ...
    ) -> switch_xml_t;
}
extern "C" {
    #[doc = "\\brief Returns the Nth tag with the same name in the same section at the same depth\n\\ or NULL if not found. An index of 0 returns the tag given.\n\\param xml the xml node\n\\param idx the index\n\\return an xml node or NULL"]
    pub fn switch_xml_idx(xml: switch_xml_t, idx: ::std::os::raw::c_int) -> switch_xml_t;
}
extern "C" {
    #[doc = "\\brief returns the value of the requested tag attribute, or NULL if not found\n\\param xml the xml node\n\\param attr the attribute\n\\return the value"]
    pub fn switch_xml_attr(
        xml: switch_xml_t,
        attr: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief returns the value of the requested tag attribute, or \"\" if not found\n\\param xml the xml node\n\\param attr the attribute\n\\return the value"]
    pub fn switch_xml_attr_soft(
        xml: switch_xml_t,
        attr: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Traverses the switch_xml structure to retrieve a specific subtag. Takes a\n\\ variable length list of tag names and indexes. The argument list must be\n\\ terminated by either an index of -1 or an empty string tag name. Example:\n\\ title = switch_xml_get(library, \"shelf\", 0, \"book\", 2, \"title\", -1);\n\\ This retrieves the title of the 3rd book on the 1st shelf of library.\n\\ Returns NULL if not found.\n\\param xml the xml node\n\\return an xml node or NULL"]
    pub fn switch_xml_get(xml: switch_xml_t, ...) -> switch_xml_t;
}
extern "C" {
    pub fn switch_xml_toxml_ex(
        xml: switch_xml_t,
        prn_header: switch_bool_t,
        use_utf8_encoding: switch_bool_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_xml_toxml_nolock_ex(
        xml: switch_xml_t,
        prn_header: switch_bool_t,
        use_utf8_encoding: switch_bool_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_xml_tohtml_ex(
        xml: switch_xml_t,
        prn_header: switch_bool_t,
        use_utf8_encoding: switch_bool_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_xml_toxml_buf_ex(
        xml: switch_xml_t,
        buf: *mut ::std::os::raw::c_char,
        buflen: switch_size_t,
        offset: switch_size_t,
        prn_header: switch_bool_t,
        use_utf8_encoding: switch_bool_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief returns a NULL terminated array of processing instructions for the given\n\\ target\n\\param xml the xml node\n\\param target the instructions\n\\return the array"]
    pub fn switch_xml_pi(
        xml: switch_xml_t,
        target: *const ::std::os::raw::c_char,
    ) -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief frees the memory allocated for an switch_xml structure\n\\param xml the xml node\n\\note in the case of the root node the readlock will be lifted"]
    pub fn switch_xml_free(xml: switch_xml_t);
}
extern "C" {
    pub fn switch_xml_free_in_thread(xml: switch_xml_t, stacksize: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "\\brief returns parser error message or empty string if none\n\\param xml the xml node\n\\return the error string or nothing"]
    pub fn switch_xml_error(xml: switch_xml_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief returns a new empty switch_xml structure with the given root tag name\n\\param name the name of the new root tag"]
    pub fn switch_xml_new(name: *const ::std::os::raw::c_char) -> switch_xml_t;
}
extern "C" {
    #[doc = "\\brief Adds a child tag. off is the offset of the child tag relative to the start\n\\ of the parent tag's character content. Returns the child tag.\n\\param xml the xml node\n\\param name the name of the tag\n\\param off the offset\n\\return an xml node or NULL"]
    pub fn switch_xml_add_child(
        xml: switch_xml_t,
        name: *const ::std::os::raw::c_char,
        off: switch_size_t,
    ) -> switch_xml_t;
}
extern "C" {
    #[doc = "\\brief wrapper for switch_xml_add_child() that strdup()s name\n\\param xml the xml node\n\\param name the name of the child\n\\param off the offset"]
    pub fn switch_xml_add_child_d(
        xml: switch_xml_t,
        name: *const ::std::os::raw::c_char,
        off: switch_size_t,
    ) -> switch_xml_t;
}
extern "C" {
    #[doc = "\\brief sets the character content for the given tag and returns the tag\n\\param xml the xml node\n\\param txt the text\n\\return an xml node or NULL"]
    pub fn switch_xml_set_txt(
        xml: switch_xml_t,
        txt: *const ::std::os::raw::c_char,
    ) -> switch_xml_t;
}
extern "C" {
    #[doc = "\\brief wrapper for switch_xml_set_txt() that strdup()s txt\n\\ sets the character content for the given tag and returns the tag\n\\param xml the xml node\n\\param txt the text\n\\return an xml node or NULL"]
    pub fn switch_xml_set_txt_d(
        xml: switch_xml_t,
        txt: *const ::std::os::raw::c_char,
    ) -> switch_xml_t;
}
extern "C" {
    #[doc = "\\brief Sets the given tag attribute or adds a new attribute if not found. A value\n\\ of NULL will remove the specified attribute.\n\\param xml the xml node\n\\param name the attribute name\n\\param value the attribute value\n\\return the tag given"]
    pub fn switch_xml_set_attr(
        xml: switch_xml_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> switch_xml_t;
}
extern "C" {
    #[doc = "\\brief Wrapper for switch_xml_set_attr() that strdup()s name/value. Value cannot be NULL\n\\param xml the xml node\n\\param name the attribute name\n\\param value the attribute value\n\\return an xml node or NULL"]
    pub fn switch_xml_set_attr_d(
        xml: switch_xml_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> switch_xml_t;
}
extern "C" {
    #[doc = "\\brief Wrapper for switch_xml_set_attr() that strdup()s name/value. Value cannot be NULL\n\\param xml the xml node\n\\param name the attribute name\n\\param value the attribute value\n\\return an xml node or NULL"]
    pub fn switch_xml_set_attr_d_buf(
        xml: switch_xml_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> switch_xml_t;
}
extern "C" {
    #[doc = "\\brief sets a flag for the given tag and returns the tag\n\\param xml the xml node\n\\param flag the flag to set\n\\return an xml node or NULL"]
    pub fn switch_xml_set_flag(xml: switch_xml_t, flag: switch_xml_flag_t) -> switch_xml_t;
}
extern "C" {
    #[doc = "\\brief removes a tag along with its subtags without freeing its memory\n\\param xml the xml node"]
    pub fn switch_xml_cut(xml: switch_xml_t) -> switch_xml_t;
}
extern "C" {
    #[doc = "\\brief inserts an existing tag into an ezxml structure"]
    pub fn switch_xml_insert(
        xml: switch_xml_t,
        dest: switch_xml_t,
        off: switch_size_t,
    ) -> switch_xml_t;
}
extern "C" {
    #[doc = "\\brief set new core xml root"]
    pub fn switch_xml_set_root(new_main: switch_xml_t) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Set and alternate function for opening xml root"]
    pub fn switch_xml_set_open_root_function(
        func: switch_xml_open_root_function_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief open the Core xml root\n\\param reload if it's is already open close it and open it again as soon as permissable (blocking)\n\\param err a pointer to set error strings\n\\return the xml root node or NULL"]
    pub fn switch_xml_open_root(
        reload: u8,
        err: *mut *const ::std::os::raw::c_char,
    ) -> switch_xml_t;
}
extern "C" {
    #[doc = "\\brief initilize the core XML backend\n\\param pool a memory pool to use\n\\param err a pointer to set error strings\n\\return SWITCH_STATUS_SUCCESS if successful"]
    pub fn switch_xml_init(
        pool: *mut switch_memory_pool_t,
        err: *mut *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_xml_reload(err: *mut *const ::std::os::raw::c_char) -> switch_status_t;
}
extern "C" {
    pub fn switch_xml_destroy() -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief retrieve the core XML root node\n\\return the xml root node\n\\note this will cause a readlock on the root until it's released with \\see switch_xml_free"]
    pub fn switch_xml_root() -> switch_xml_t;
}
extern "C" {
    #[doc = "\\brief locate an xml pointer in the core registry\n\\param section the section to look in\n\\param tag_name the type of tag in that section\n\\param key_name the name of the key\n\\param key_value the value of the key\n\\param root a pointer to point at the root node\n\\param node a pointer to the requested node\n\\param params optional URL formatted params to pass to external gateways\n\\return SWITCH_STATUS_SUCCESS if successful root and node will be assigned"]
    pub fn switch_xml_locate(
        section: *const ::std::os::raw::c_char,
        tag_name: *const ::std::os::raw::c_char,
        key_name: *const ::std::os::raw::c_char,
        key_value: *const ::std::os::raw::c_char,
        root: *mut switch_xml_t,
        node: *mut switch_xml_t,
        params: *mut switch_event_t,
        clone: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_xml_locate_domain(
        domain_name: *const ::std::os::raw::c_char,
        params: *mut switch_event_t,
        root: *mut switch_xml_t,
        domain: *mut switch_xml_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_xml_locate_group(
        group_name: *const ::std::os::raw::c_char,
        domain_name: *const ::std::os::raw::c_char,
        root: *mut switch_xml_t,
        domain: *mut switch_xml_t,
        group: *mut switch_xml_t,
        params: *mut switch_event_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_xml_locate_user(
        key: *const ::std::os::raw::c_char,
        user_name: *const ::std::os::raw::c_char,
        domain_name: *const ::std::os::raw::c_char,
        ip: *const ::std::os::raw::c_char,
        root: *mut switch_xml_t,
        domain: *mut switch_xml_t,
        user: *mut switch_xml_t,
        ingroup: *mut switch_xml_t,
        params: *mut switch_event_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_xml_locate_user_in_domain(
        user_name: *const ::std::os::raw::c_char,
        domain: switch_xml_t,
        user: *mut switch_xml_t,
        ingroup: *mut switch_xml_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_xml_locate_user_merged(
        key: *const ::std::os::raw::c_char,
        user_name: *const ::std::os::raw::c_char,
        domain_name: *const ::std::os::raw::c_char,
        ip: *const ::std::os::raw::c_char,
        user: *mut switch_xml_t,
        params: *mut switch_event_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_xml_clear_user_cache(
        key: *const ::std::os::raw::c_char,
        user_name: *const ::std::os::raw::c_char,
        domain_name: *const ::std::os::raw::c_char,
    ) -> u32;
}
extern "C" {
    pub fn switch_xml_merge_user(user: switch_xml_t, domain: switch_xml_t, group: switch_xml_t);
}
extern "C" {
    pub fn switch_xml_dup(xml: switch_xml_t) -> switch_xml_t;
}
extern "C" {
    #[doc = "\\brief open a config in the core registry\n\\param file_path the name of the config section e.g. modules.conf\n\\param node a pointer to point to the node if it is found\n\\param params optional URL formatted params to pass to external gateways\n\\return the root xml node associated with the current request or NULL"]
    pub fn switch_xml_open_cfg(
        file_path: *const ::std::os::raw::c_char,
        node: *mut switch_xml_t,
        params: *mut switch_event_t,
    ) -> switch_xml_t;
}
extern "C" {
    #[doc = "\\brief bind a search function to an external gateway\n\\param function the search function to bind\n\\param sections a bitmask of sections you wil service\n\\param user_data a pointer to private data to be used during the callback\n\\return SWITCH_STATUS_SUCCESS if successful\n\\note gateway functions will be executed in the order they were binded until a success is found else the root registry will be used"]
    pub fn switch_xml_set_binding_sections(
        binding: *mut switch_xml_binding_t,
        sections: switch_xml_section_t,
    );
}
extern "C" {
    pub fn switch_xml_set_binding_user_data(
        binding: *mut switch_xml_binding_t,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn switch_xml_get_binding_sections(
        binding: *mut switch_xml_binding_t,
    ) -> switch_xml_section_t;
}
extern "C" {
    pub fn switch_xml_get_binding_user_data(
        binding: *mut switch_xml_binding_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn switch_xml_bind_search_function_ret(
        function: switch_xml_search_function_t,
        sections: switch_xml_section_t,
        user_data: *mut ::std::os::raw::c_void,
        ret_binding: *mut *mut switch_xml_binding_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_xml_unbind_search_function(
        binding: *mut *mut switch_xml_binding_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_xml_unbind_search_function_ptr(
        function: switch_xml_search_function_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief parse a string for a list of sections\n\\param str a | delimited list of section names\n\\return the section mask"]
    pub fn switch_xml_parse_section_string(
        str_: *const ::std::os::raw::c_char,
    ) -> switch_xml_section_t;
}
extern "C" {
    pub fn switch_xml_std_datetime_check(
        xcond: switch_xml_t,
        offset: *mut ::std::os::raw::c_int,
        tzname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_xml_locate_language(
        root: *mut switch_xml_t,
        node: *mut switch_xml_t,
        params: *mut switch_event_t,
        language: *mut switch_xml_t,
        phrases: *mut switch_xml_t,
        macros: *mut switch_xml_t,
        str_language: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
pub const switch_xml_config_type_t_SWITCH_CONFIG_INT: switch_xml_config_type_t = 0;
pub const switch_xml_config_type_t_SWITCH_CONFIG_ATOMIC: switch_xml_config_type_t = 1;
pub const switch_xml_config_type_t_SWITCH_CONFIG_STRING: switch_xml_config_type_t = 2;
pub const switch_xml_config_type_t_SWITCH_CONFIG_BOOL: switch_xml_config_type_t = 3;
pub const switch_xml_config_type_t_SWITCH_CONFIG_CUSTOM: switch_xml_config_type_t = 4;
pub const switch_xml_config_type_t_SWITCH_CONFIG_ENUM: switch_xml_config_type_t = 5;
pub const switch_xml_config_type_t_SWITCH_CONFIG_FLAG: switch_xml_config_type_t = 6;
pub const switch_xml_config_type_t_SWITCH_CONFIG_FLAGARRAY: switch_xml_config_type_t = 7;
pub const switch_xml_config_type_t_SWITCH_CONFIG_LAST: switch_xml_config_type_t = 8;
#[doc = " \\brief Type of value to parse"]
pub type switch_xml_config_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_xml_config_enum_item_t {
    pub key: *mut ::std::os::raw::c_char,
    pub value: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_switch_xml_config_enum_item_t() {
    const UNINIT: ::std::mem::MaybeUninit<switch_xml_config_enum_item_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_xml_config_enum_item_t>(),
        16usize,
        concat!("Size of: ", stringify!(switch_xml_config_enum_item_t))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_xml_config_enum_item_t>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_xml_config_enum_item_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml_config_enum_item_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml_config_enum_item_t),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_xml_config_string_options_t {
    pub pool: *mut switch_memory_pool_t,
    pub length: switch_size_t,
    pub validation_regex: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_switch_xml_config_string_options_t() {
    const UNINIT: ::std::mem::MaybeUninit<switch_xml_config_string_options_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_xml_config_string_options_t>(),
        24usize,
        concat!("Size of: ", stringify!(switch_xml_config_string_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_xml_config_string_options_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(switch_xml_config_string_options_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml_config_string_options_t),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml_config_string_options_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).validation_regex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml_config_string_options_t),
            "::",
            stringify!(validation_regex)
        )
    );
}
extern "C" {
    pub static mut switch_config_string_strdup: switch_xml_config_string_options_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_xml_config_int_options_t {
    pub enforce_min: switch_bool_t,
    pub min: ::std::os::raw::c_int,
    pub enforce_max: switch_bool_t,
    pub max: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_switch_xml_config_int_options_t() {
    const UNINIT: ::std::mem::MaybeUninit<switch_xml_config_int_options_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_xml_config_int_options_t>(),
        16usize,
        concat!("Size of: ", stringify!(switch_xml_config_int_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_xml_config_int_options_t>(),
        4usize,
        concat!("Alignment of ", stringify!(switch_xml_config_int_options_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enforce_min) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml_config_int_options_t),
            "::",
            stringify!(enforce_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml_config_int_options_t),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enforce_max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml_config_int_options_t),
            "::",
            stringify!(enforce_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml_config_int_options_t),
            "::",
            stringify!(max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_xml_config_atomic_options_t {
    pub enforce_min: switch_bool_t,
    pub min: u32,
    pub enforce_max: switch_bool_t,
    pub max: u32,
}
#[test]
fn bindgen_test_layout_switch_xml_config_atomic_options_t() {
    const UNINIT: ::std::mem::MaybeUninit<switch_xml_config_atomic_options_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_xml_config_atomic_options_t>(),
        16usize,
        concat!("Size of: ", stringify!(switch_xml_config_atomic_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_xml_config_atomic_options_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(switch_xml_config_atomic_options_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enforce_min) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml_config_atomic_options_t),
            "::",
            stringify!(enforce_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml_config_atomic_options_t),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enforce_max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml_config_atomic_options_t),
            "::",
            stringify!(enforce_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml_config_atomic_options_t),
            "::",
            stringify!(max)
        )
    );
}
#[doc = " \\brief A configuration instruction read by switch_xml_config_parse"]
pub type switch_xml_config_item_t = switch_xml_config_item;
pub const switch_config_callback_type_t_CONFIG_LOAD: switch_config_callback_type_t = 0;
pub const switch_config_callback_type_t_CONFIG_RELOAD: switch_config_callback_type_t = 1;
pub const switch_config_callback_type_t_CONFIG_SHUTDOWN: switch_config_callback_type_t = 2;
pub type switch_config_callback_type_t = ::std::os::raw::c_uint;
pub const switch_config_flags_t_CONFIG_RELOADABLE: switch_config_flags_t = 1;
pub const switch_config_flags_t_CONFIG_REQUIRED: switch_config_flags_t = 2;
pub type switch_config_flags_t = ::std::os::raw::c_uint;
pub type switch_xml_config_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        item: *mut switch_xml_config_item_t,
        newvalue: *const ::std::os::raw::c_char,
        callback_type: switch_config_callback_type_t,
        changed: switch_bool_t,
    ) -> switch_status_t,
>;
#[doc = " \\brief A configuration instruction read by switch_xml_config_parse"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_xml_config_item {
    pub key: *const ::std::os::raw::c_char,
    pub type_: switch_xml_config_type_t,
    pub flags: ::std::os::raw::c_int,
    pub ptr: *mut ::std::os::raw::c_void,
    pub defaultvalue: *const ::std::os::raw::c_void,
    pub data: *mut ::std::os::raw::c_void,
    pub function: switch_xml_config_callback_t,
    pub syntax: *const ::std::os::raw::c_char,
    pub helptext: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_switch_xml_config_item() {
    const UNINIT: ::std::mem::MaybeUninit<switch_xml_config_item> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_xml_config_item>(),
        64usize,
        concat!("Size of: ", stringify!(switch_xml_config_item))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_xml_config_item>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_xml_config_item))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml_config_item),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml_config_item),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml_config_item),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml_config_item),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).defaultvalue) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml_config_item),
            "::",
            stringify!(defaultvalue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml_config_item),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).function) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml_config_item),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).syntax) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml_config_item),
            "::",
            stringify!(syntax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).helptext) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_xml_config_item),
            "::",
            stringify!(helptext)
        )
    );
}
extern "C" {
    pub fn switch_config_perform_set_item(
        item: *mut switch_xml_config_item_t,
        key: *const ::std::os::raw::c_char,
        type_: switch_xml_config_type_t,
        flags: ::std::os::raw::c_int,
        ptr: *mut ::std::os::raw::c_void,
        defaultvalue: *const ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
        function: switch_xml_config_callback_t,
        syntax: *const ::std::os::raw::c_char,
        helptext: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " \\brief Gets the int representation of an enum\n \\param enum_options the switch_xml_config_enum_item_t array for this enum\n \\param value string value to search"]
    pub fn switch_xml_config_enum_str2int(
        enum_options: *mut switch_xml_config_enum_item_t,
        value: *const ::std::os::raw::c_char,
        out: *mut ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " \\brief Gets the string representation of an enum\n \\param enum_options the switch_xml_config_enum_item_t array for this enum\n \\param value int value to search"]
    pub fn switch_xml_config_enum_int2str(
        enum_options: *mut switch_xml_config_enum_item_t,
        value: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\brief Prints out an item's documentation on the console\n \\param level loglevel to use\n \\param item item which the doc should be printed"]
    pub fn switch_xml_config_item_print_doc(
        level: ::std::os::raw::c_int,
        item: *mut switch_xml_config_item_t,
    );
}
extern "C" {
    #[doc = " \\brief Parses all the xml elements, following a ruleset defined by an array of switch_xml_config_item_t\n \\param xml The first element of the list to parse\n \\param reload true to skip all non-reloadable options\n \\param instructions instrutions on how to parse the elements\n \\see switch_xml_config_item_t"]
    pub fn switch_xml_config_parse(
        xml: switch_xml_t,
        reload: switch_bool_t,
        instructions: *mut switch_xml_config_item_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " \\brief Parses a module's settings\n \\param reload true to skip all non-reloadable options\n \\param file the configuration file to look for\n \\param instructions the instructions"]
    pub fn switch_xml_config_parse_module_settings(
        file: *const ::std::os::raw::c_char,
        reload: switch_bool_t,
        instructions: *mut switch_xml_config_item_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " \\brief Parses all of an event's elements, following a ruleset defined by an array of switch_xml_config_item_t\n \\param event The event structure containing the key and values to parse\n \\param reload true to skip all non-reloadable options\n \\param instructions instrutions on how to parse the elements\n \\see switch_xml_config_item_t"]
    pub fn switch_xml_config_parse_event(
        event: *mut switch_event_t,
        count: ::std::os::raw::c_int,
        reload: switch_bool_t,
        instructions: *mut switch_xml_config_item_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = " \\brief Parses a list of xml elements into an event\n \\param xml First element of the xml list to parse\n \\param keyname Name of the key attribute\n \\param keyvalue Name of the value attribute\n \\param event [out] event (if *event is NOT NULL, the headers will be appended to the existing event)"]
    pub fn switch_event_import_xml(
        xml: switch_xml_t,
        keyname: *const ::std::os::raw::c_char,
        valuename: *const ::std::os::raw::c_char,
        event: *mut *mut switch_event_t,
    ) -> switch_size_t;
}
extern "C" {
    #[doc = " \\brief Free any memory allocated by the configuration\n \\param instructions instrutions on how to parse the elements"]
    pub fn switch_xml_config_cleanup(instructions: *mut switch_xml_config_item_t);
}
#[doc = " \\brief A table of lists of io_event_hooks to store the event hooks associated with a session"]
pub type switch_io_event_hooks_t = switch_io_event_hooks;
#[doc = " \\brief Node in which to store custom receive message callback hooks"]
pub type switch_io_event_hook_outgoing_channel_t = switch_io_event_hook_outgoing_channel;
#[doc = " \\brief Node in which to store custom receive message callback hooks"]
pub type switch_io_event_hook_receive_message_t = switch_io_event_hook_receive_message;
#[doc = " \\brief Node in which to store custom receive message callback hooks"]
pub type switch_io_event_hook_receive_event_t = switch_io_event_hook_receive_event;
#[doc = " \\brief Node in which to store custom read frame channel callback hooks"]
pub type switch_io_event_hook_read_frame_t = switch_io_event_hook_read_frame;
#[doc = " \\brief Node in which to store custom read frame channel callback hooks"]
pub type switch_io_event_hook_video_read_frame_t = switch_io_event_hook_video_read_frame;
#[doc = " \\brief Node in which to store custom write_frame channel callback hooks"]
pub type switch_io_event_hook_write_frame_t = switch_io_event_hook_write_frame;
#[doc = " \\brief Node in which to store custom video_write_frame channel callback hooks"]
pub type switch_io_event_hook_video_write_frame_t = switch_io_event_hook_video_write_frame;
#[doc = " \\brief Node in which to store custom read frame channel callback hooks"]
pub type switch_io_event_hook_text_read_frame_t = switch_io_event_hook_text_read_frame;
#[doc = " \\brief Node in which to store custom video_write_frame channel callback hooks"]
pub type switch_io_event_hook_text_write_frame_t = switch_io_event_hook_text_write_frame;
#[doc = " \\brief Node in which to store custom kill channel callback hooks"]
pub type switch_io_event_hook_kill_channel_t = switch_io_event_hook_kill_channel;
#[doc = " \\brief Node in which to store custom send dtmf channel callback hooks"]
pub type switch_io_event_hook_send_dtmf_t = switch_io_event_hook_send_dtmf;
#[doc = " \\brief Node in which to store custom recv dtmf channel callback hooks"]
pub type switch_io_event_hook_recv_dtmf_t = switch_io_event_hook_recv_dtmf;
#[doc = " \\brief Node in which to store state change callback hooks"]
pub type switch_io_event_hook_state_change_t = switch_io_event_hook_state_change;
#[doc = " \\brief Node in which to store state run callback hooks"]
pub type switch_io_event_hook_state_run_t = switch_io_event_hook_state_run;
pub type switch_outgoing_channel_hook_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut switch_core_session_t,
        arg2: *mut switch_event_t,
        arg3: *mut switch_caller_profile_t,
        arg4: *mut switch_core_session_t,
        arg5: switch_originate_flag_t,
    ) -> switch_status_t,
>;
pub type switch_receive_message_hook_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut switch_core_session_t,
        arg2: *mut switch_core_session_message_t,
    ) -> switch_status_t,
>;
pub type switch_receive_event_hook_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut switch_core_session_t,
        arg2: *mut switch_event_t,
    ) -> switch_status_t,
>;
pub type switch_read_frame_hook_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut switch_core_session_t,
        arg2: *mut *mut switch_frame_t,
        arg3: switch_io_flag_t,
        arg4: ::std::os::raw::c_int,
    ) -> switch_status_t,
>;
pub type switch_video_read_frame_hook_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut switch_core_session_t,
        arg2: *mut *mut switch_frame_t,
        arg3: switch_io_flag_t,
        arg4: ::std::os::raw::c_int,
    ) -> switch_status_t,
>;
pub type switch_write_frame_hook_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut switch_core_session_t,
        arg2: *mut switch_frame_t,
        arg3: switch_io_flag_t,
        arg4: ::std::os::raw::c_int,
    ) -> switch_status_t,
>;
pub type switch_video_write_frame_hook_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut switch_core_session_t,
        arg2: *mut switch_frame_t,
        arg3: switch_io_flag_t,
        arg4: ::std::os::raw::c_int,
    ) -> switch_status_t,
>;
pub type switch_text_read_frame_hook_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut switch_core_session_t,
        arg2: *mut *mut switch_frame_t,
        arg3: switch_io_flag_t,
        arg4: ::std::os::raw::c_int,
    ) -> switch_status_t,
>;
pub type switch_text_write_frame_hook_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut switch_core_session_t,
        arg2: *mut switch_frame_t,
        arg3: switch_io_flag_t,
        arg4: ::std::os::raw::c_int,
    ) -> switch_status_t,
>;
pub type switch_kill_channel_hook_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut switch_core_session_t,
        arg2: ::std::os::raw::c_int,
    ) -> switch_status_t,
>;
pub type switch_send_dtmf_hook_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut switch_core_session_t,
        arg2: *const switch_dtmf_t,
        direction: switch_dtmf_direction_t,
    ) -> switch_status_t,
>;
pub type switch_recv_dtmf_hook_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut switch_core_session_t,
        arg2: *const switch_dtmf_t,
        direction: switch_dtmf_direction_t,
    ) -> switch_status_t,
>;
pub type switch_state_change_hook_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut switch_core_session_t) -> switch_status_t,
>;
pub type switch_state_run_hook_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut switch_core_session_t) -> switch_status_t,
>;
#[doc = " \\brief Node in which to store custom receive message callback hooks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_io_event_hook_outgoing_channel {
    pub outgoing_channel: switch_outgoing_channel_hook_t,
    pub next: *mut switch_io_event_hook_outgoing_channel,
}
#[test]
fn bindgen_test_layout_switch_io_event_hook_outgoing_channel() {
    const UNINIT: ::std::mem::MaybeUninit<switch_io_event_hook_outgoing_channel> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_io_event_hook_outgoing_channel>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(switch_io_event_hook_outgoing_channel)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<switch_io_event_hook_outgoing_channel>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(switch_io_event_hook_outgoing_channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outgoing_channel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hook_outgoing_channel),
            "::",
            stringify!(outgoing_channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hook_outgoing_channel),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " \\brief Node in which to store custom receive message callback hooks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_io_event_hook_receive_message {
    pub receive_message: switch_receive_message_hook_t,
    pub next: *mut switch_io_event_hook_receive_message,
}
#[test]
fn bindgen_test_layout_switch_io_event_hook_receive_message() {
    const UNINIT: ::std::mem::MaybeUninit<switch_io_event_hook_receive_message> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_io_event_hook_receive_message>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(switch_io_event_hook_receive_message)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<switch_io_event_hook_receive_message>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(switch_io_event_hook_receive_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receive_message) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hook_receive_message),
            "::",
            stringify!(receive_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hook_receive_message),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " \\brief Node in which to store custom receive message callback hooks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_io_event_hook_receive_event {
    #[doc = " the event callback hook"]
    pub receive_event: switch_receive_event_hook_t,
    pub next: *mut switch_io_event_hook_receive_event,
}
#[test]
fn bindgen_test_layout_switch_io_event_hook_receive_event() {
    const UNINIT: ::std::mem::MaybeUninit<switch_io_event_hook_receive_event> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_io_event_hook_receive_event>(),
        16usize,
        concat!("Size of: ", stringify!(switch_io_event_hook_receive_event))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_io_event_hook_receive_event>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(switch_io_event_hook_receive_event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receive_event) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hook_receive_event),
            "::",
            stringify!(receive_event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hook_receive_event),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " \\brief Node in which to store custom read frame channel callback hooks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_io_event_hook_read_frame {
    #[doc = " the read frame channel callback hook"]
    pub read_frame: switch_read_frame_hook_t,
    pub next: *mut switch_io_event_hook_read_frame,
}
#[test]
fn bindgen_test_layout_switch_io_event_hook_read_frame() {
    const UNINIT: ::std::mem::MaybeUninit<switch_io_event_hook_read_frame> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_io_event_hook_read_frame>(),
        16usize,
        concat!("Size of: ", stringify!(switch_io_event_hook_read_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_io_event_hook_read_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_io_event_hook_read_frame))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_frame) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hook_read_frame),
            "::",
            stringify!(read_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hook_read_frame),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " \\brief Node in which to store custom read frame channel callback hooks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_io_event_hook_video_read_frame {
    #[doc = " the read frame channel callback hook"]
    pub video_read_frame: switch_read_frame_hook_t,
    pub next: *mut switch_io_event_hook_video_read_frame,
}
#[test]
fn bindgen_test_layout_switch_io_event_hook_video_read_frame() {
    const UNINIT: ::std::mem::MaybeUninit<switch_io_event_hook_video_read_frame> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_io_event_hook_video_read_frame>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(switch_io_event_hook_video_read_frame)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<switch_io_event_hook_video_read_frame>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(switch_io_event_hook_video_read_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).video_read_frame) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hook_video_read_frame),
            "::",
            stringify!(video_read_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hook_video_read_frame),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " \\brief Node in which to store custom write_frame channel callback hooks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_io_event_hook_write_frame {
    #[doc = " the write_frame channel callback hook"]
    pub write_frame: switch_write_frame_hook_t,
    pub next: *mut switch_io_event_hook_write_frame,
}
#[test]
fn bindgen_test_layout_switch_io_event_hook_write_frame() {
    const UNINIT: ::std::mem::MaybeUninit<switch_io_event_hook_write_frame> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_io_event_hook_write_frame>(),
        16usize,
        concat!("Size of: ", stringify!(switch_io_event_hook_write_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_io_event_hook_write_frame>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(switch_io_event_hook_write_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_frame) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hook_write_frame),
            "::",
            stringify!(write_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hook_write_frame),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " \\brief Node in which to store custom video_write_frame channel callback hooks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_io_event_hook_video_write_frame {
    #[doc = " the video_write_frame channel callback hook"]
    pub video_write_frame: switch_video_write_frame_hook_t,
    pub next: *mut switch_io_event_hook_video_write_frame,
}
#[test]
fn bindgen_test_layout_switch_io_event_hook_video_write_frame() {
    const UNINIT: ::std::mem::MaybeUninit<switch_io_event_hook_video_write_frame> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_io_event_hook_video_write_frame>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(switch_io_event_hook_video_write_frame)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<switch_io_event_hook_video_write_frame>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(switch_io_event_hook_video_write_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).video_write_frame) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hook_video_write_frame),
            "::",
            stringify!(video_write_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hook_video_write_frame),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " \\brief Node in which to store custom read frame channel callback hooks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_io_event_hook_text_read_frame {
    #[doc = " the read frame channel callback hook"]
    pub text_read_frame: switch_read_frame_hook_t,
    pub next: *mut switch_io_event_hook_text_read_frame,
}
#[test]
fn bindgen_test_layout_switch_io_event_hook_text_read_frame() {
    const UNINIT: ::std::mem::MaybeUninit<switch_io_event_hook_text_read_frame> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_io_event_hook_text_read_frame>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(switch_io_event_hook_text_read_frame)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<switch_io_event_hook_text_read_frame>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(switch_io_event_hook_text_read_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text_read_frame) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hook_text_read_frame),
            "::",
            stringify!(text_read_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hook_text_read_frame),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " \\brief Node in which to store custom video_write_frame channel callback hooks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_io_event_hook_text_write_frame {
    #[doc = " the video_write_frame channel callback hook"]
    pub text_write_frame: switch_video_write_frame_hook_t,
    pub next: *mut switch_io_event_hook_text_write_frame,
}
#[test]
fn bindgen_test_layout_switch_io_event_hook_text_write_frame() {
    const UNINIT: ::std::mem::MaybeUninit<switch_io_event_hook_text_write_frame> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_io_event_hook_text_write_frame>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(switch_io_event_hook_text_write_frame)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<switch_io_event_hook_text_write_frame>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(switch_io_event_hook_text_write_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text_write_frame) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hook_text_write_frame),
            "::",
            stringify!(text_write_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hook_text_write_frame),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " \\brief Node in which to store custom kill channel callback hooks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_io_event_hook_kill_channel {
    #[doc = " the kill channel callback hook"]
    pub kill_channel: switch_kill_channel_hook_t,
    pub next: *mut switch_io_event_hook_kill_channel,
}
#[test]
fn bindgen_test_layout_switch_io_event_hook_kill_channel() {
    const UNINIT: ::std::mem::MaybeUninit<switch_io_event_hook_kill_channel> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_io_event_hook_kill_channel>(),
        16usize,
        concat!("Size of: ", stringify!(switch_io_event_hook_kill_channel))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_io_event_hook_kill_channel>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(switch_io_event_hook_kill_channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kill_channel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hook_kill_channel),
            "::",
            stringify!(kill_channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hook_kill_channel),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " \\brief Node in which to store custom send dtmf channel callback hooks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_io_event_hook_send_dtmf {
    #[doc = " the send dtmf channel callback hook"]
    pub send_dtmf: switch_send_dtmf_hook_t,
    pub next: *mut switch_io_event_hook_send_dtmf,
}
#[test]
fn bindgen_test_layout_switch_io_event_hook_send_dtmf() {
    const UNINIT: ::std::mem::MaybeUninit<switch_io_event_hook_send_dtmf> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_io_event_hook_send_dtmf>(),
        16usize,
        concat!("Size of: ", stringify!(switch_io_event_hook_send_dtmf))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_io_event_hook_send_dtmf>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_io_event_hook_send_dtmf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).send_dtmf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hook_send_dtmf),
            "::",
            stringify!(send_dtmf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hook_send_dtmf),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " \\brief Node in which to store custom recv dtmf channel callback hooks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_io_event_hook_recv_dtmf {
    #[doc = " the recv dtmf channel callback hook"]
    pub recv_dtmf: switch_recv_dtmf_hook_t,
    pub next: *mut switch_io_event_hook_recv_dtmf,
}
#[test]
fn bindgen_test_layout_switch_io_event_hook_recv_dtmf() {
    const UNINIT: ::std::mem::MaybeUninit<switch_io_event_hook_recv_dtmf> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_io_event_hook_recv_dtmf>(),
        16usize,
        concat!("Size of: ", stringify!(switch_io_event_hook_recv_dtmf))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_io_event_hook_recv_dtmf>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_io_event_hook_recv_dtmf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recv_dtmf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hook_recv_dtmf),
            "::",
            stringify!(recv_dtmf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hook_recv_dtmf),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " \\brief Node in which to store state change callback hooks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_io_event_hook_state_change {
    #[doc = " the state change channel callback hook"]
    pub state_change: switch_state_change_hook_t,
    pub next: *mut switch_io_event_hook_state_change,
}
#[test]
fn bindgen_test_layout_switch_io_event_hook_state_change() {
    const UNINIT: ::std::mem::MaybeUninit<switch_io_event_hook_state_change> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_io_event_hook_state_change>(),
        16usize,
        concat!("Size of: ", stringify!(switch_io_event_hook_state_change))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_io_event_hook_state_change>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(switch_io_event_hook_state_change)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state_change) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hook_state_change),
            "::",
            stringify!(state_change)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hook_state_change),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " \\brief Node in which to store state run callback hooks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_io_event_hook_state_run {
    #[doc = " the state run channel callback hook"]
    pub state_run: switch_state_run_hook_t,
    pub next: *mut switch_io_event_hook_state_run,
}
#[test]
fn bindgen_test_layout_switch_io_event_hook_state_run() {
    const UNINIT: ::std::mem::MaybeUninit<switch_io_event_hook_state_run> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_io_event_hook_state_run>(),
        16usize,
        concat!("Size of: ", stringify!(switch_io_event_hook_state_run))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_io_event_hook_state_run>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_io_event_hook_state_run))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state_run) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hook_state_run),
            "::",
            stringify!(state_run)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hook_state_run),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " \\brief A table of lists of io_event_hooks to store the event hooks associated with a session"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_io_event_hooks {
    #[doc = " a list of outgoing channel hooks"]
    pub outgoing_channel: *mut switch_io_event_hook_outgoing_channel_t,
    #[doc = " a list of receive message hooks"]
    pub receive_message: *mut switch_io_event_hook_receive_message_t,
    #[doc = " a list of queue message hooks"]
    pub receive_event: *mut switch_io_event_hook_receive_event_t,
    #[doc = " a list of read frame hooks"]
    pub read_frame: *mut switch_io_event_hook_read_frame_t,
    #[doc = " a list of video read frame hooks"]
    pub video_read_frame: *mut switch_io_event_hook_video_read_frame_t,
    #[doc = " a list of write frame hooks"]
    pub write_frame: *mut switch_io_event_hook_write_frame_t,
    #[doc = " a list of text write frame hooks"]
    pub video_write_frame: *mut switch_io_event_hook_video_write_frame_t,
    #[doc = " a list of text write frame hooks"]
    pub text_write_frame: *mut switch_io_event_hook_text_write_frame_t,
    #[doc = " a list of text read frame hooks"]
    pub text_read_frame: *mut switch_io_event_hook_text_read_frame_t,
    #[doc = " a list of kill channel hooks"]
    pub kill_channel: *mut switch_io_event_hook_kill_channel_t,
    #[doc = " a list of send dtmf hooks"]
    pub send_dtmf: *mut switch_io_event_hook_send_dtmf_t,
    #[doc = " a list of recv dtmf hooks"]
    pub recv_dtmf: *mut switch_io_event_hook_recv_dtmf_t,
    #[doc = " a list of state change hooks"]
    pub state_change: *mut switch_io_event_hook_state_change_t,
    pub state_run: *mut switch_io_event_hook_state_run_t,
}
#[test]
fn bindgen_test_layout_switch_io_event_hooks() {
    const UNINIT: ::std::mem::MaybeUninit<switch_io_event_hooks> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_io_event_hooks>(),
        112usize,
        concat!("Size of: ", stringify!(switch_io_event_hooks))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_io_event_hooks>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_io_event_hooks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outgoing_channel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hooks),
            "::",
            stringify!(outgoing_channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receive_message) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hooks),
            "::",
            stringify!(receive_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receive_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hooks),
            "::",
            stringify!(receive_event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_frame) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hooks),
            "::",
            stringify!(read_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).video_read_frame) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hooks),
            "::",
            stringify!(video_read_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_frame) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hooks),
            "::",
            stringify!(write_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).video_write_frame) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hooks),
            "::",
            stringify!(video_write_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text_write_frame) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hooks),
            "::",
            stringify!(text_write_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text_read_frame) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hooks),
            "::",
            stringify!(text_read_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kill_channel) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hooks),
            "::",
            stringify!(kill_channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).send_dtmf) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hooks),
            "::",
            stringify!(send_dtmf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recv_dtmf) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hooks),
            "::",
            stringify!(recv_dtmf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state_change) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hooks),
            "::",
            stringify!(state_change)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state_run) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_io_event_hooks),
            "::",
            stringify!(state_run)
        )
    );
}
extern "C" {
    pub fn switch_core_session_get_event_hooks(
        session: *mut switch_core_session_t,
    ) -> switch_io_event_hooks_t;
}
extern "C" {
    pub fn switch_core_event_hook_add_outgoing_channel(
        session: *mut switch_core_session_t,
        outgoing_channel: switch_outgoing_channel_hook_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_event_hook_add_receive_message(
        session: *mut switch_core_session_t,
        receive_message: switch_receive_message_hook_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_event_hook_add_receive_event(
        session: *mut switch_core_session_t,
        receive_event: switch_receive_event_hook_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_event_hook_add_state_change(
        session: *mut switch_core_session_t,
        state_change: switch_state_change_hook_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_event_hook_add_state_run(
        session: *mut switch_core_session_t,
        state_run: switch_state_run_hook_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_event_hook_add_read_frame(
        session: *mut switch_core_session_t,
        read_frame: switch_read_frame_hook_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_event_hook_add_write_frame(
        session: *mut switch_core_session_t,
        write_frame: switch_write_frame_hook_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_event_hook_add_video_read_frame(
        session: *mut switch_core_session_t,
        video_read_frame: switch_video_read_frame_hook_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_event_hook_add_video_write_frame(
        session: *mut switch_core_session_t,
        video_write_frame: switch_video_write_frame_hook_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_event_hook_add_text_read_frame(
        session: *mut switch_core_session_t,
        text_read_frame: switch_text_read_frame_hook_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_event_hook_add_text_write_frame(
        session: *mut switch_core_session_t,
        text_write_frame: switch_text_write_frame_hook_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_event_hook_add_kill_channel(
        session: *mut switch_core_session_t,
        kill_channel: switch_kill_channel_hook_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_event_hook_add_send_dtmf(
        session: *mut switch_core_session_t,
        send_dtmf: switch_send_dtmf_hook_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_event_hook_add_recv_dtmf(
        session: *mut switch_core_session_t,
        recv_dtmf: switch_recv_dtmf_hook_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_event_hook_remove_outgoing_channel(
        session: *mut switch_core_session_t,
        outgoing_channel: switch_outgoing_channel_hook_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_event_hook_remove_receive_message(
        session: *mut switch_core_session_t,
        receive_message: switch_receive_message_hook_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_event_hook_remove_receive_event(
        session: *mut switch_core_session_t,
        receive_event: switch_receive_event_hook_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_event_hook_remove_state_change(
        session: *mut switch_core_session_t,
        state_change: switch_state_change_hook_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_event_hook_remove_state_run(
        session: *mut switch_core_session_t,
        state_run: switch_state_run_hook_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_event_hook_remove_read_frame(
        session: *mut switch_core_session_t,
        read_frame: switch_read_frame_hook_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_event_hook_remove_write_frame(
        session: *mut switch_core_session_t,
        write_frame: switch_write_frame_hook_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_event_hook_remove_video_read_frame(
        session: *mut switch_core_session_t,
        video_read_frame: switch_video_read_frame_hook_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_event_hook_remove_video_write_frame(
        session: *mut switch_core_session_t,
        video_write_frame: switch_video_write_frame_hook_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_event_hook_remove_text_read_frame(
        session: *mut switch_core_session_t,
        text_read_frame: switch_text_read_frame_hook_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_event_hook_remove_text_write_frame(
        session: *mut switch_core_session_t,
        text_write_frame: switch_text_write_frame_hook_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_event_hook_remove_kill_channel(
        session: *mut switch_core_session_t,
        kill_channel: switch_kill_channel_hook_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_event_hook_remove_send_dtmf(
        session: *mut switch_core_session_t,
        send_dtmf: switch_send_dtmf_hook_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_event_hook_remove_recv_dtmf(
        session: *mut switch_core_session_t,
        recv_dtmf: switch_recv_dtmf_hook_t,
    ) -> switch_status_t;
}
#[doc = "\\defgroup sched1 Scheduler\n\\ingroup core1\n\\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_scheduler_task {
    pub created: i64,
    pub runtime: i64,
    pub cmd_id: u32,
    pub repeat: u32,
    pub group: *mut ::std::os::raw::c_char,
    pub cmd_arg: *mut ::std::os::raw::c_void,
    pub task_id: u32,
    pub hash: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_switch_scheduler_task() {
    const UNINIT: ::std::mem::MaybeUninit<switch_scheduler_task> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_scheduler_task>(),
        56usize,
        concat!("Size of: ", stringify!(switch_scheduler_task))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_scheduler_task>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_scheduler_task))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).created) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_scheduler_task),
            "::",
            stringify!(created)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).runtime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_scheduler_task),
            "::",
            stringify!(runtime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_scheduler_task),
            "::",
            stringify!(cmd_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).repeat) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_scheduler_task),
            "::",
            stringify!(repeat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).group) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_scheduler_task),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd_arg) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_scheduler_task),
            "::",
            stringify!(cmd_arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).task_id) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_scheduler_task),
            "::",
            stringify!(task_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_scheduler_task),
            "::",
            stringify!(hash)
        )
    );
}
extern "C" {
    #[doc = "\\brief Schedule a task in the future\n\\param task_runtime the time in epoch seconds to execute the task.\n\\param func the callback function to execute when the task is executed.\n\\param desc an arbitrary description of the task.\n\\param group a group id tag to link multiple tasks to a single entity.\n\\param cmd_id an arbitrary index number be used in the callback.\n\\param cmd_arg user data to be passed to the callback.\n\\param flags flags to alter behaviour\n\\return the id of the task"]
    pub fn switch_scheduler_add_task(
        task_runtime: time_t,
        func: switch_scheduler_func_t,
        desc: *const ::std::os::raw::c_char,
        group: *const ::std::os::raw::c_char,
        cmd_id: u32,
        cmd_arg: *mut ::std::os::raw::c_void,
        flags: switch_scheduler_flag_t,
    ) -> u32;
}
extern "C" {
    #[doc = "\\brief Schedule a task in the future\n\\param task_runtime the time in epoch seconds to execute the task.\n\\param func the callback function to execute when the task is executed.\n\\param desc an arbitrary description of the task.\n\\param group a group id tag to link multiple tasks to a single entity.\n\\param cmd_id an arbitrary index number be used in the callback.\n\\param cmd_arg user data to be passed to the callback.\n\\param flags flags to alter behaviour\n\\param task_id pointer to put the id of the task to\n\\return the id of the task"]
    pub fn switch_scheduler_add_task_ex(
        task_runtime: time_t,
        func: switch_scheduler_func_t,
        desc: *const ::std::os::raw::c_char,
        group: *const ::std::os::raw::c_char,
        cmd_id: u32,
        cmd_arg: *mut ::std::os::raw::c_void,
        flags: switch_scheduler_flag_t,
        task_id: *mut u32,
    ) -> u32;
}
extern "C" {
    #[doc = "\\brief Delete a scheduled task\n\\param task_id the id of the task\n\\return the number of jobs deleted"]
    pub fn switch_scheduler_del_task_id(task_id: u32) -> u32;
}
extern "C" {
    #[doc = "\\brief Delete a scheduled task based on the group name\n\\param group the group name\n\\return the number of jobs deleted"]
    pub fn switch_scheduler_del_task_group(group: *const ::std::os::raw::c_char) -> u32;
}
extern "C" {
    #[doc = "\\brief Start the scheduler system"]
    pub fn switch_scheduler_task_thread_start();
}
extern "C" {
    #[doc = "\\brief Stop the scheduler system"]
    pub fn switch_scheduler_task_thread_stop();
}
#[doc = " \\brief A simple file handle representing an open configuration file"]
pub type switch_config_t = switch_config;
#[doc = " \\brief A simple file handle representing an open configuration file"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_config {
    #[doc = " FILE stream buffer to the opened file"]
    pub file: *mut FILE,
    #[doc = " path to the file"]
    pub path: [::std::os::raw::c_char; 512usize],
    #[doc = " current category"]
    pub category: [::std::os::raw::c_char; 256usize],
    #[doc = " current section"]
    pub section: [::std::os::raw::c_char; 256usize],
    #[doc = " buffer of current line being read"]
    pub buf: [::std::os::raw::c_char; 1024usize],
    #[doc = " current line number in file"]
    pub lineno: ::std::os::raw::c_int,
    #[doc = " current category number in file"]
    pub catno: ::std::os::raw::c_int,
    #[doc = " current section number in file"]
    pub sectno: ::std::os::raw::c_int,
    pub lockto: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_switch_config() {
    const UNINIT: ::std::mem::MaybeUninit<switch_config> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_config>(),
        2072usize,
        concat!("Size of: ", stringify!(switch_config))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_config>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_config))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_config),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_config),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).category) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_config),
            "::",
            stringify!(category)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).section) as usize - ptr as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_config),
            "::",
            stringify!(section)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_config),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lineno) as usize - ptr as usize },
        2056usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_config),
            "::",
            stringify!(lineno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).catno) as usize - ptr as usize },
        2060usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_config),
            "::",
            stringify!(catno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sectno) as usize - ptr as usize },
        2064usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_config),
            "::",
            stringify!(sectno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lockto) as usize - ptr as usize },
        2068usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_config),
            "::",
            stringify!(lockto)
        )
    );
}
extern "C" {
    #[doc = "\\brief Open a configuration file\n\\param cfg (switch_config_t *) config handle to use\n\\param file_path path to the file\n\\return 1 (true) on success 0 (false) on failure"]
    pub fn switch_config_open_file(
        cfg: *mut switch_config_t,
        file_path: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Close a previously opened configuration file\n\\param cfg (switch_config_t *) config handle to use"]
    pub fn switch_config_close_file(cfg: *mut switch_config_t);
}
extern "C" {
    #[doc = "\\brief Retrieve next name/value pair from configuration file\n\\param cfg (switch_config_t *) config handle to use\n\\param var pointer to aim at the new variable name\n\\param val pointer to aim at the new value"]
    pub fn switch_config_next_pair(
        cfg: *mut switch_config_t,
        var: *mut *mut ::std::os::raw::c_char,
        val: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub type switch_packetizer_t = ::std::os::raw::c_void;
pub const switch_packetizer_bitstream_t_SPT_H264_BITSTREAM: switch_packetizer_bitstream_t = 0;
pub const switch_packetizer_bitstream_t_SPT_H264_SIZED_BITSTREAM: switch_packetizer_bitstream_t = 1;
pub const switch_packetizer_bitstream_t_SPT_H264_SIGNALE_NALU: switch_packetizer_bitstream_t = 2;
pub const switch_packetizer_bitstream_t_SPT_VP8_BITSTREAM: switch_packetizer_bitstream_t = 3;
pub const switch_packetizer_bitstream_t_SPT_VP9_BITSTREAM: switch_packetizer_bitstream_t = 4;
pub const switch_packetizer_bitstream_t_SPT_H265_BITSTREAM: switch_packetizer_bitstream_t = 5;
pub const switch_packetizer_bitstream_t_SPT_AV1: switch_packetizer_bitstream_t = 6;
pub const switch_packetizer_bitstream_t_SPT_INVALID_STREAM: switch_packetizer_bitstream_t = 7;
pub type switch_packetizer_bitstream_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn switch_packetizer_create(
        type_: switch_packetizer_bitstream_t,
        slice_size: u32,
    ) -> *mut switch_packetizer_t;
}
extern "C" {
    pub fn switch_packetizer_set_debug(
        packetizer: *mut switch_packetizer_t,
        debug_evel: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn switch_packetizer_feed(
        packetizer: *mut switch_packetizer_t,
        data: *mut ::std::os::raw::c_void,
        size: u32,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_packetizer_feed_extradata(
        packetizer: *mut switch_packetizer_t,
        data: *mut ::std::os::raw::c_void,
        size: u32,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_packetizer_read(
        packetizer: *mut switch_packetizer_t,
        frame: *mut switch_frame_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_packetizer_close(packetizer: *mut *mut switch_packetizer_t);
}
pub const switch_nat_type_t_SWITCH_NAT_TYPE_NONE: switch_nat_type_t = 0;
pub const switch_nat_type_t_SWITCH_NAT_TYPE_PMP: switch_nat_type_t = 1;
pub const switch_nat_type_t_SWITCH_NAT_TYPE_UPNP: switch_nat_type_t = 2;
pub type switch_nat_type_t = ::std::os::raw::c_uint;
pub const switch_nat_ip_proto_t_SWITCH_NAT_UDP: switch_nat_ip_proto_t = 0;
pub const switch_nat_ip_proto_t_SWITCH_NAT_TCP: switch_nat_ip_proto_t = 1;
pub type switch_nat_ip_proto_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn switch_nat_get_type() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Initilize the NAT Traversal System\n\\param pool the memory pool to use for long term allocations\n\\note Generally called by the core_init"]
    pub fn switch_nat_init(pool: *mut switch_memory_pool_t, mapping: switch_bool_t);
}
extern "C" {
    #[doc = "\\brief Initilize the rest of the NAT Traversal System\n\\note nat_init is called prior to some other modules being loaded.\nThis method allows us to init the rest of the NAT system."]
    pub fn switch_nat_late_init();
}
extern "C" {
    #[doc = "\\brief Shuts down the NAT Traversal System"]
    pub fn switch_nat_shutdown();
}
extern "C" {
    #[doc = "\\brief Returns a list of nat mappings and other status info\n\\note  caller must free the string"]
    pub fn switch_nat_status() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Republishes the nap mappings"]
    pub fn switch_nat_republish();
}
extern "C" {
    #[doc = "\\brief re-initializes NAT subsystem"]
    pub fn switch_nat_reinit();
}
extern "C" {
    #[doc = "\\brief Update the setting if port mapping will be created"]
    pub fn switch_nat_set_mapping(mapping: switch_bool_t);
}
extern "C" {
    #[doc = "\\brief Maps a port through the NAT Traversal System\n\\param port Internal port to map\n\\param proto Protocol\n\\param external_port [out] Mapped external port\n\\param sticky make the mapping permanent"]
    pub fn switch_nat_add_mapping(
        port: switch_port_t,
        proto: switch_nat_ip_proto_t,
        external_port: *mut switch_port_t,
        sticky: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Has the NAT subsystem been initialized"]
    pub fn switch_nat_is_initialized() -> switch_bool_t;
}
extern "C" {
    #[doc = "\\brief Deletes a NAT mapping\n\\param proto Protocol"]
    pub fn switch_nat_del_mapping(
        port: switch_port_t,
        proto: switch_nat_ip_proto_t,
    ) -> switch_status_t;
}
pub type switch_odbc_statement_handle_t = *mut ::std::os::raw::c_void;
pub const switch_odbc_state_t_SWITCH_ODBC_STATE_INIT: switch_odbc_state_t = 0;
pub const switch_odbc_state_t_SWITCH_ODBC_STATE_DOWN: switch_odbc_state_t = 1;
pub const switch_odbc_state_t_SWITCH_ODBC_STATE_CONNECTED: switch_odbc_state_t = 2;
pub const switch_odbc_state_t_SWITCH_ODBC_STATE_ERROR: switch_odbc_state_t = 3;
pub type switch_odbc_state_t = ::std::os::raw::c_uint;
pub const switch_odbc_status_t_SWITCH_ODBC_SUCCESS: switch_odbc_status_t = 0;
pub const switch_odbc_status_t_SWITCH_ODBC_FAIL: switch_odbc_status_t = -1;
pub type switch_odbc_status_t = ::std::os::raw::c_int;
extern "C" {
    pub fn switch_odbc_skip_autocommit_flip();
}
extern "C" {
    pub fn switch_odbc_handle_new(
        dsn: *const ::std::os::raw::c_char,
        username: *const ::std::os::raw::c_char,
        password: *const ::std::os::raw::c_char,
    ) -> *mut switch_odbc_handle_t;
}
extern "C" {
    pub fn switch_odbc_set_num_retries(
        handle: *mut switch_odbc_handle_t,
        num_retries: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn switch_odbc_handle_disconnect(handle: *mut switch_odbc_handle_t)
        -> switch_odbc_status_t;
}
extern "C" {
    pub fn switch_odbc_handle_connect(handle: *mut switch_odbc_handle_t) -> switch_odbc_status_t;
}
extern "C" {
    pub fn switch_odbc_handle_destroy(handlep: *mut *mut switch_odbc_handle_t);
}
extern "C" {
    pub fn switch_odbc_handle_get_state(handle: *mut switch_odbc_handle_t) -> switch_odbc_state_t;
}
extern "C" {
    pub fn switch_odbc_handle_exec(
        handle: *mut switch_odbc_handle_t,
        sql: *const ::std::os::raw::c_char,
        rstmt: *mut switch_odbc_statement_handle_t,
        err: *mut *mut ::std::os::raw::c_char,
    ) -> switch_odbc_status_t;
}
extern "C" {
    pub fn switch_odbc_handle_exec_string(
        handle: *mut switch_odbc_handle_t,
        sql: *const ::std::os::raw::c_char,
        resbuf: *mut ::std::os::raw::c_char,
        len: usize,
        err: *mut *mut ::std::os::raw::c_char,
    ) -> switch_odbc_status_t;
}
extern "C" {
    pub fn switch_odbc_available() -> switch_bool_t;
}
extern "C" {
    pub fn switch_odbc_SQLSetAutoCommitAttr(
        handle: *mut switch_odbc_handle_t,
        on: switch_bool_t,
    ) -> switch_odbc_status_t;
}
extern "C" {
    pub fn switch_odbc_SQLEndTran(
        handle: *mut switch_odbc_handle_t,
        commit: switch_bool_t,
    ) -> switch_odbc_status_t;
}
extern "C" {
    pub fn switch_odbc_statement_handle_free(
        stmt: *mut switch_odbc_statement_handle_t,
    ) -> switch_odbc_status_t;
}
extern "C" {
    #[doc = "\\brief Execute the sql query and issue a callback for each row returned\n\\param file the file from which this function is called\n\\param func the function from which this function is called\n\\param line the line from which this function is called\n\\param handle the ODBC handle\n\\param sql the sql string to execute\n\\param callback the callback function to execute\n\\param pdata the state data passed on each callback invocation\n\\return SWITCH_STATUS_SUCCESS if the operation was successful\n\\note none"]
    pub fn switch_odbc_handle_callback_exec_detailed(
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        handle: *mut switch_odbc_handle_t,
        sql: *const ::std::os::raw::c_char,
        callback: switch_core_db_callback_func_t,
        pdata: *mut ::std::os::raw::c_void,
        err: *mut *mut ::std::os::raw::c_char,
    ) -> switch_odbc_status_t;
}
extern "C" {
    pub fn switch_odbc_handle_get_error(
        handle: *mut switch_odbc_handle_t,
        stmt: switch_odbc_statement_handle_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_odbc_handle_affected_rows(
        handle: *mut switch_odbc_handle_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Initilize the LIMIT Core System\n\\param pool the memory pool to use for long term allocations\n\\note Generally called by the core_init"]
    pub fn switch_limit_init(pool: *mut switch_memory_pool_t);
}
extern "C" {
    #[doc = "\\brief Increment resource.\n\\param backend to use\n\\param realm\n\\param resource\n\\param max - 0 means no limit, just count\n\\param interval - 0 means no interval\n\\return true/false - true ok, false over limit"]
    pub fn switch_limit_incr(
        backend: *const ::std::os::raw::c_char,
        session: *mut switch_core_session_t,
        realm: *const ::std::os::raw::c_char,
        resource: *const ::std::os::raw::c_char,
        max: ::std::os::raw::c_int,
        interval: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief Release resource.\n\\param backend to use\n\\param realm\n\\param resource\n\\return true/false - true ok, false over limit"]
    pub fn switch_limit_release(
        backend: *const ::std::os::raw::c_char,
        session: *mut switch_core_session_t,
        realm: *const ::std::os::raw::c_char,
        resource: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief get usage count for resource\n\\param backend to use\n\\param realm\n\\param resource\n\\param rcount - output paramter, rate counter"]
    pub fn switch_limit_usage(
        backend: *const ::std::os::raw::c_char,
        realm: *const ::std::os::raw::c_char,
        resource: *const ::std::os::raw::c_char,
        rcount: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief reset interval usage counter for a given resource\n\\param backend\n\\param realm\n\\param resource"]
    pub fn switch_limit_interval_reset(
        backend: *const ::std::os::raw::c_char,
        realm: *const ::std::os::raw::c_char,
        resource: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief reset all usage counters\n\\param backend to use"]
    pub fn switch_limit_reset(backend: *const ::std::os::raw::c_char) -> switch_status_t;
}
extern "C" {
    #[doc = "\\brief fire event for limit usage\n\\param backend to use\n\\param realm\n\\param resource\n\\param usage\n\\param rate\n\\param max\n\\param ratemax"]
    pub fn switch_limit_fire_event(
        backend: *const ::std::os::raw::c_char,
        realm: *const ::std::os::raw::c_char,
        resource: *const ::std::os::raw::c_char,
        usage: u32,
        rate: u32,
        max: u32,
        ratemax: u32,
    );
}
extern "C" {
    #[doc = "\\brief retrieve arbitrary status information\n\\param backend to use\n\\note caller must free returned value"]
    pub fn switch_limit_status(
        backend: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub const MSRP_ST_WAIT_HEADER: _bindgen_ty_1 = 0;
pub const MSRP_ST_PARSE_HEADER: _bindgen_ty_1 = 1;
pub const MSRP_ST_WAIT_BODY: _bindgen_ty_1 = 2;
pub const MSRP_ST_DONE: _bindgen_ty_1 = 3;
pub const MSRP_ST_ERROR: _bindgen_ty_1 = 4;
pub const MSRP_METHOD_REPLY: _bindgen_ty_1 = 5;
pub const MSRP_METHOD_SEND: _bindgen_ty_1 = 6;
pub const MSRP_METHOD_AUTH: _bindgen_ty_1 = 7;
pub const MSRP_METHOD_REPORT: _bindgen_ty_1 = 8;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const switch_msrp_header_type_t_MSRP_H_FROM_PATH: switch_msrp_header_type_t = 0;
pub const switch_msrp_header_type_t_MSRP_H_TO_PATH: switch_msrp_header_type_t = 1;
pub const switch_msrp_header_type_t_MSRP_H_MESSAGE_ID: switch_msrp_header_type_t = 2;
pub const switch_msrp_header_type_t_MSRP_H_CONTENT_TYPE: switch_msrp_header_type_t = 3;
pub const switch_msrp_header_type_t_MSRP_H_SUCCESS_REPORT: switch_msrp_header_type_t = 4;
pub const switch_msrp_header_type_t_MSRP_H_FAILURE_REPORT: switch_msrp_header_type_t = 5;
pub const switch_msrp_header_type_t_MSRP_H_STATUS: switch_msrp_header_type_t = 6;
pub const switch_msrp_header_type_t_MSRP_H_KEEPALIVE: switch_msrp_header_type_t = 7;
pub const switch_msrp_header_type_t_MSRP_H_TRASACTION_ID: switch_msrp_header_type_t = 8;
pub const switch_msrp_header_type_t_MSRP_H_DELIMITER: switch_msrp_header_type_t = 9;
pub const switch_msrp_header_type_t_MSRP_H_CODE_DESCRIPTION: switch_msrp_header_type_t = 10;
pub const switch_msrp_header_type_t_MSRP_H_UNKNOWN: switch_msrp_header_type_t = 11;
pub type switch_msrp_header_type_t = ::std::os::raw::c_uint;
pub type switch_msrp_session_t = switch_msrp_session_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msrp_client_socket_s {
    _unused: [u8; 0],
}
pub type switch_msrp_client_socket_t = msrp_client_socket_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msrp_socket_s {
    _unused: [u8; 0],
}
pub type switch_msrp_socket_t = msrp_socket_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msrp_msg_s {
    pub state: ::std::os::raw::c_int,
    pub method: ::std::os::raw::c_int,
    pub headers: *mut switch_event_t,
    pub transaction_id: *const ::std::os::raw::c_char,
    pub delimiter: *const ::std::os::raw::c_char,
    pub code_number: ::std::os::raw::c_int,
    pub code_description: *const ::std::os::raw::c_char,
    pub byte_start: switch_size_t,
    pub byte_end: switch_size_t,
    pub bytes: switch_size_t,
    pub payload_bytes: switch_size_t,
    pub accumulated_bytes: switch_size_t,
    pub range_star: ::std::os::raw::c_int,
    pub last_p: *mut ::std::os::raw::c_char,
    pub payload: *mut ::std::os::raw::c_char,
    pub next: *mut msrp_msg_s,
}
#[test]
fn bindgen_test_layout_msrp_msg_s() {
    const UNINIT: ::std::mem::MaybeUninit<msrp_msg_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<msrp_msg_s>(),
        120usize,
        concat!("Size of: ", stringify!(msrp_msg_s))
    );
    assert_eq!(
        ::std::mem::align_of::<msrp_msg_s>(),
        8usize,
        concat!("Alignment of ", stringify!(msrp_msg_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msrp_msg_s),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(msrp_msg_s),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).headers) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msrp_msg_s),
            "::",
            stringify!(headers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transaction_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msrp_msg_s),
            "::",
            stringify!(transaction_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delimiter) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msrp_msg_s),
            "::",
            stringify!(delimiter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).code_number) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(msrp_msg_s),
            "::",
            stringify!(code_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).code_description) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(msrp_msg_s),
            "::",
            stringify!(code_description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).byte_start) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(msrp_msg_s),
            "::",
            stringify!(byte_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).byte_end) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(msrp_msg_s),
            "::",
            stringify!(byte_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(msrp_msg_s),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).payload_bytes) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(msrp_msg_s),
            "::",
            stringify!(payload_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accumulated_bytes) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(msrp_msg_s),
            "::",
            stringify!(accumulated_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range_star) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(msrp_msg_s),
            "::",
            stringify!(range_star)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_p) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(msrp_msg_s),
            "::",
            stringify!(last_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).payload) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(msrp_msg_s),
            "::",
            stringify!(payload)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(msrp_msg_s),
            "::",
            stringify!(next)
        )
    );
}
pub type switch_msrp_msg_t = msrp_msg_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_msrp_session_s {
    pub pool: *mut switch_memory_pool_t,
    pub secure: ::std::os::raw::c_int,
    pub active: ::std::os::raw::c_int,
    pub remote_path: *mut ::std::os::raw::c_char,
    pub remote_accept_types: *mut ::std::os::raw::c_char,
    pub remote_accept_wrapped_types: *mut ::std::os::raw::c_char,
    pub remote_setup: *mut ::std::os::raw::c_char,
    pub remote_file_selector: *mut ::std::os::raw::c_char,
    pub local_path: *mut ::std::os::raw::c_char,
    pub local_accept_types: *mut ::std::os::raw::c_char,
    pub local_accept_wrapped_types: *mut ::std::os::raw::c_char,
    pub local_setup: *mut ::std::os::raw::c_char,
    pub local_file_selector: *mut ::std::os::raw::c_char,
    pub local_port: ::std::os::raw::c_int,
    pub call_id: *mut ::std::os::raw::c_char,
    pub msrp_msg: *mut switch_msrp_msg_t,
    pub last_msg: *mut switch_msrp_msg_t,
    pub mutex: *mut switch_mutex_t,
    pub msrp_msg_buffer_size: switch_size_t,
    pub msrp_msg_count: switch_size_t,
    pub msock: *mut switch_msrp_socket_t,
    pub csock: *mut switch_msrp_client_socket_t,
    pub frame: switch_frame_t,
    pub frame_data: [u8; 16384usize],
    pub running: ::std::os::raw::c_int,
    pub user_data: *mut ::std::os::raw::c_void,
    pub send_queue: *mut switch_queue_t,
}
#[test]
fn bindgen_test_layout_switch_msrp_session_s() {
    const UNINIT: ::std::mem::MaybeUninit<switch_msrp_session_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_msrp_session_s>(),
        16728usize,
        concat!("Size of: ", stringify!(switch_msrp_session_s))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_msrp_session_s>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_msrp_session_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_msrp_session_s),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).secure) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_msrp_session_s),
            "::",
            stringify!(secure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).active) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_msrp_session_s),
            "::",
            stringify!(active)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_path) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_msrp_session_s),
            "::",
            stringify!(remote_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_accept_types) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_msrp_session_s),
            "::",
            stringify!(remote_accept_types)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_accept_wrapped_types) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_msrp_session_s),
            "::",
            stringify!(remote_accept_wrapped_types)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_setup) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_msrp_session_s),
            "::",
            stringify!(remote_setup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_file_selector) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_msrp_session_s),
            "::",
            stringify!(remote_file_selector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_path) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_msrp_session_s),
            "::",
            stringify!(local_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_accept_types) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_msrp_session_s),
            "::",
            stringify!(local_accept_types)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_accept_wrapped_types) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_msrp_session_s),
            "::",
            stringify!(local_accept_wrapped_types)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_setup) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_msrp_session_s),
            "::",
            stringify!(local_setup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_file_selector) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_msrp_session_s),
            "::",
            stringify!(local_file_selector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_port) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_msrp_session_s),
            "::",
            stringify!(local_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).call_id) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_msrp_session_s),
            "::",
            stringify!(call_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msrp_msg) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_msrp_session_s),
            "::",
            stringify!(msrp_msg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_msg) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_msrp_session_s),
            "::",
            stringify!(last_msg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_msrp_session_s),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msrp_msg_buffer_size) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_msrp_session_s),
            "::",
            stringify!(msrp_msg_buffer_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msrp_msg_count) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_msrp_session_s),
            "::",
            stringify!(msrp_msg_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msock) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_msrp_session_s),
            "::",
            stringify!(msock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).csock) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_msrp_session_s),
            "::",
            stringify!(csock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_msrp_session_s),
            "::",
            stringify!(frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_data) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_msrp_session_s),
            "::",
            stringify!(frame_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).running) as usize - ptr as usize },
        16704usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_msrp_session_s),
            "::",
            stringify!(running)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        16712usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_msrp_session_s),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).send_queue) as usize - ptr as usize },
        16720usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_msrp_session_s),
            "::",
            stringify!(send_queue)
        )
    );
}
extern "C" {
    pub fn switch_msrp_init() -> switch_status_t;
}
extern "C" {
    pub fn switch_msrp_destroy() -> switch_status_t;
}
extern "C" {
    pub fn switch_msrp_session_new(
        pool: *mut switch_memory_pool_t,
        call_id: *const ::std::os::raw::c_char,
        secure: switch_bool_t,
    ) -> *mut switch_msrp_session_t;
}
extern "C" {
    pub fn switch_msrp_session_destroy(ms: *mut *mut switch_msrp_session_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_msrp_session_pop_msg(ms: *mut switch_msrp_session_t) -> *mut switch_msrp_msg_t;
}
extern "C" {
    pub fn switch_msrp_perform_send(
        ms: *mut switch_msrp_session_t,
        msg: *mut switch_msrp_msg_t,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_msrp_start_client(msrp_session: *mut switch_msrp_session_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_msrp_listen_ip() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_msrp_msg_create() -> *mut switch_msrp_msg_t;
}
extern "C" {
    pub fn switch_msrp_msg_destroy(msg: *mut *mut switch_msrp_msg_t);
}
extern "C" {
    pub fn switch_msrp_load_apis_and_applications(
        moudle_interface: *mut *mut switch_loadable_module_interface_t,
    );
}
extern "C" {
    pub fn switch_msrp_msg_get_header(
        msrp_msg: *mut switch_msrp_msg_t,
        htype: switch_msrp_header_type_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_msrp_msg_add_header(
        msrp_msg: *mut switch_msrp_msg_t,
        htype: switch_msrp_header_type_t,
        fmt: *mut ::std::os::raw::c_char,
        ...
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_msrp_msg_set_payload(
        msrp_msg: *mut switch_msrp_msg_t,
        buf: *const ::std::os::raw::c_char,
        payload_bytes: switch_size_t,
    );
}
extern "C" {
    pub fn switch_msrp_header_name(htype: switch_msrp_header_type_t)
        -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_msrp_msg_dup(msg: *mut switch_msrp_msg_t) -> *mut switch_msrp_msg_t;
}
pub const switch_core_media_dtmf_t_DTMF_AUTO: switch_core_media_dtmf_t = 0;
pub const switch_core_media_dtmf_t_DTMF_2833: switch_core_media_dtmf_t = 1;
pub const switch_core_media_dtmf_t_DTMF_INFO: switch_core_media_dtmf_t = 2;
pub const switch_core_media_dtmf_t_DTMF_NONE: switch_core_media_dtmf_t = 3;
pub type switch_core_media_dtmf_t = ::std::os::raw::c_uint;
pub const switch_core_media_avp_secure_t_AVP_NO_SECURE: switch_core_media_avp_secure_t = 0;
pub const switch_core_media_avp_secure_t_AVP_SECURE: switch_core_media_avp_secure_t = 1;
pub const switch_core_media_avp_secure_t_AVP_UNDEFINED: switch_core_media_avp_secure_t = 2;
pub type switch_core_media_avp_secure_t = ::std::os::raw::c_uint;
pub const switch_core_media_NDLB_t_SM_NDLB_ALLOW_BAD_IANANAME: switch_core_media_NDLB_t = 1;
pub const switch_core_media_NDLB_t_SM_NDLB_ALLOW_NONDUP_SDP: switch_core_media_NDLB_t = 2;
pub const switch_core_media_NDLB_t_SM_NDLB_ALLOW_CRYPTO_IN_AVP: switch_core_media_NDLB_t = 4;
pub const switch_core_media_NDLB_t_SM_NDLB_DISABLE_SRTP_AUTH: switch_core_media_NDLB_t = 8;
pub const switch_core_media_NDLB_t_SM_NDLB_SENDRECV_IN_SESSION: switch_core_media_NDLB_t = 16;
pub const switch_core_media_NDLB_t_SM_NDLB_NEVER_PATCH_REINVITE: switch_core_media_NDLB_t = 32;
pub type switch_core_media_NDLB_t = ::std::os::raw::c_uint;
pub const switch_core_media_flag_t_SCMF_RUNNING: switch_core_media_flag_t = 0;
pub const switch_core_media_flag_t_SCMF_DISABLE_TRANSCODING: switch_core_media_flag_t = 1;
pub const switch_core_media_flag_t_SCMF_AUTOFIX_TIMING: switch_core_media_flag_t = 2;
pub const switch_core_media_flag_t_SCMF_CODEC_GREEDY: switch_core_media_flag_t = 3;
pub const switch_core_media_flag_t_SCMF_CODEC_SCROOGE: switch_core_media_flag_t = 4;
pub const switch_core_media_flag_t_SCMF_DISABLE_HOLD: switch_core_media_flag_t = 5;
pub const switch_core_media_flag_t_SCMF_SUPPRESS_CNG: switch_core_media_flag_t = 6;
pub const switch_core_media_flag_t_SCMF_DISABLE_RTP_AUTOADJ: switch_core_media_flag_t = 7;
pub const switch_core_media_flag_t_SCMF_PASS_RFC2833: switch_core_media_flag_t = 8;
pub const switch_core_media_flag_t_SCMF_AUTOFLUSH: switch_core_media_flag_t = 9;
pub const switch_core_media_flag_t_SCMF_REWRITE_TIMESTAMPS: switch_core_media_flag_t = 10;
pub const switch_core_media_flag_t_SCMF_RTP_AUTOFLUSH_DURING_BRIDGE: switch_core_media_flag_t = 11;
pub const switch_core_media_flag_t_SCMF_MULTI_ANSWER_AUDIO: switch_core_media_flag_t = 12;
pub const switch_core_media_flag_t_SCMF_MULTI_ANSWER_VIDEO: switch_core_media_flag_t = 13;
pub const switch_core_media_flag_t_SCMF_RECV_SDP: switch_core_media_flag_t = 14;
pub const switch_core_media_flag_t_SCMF_MAX: switch_core_media_flag_t = 15;
pub type switch_core_media_flag_t = ::std::os::raw::c_uint;
pub const STUNFLAGS_STUN_FLAG_SET: STUNFLAGS = 1;
pub const STUNFLAGS_STUN_FLAG_PING: STUNFLAGS = 2;
pub const STUNFLAGS_STUN_FLAG_FUNNY: STUNFLAGS = 4;
pub type STUNFLAGS = ::std::os::raw::c_uint;
pub const switch_core_media_vflag_t_VAD_IN: switch_core_media_vflag_t = 1;
pub const switch_core_media_vflag_t_VAD_OUT: switch_core_media_vflag_t = 2;
pub type switch_core_media_vflag_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_core_media_params_s {
    pub rtp_timeout_sec: u32,
    pub rtp_hold_timeout_sec: u32,
    pub dtmf_delay: u32,
    pub codec_flags: u32,
    pub ndlb: switch_core_media_NDLB_t,
    pub auto_rtp_bugs: switch_rtp_bug_flag_t,
    pub inbound_codec_string: *mut ::std::os::raw::c_char,
    pub outbound_codec_string: *mut ::std::os::raw::c_char,
    pub timer_name: *mut ::std::os::raw::c_char,
    pub remote_sdp_str: *mut ::std::os::raw::c_char,
    pub early_sdp: *mut ::std::os::raw::c_char,
    pub local_sdp_str: *mut ::std::os::raw::c_char,
    pub last_sdp_str: *mut ::std::os::raw::c_char,
    pub last_sdp_response: *mut ::std::os::raw::c_char,
    pub prev_sdp_str: *mut ::std::os::raw::c_char,
    pub prev_sdp_response: *mut ::std::os::raw::c_char,
    pub stun_ip: *mut ::std::os::raw::c_char,
    pub stun_port: switch_port_t,
    pub stun_flags: u32,
    pub jb_msec: *mut ::std::os::raw::c_char,
    pub vflags: switch_core_media_vflag_t,
    pub manual_rtp_bugs: switch_rtp_bug_flag_t,
    pub manual_video_rtp_bugs: switch_rtp_bug_flag_t,
    pub manual_text_rtp_bugs: switch_rtp_bug_flag_t,
    pub rtcp_audio_interval_msec: *mut ::std::os::raw::c_char,
    pub rtcp_video_interval_msec: *mut ::std::os::raw::c_char,
    pub rtcp_text_interval_msec: *mut ::std::os::raw::c_char,
    pub extrtpip: *mut ::std::os::raw::c_char,
    pub rtpip: *mut ::std::os::raw::c_char,
    pub rtpip4: *mut ::std::os::raw::c_char,
    pub rtpip6: *mut ::std::os::raw::c_char,
    pub remote_ip: *mut ::std::os::raw::c_char,
    pub remote_port: ::std::os::raw::c_int,
    pub extsipip: *mut ::std::os::raw::c_char,
    pub local_network: *mut ::std::os::raw::c_char,
    pub sipip: *mut ::std::os::raw::c_char,
    pub sdp_username: *mut ::std::os::raw::c_char,
    pub te: switch_payload_t,
    pub recv_te: switch_payload_t,
    pub te_rate: ::std::os::raw::c_ulong,
    pub cng_rate: ::std::os::raw::c_ulong,
    pub adv_sdp_audio_ip: *mut ::std::os::raw::c_char,
    pub num_codecs: ::std::os::raw::c_int,
    pub hold_laps: ::std::os::raw::c_int,
    pub dtmf_type: switch_core_media_dtmf_t,
    pub cng_pt: switch_payload_t,
    pub external_video_source: switch_bool_t,
    pub video_key_freq: u32,
    pub video_key_first: u32,
    pub video_write_thread: *mut switch_thread_t,
}
#[test]
fn bindgen_test_layout_switch_core_media_params_s() {
    const UNINIT: ::std::mem::MaybeUninit<switch_core_media_params_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<switch_core_media_params_s>(),
        320usize,
        concat!("Size of: ", stringify!(switch_core_media_params_s))
    );
    assert_eq!(
        ::std::mem::align_of::<switch_core_media_params_s>(),
        8usize,
        concat!("Alignment of ", stringify!(switch_core_media_params_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rtp_timeout_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(rtp_timeout_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rtp_hold_timeout_sec) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(rtp_hold_timeout_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dtmf_delay) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(dtmf_delay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec_flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(codec_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ndlb) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(ndlb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auto_rtp_bugs) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(auto_rtp_bugs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inbound_codec_string) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(inbound_codec_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outbound_codec_string) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(outbound_codec_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timer_name) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(timer_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_sdp_str) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(remote_sdp_str)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).early_sdp) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(early_sdp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_sdp_str) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(local_sdp_str)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_sdp_str) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(last_sdp_str)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_sdp_response) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(last_sdp_response)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev_sdp_str) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(prev_sdp_str)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev_sdp_response) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(prev_sdp_response)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stun_ip) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(stun_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stun_port) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(stun_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stun_flags) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(stun_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).jb_msec) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(jb_msec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vflags) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(vflags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).manual_rtp_bugs) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(manual_rtp_bugs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).manual_video_rtp_bugs) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(manual_video_rtp_bugs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).manual_text_rtp_bugs) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(manual_text_rtp_bugs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rtcp_audio_interval_msec) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(rtcp_audio_interval_msec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rtcp_video_interval_msec) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(rtcp_video_interval_msec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rtcp_text_interval_msec) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(rtcp_text_interval_msec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extrtpip) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(extrtpip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rtpip) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(rtpip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rtpip4) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(rtpip4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rtpip6) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(rtpip6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_ip) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(remote_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_port) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(remote_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extsipip) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(extsipip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_network) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(local_network)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sipip) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(sipip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sdp_username) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(sdp_username)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).te) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(te)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recv_te) as usize - ptr as usize },
        249usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(recv_te)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).te_rate) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(te_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cng_rate) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(cng_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adv_sdp_audio_ip) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(adv_sdp_audio_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_codecs) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(num_codecs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hold_laps) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(hold_laps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dtmf_type) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(dtmf_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cng_pt) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(cng_pt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).external_video_source) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(external_video_source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).video_key_freq) as usize - ptr as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(video_key_freq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).video_key_first) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(video_key_first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).video_write_thread) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(switch_core_media_params_s),
            "::",
            stringify!(video_write_thread)
        )
    );
}
pub type switch_core_media_params_t = switch_core_media_params_s;
extern "C" {
    pub fn switch_media_handle_create(
        smhp: *mut *mut switch_media_handle_t,
        session: *mut switch_core_session_t,
        params: *mut switch_core_media_params_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_media_handle_destroy(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_session_get_media_handle(
        session: *mut switch_core_session_t,
    ) -> *mut switch_media_handle_t;
}
extern "C" {
    pub fn switch_core_session_clear_media_handle(
        session: *mut switch_core_session_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_media_handle_ready(
        session: *mut switch_core_session_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_media_handle_set_media_flag(
        smh: *mut switch_media_handle_t,
        flag: switch_core_media_flag_t,
    );
}
extern "C" {
    pub fn switch_media_handle_clear_media_flag(
        smh: *mut switch_media_handle_t,
        flag: switch_core_media_flag_t,
    );
}
extern "C" {
    pub fn switch_media_handle_test_media_flag(
        smh: *mut switch_media_handle_t,
        flag: switch_core_media_flag_t,
    ) -> i32;
}
extern "C" {
    pub fn switch_media_handle_set_media_flags(
        smh: *mut switch_media_handle_t,
        flags: *mut switch_core_media_flag_t,
    );
}
extern "C" {
    pub fn switch_core_session_check_outgoing_crypto(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_session_local_crypto_key(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_core_session_check_incoming_crypto(
        session: *mut switch_core_session_t,
        varname: *const ::std::os::raw::c_char,
        type_: switch_media_type_t,
        crypto: *const ::std::os::raw::c_char,
        crypto_tag: ::std::os::raw::c_int,
        sdp_type: switch_sdp_type_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_core_media_get_video_fps(session: *mut switch_core_session_t) -> u32;
}
extern "C" {
    pub fn switch_core_media_set_rtp_session(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
        rtp_session: *mut switch_rtp_t,
    );
}
extern "C" {
    pub fn switch_core_media_get_rtp_session(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
    ) -> *mut switch_rtp_t;
}
extern "C" {
    pub fn switch_core_media_get_codec_string(
        session: *mut switch_core_session_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_core_media_parse_rtp_bugs(
        flag_pole: *mut switch_rtp_bug_flag_t,
        str_: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn switch_core_media_add_crypto(
        session: *mut switch_core_session_t,
        ssec: *mut switch_secure_settings_t,
        direction: switch_rtp_crypto_direction_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_extract_t38_options(
        session: *mut switch_core_session_t,
        r_sdp: *const ::std::os::raw::c_char,
    ) -> *mut switch_t38_options_t;
}
extern "C" {
    pub fn switch_core_media_toggle_hold(
        session: *mut switch_core_session_t,
        sendonly: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_core_media_reset_t38(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_media_copy_t38_options(
        t38_options: *mut switch_t38_options_t,
        session: *mut switch_core_session_t,
    );
}
extern "C" {
    pub fn switch_core_media_negotiate_sdp(
        session: *mut switch_core_session_t,
        r_sdp: *const ::std::os::raw::c_char,
        proceed: *mut u8,
        sdp_type: switch_sdp_type_t,
    ) -> u8;
}
extern "C" {
    pub fn switch_core_media_set_video_codec(
        session: *mut switch_core_session_t,
        force: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_set_codec(
        session: *mut switch_core_session_t,
        force: ::std::os::raw::c_int,
        codec_flags: u32,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_check_video_codecs(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_media_read_frame(
        session: *mut switch_core_session_t,
        frame: *mut *mut switch_frame_t,
        flags: switch_io_flag_t,
        stream_id: ::std::os::raw::c_int,
        type_: switch_media_type_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_write_frame(
        session: *mut switch_core_session_t,
        frame: *mut switch_frame_t,
        flags: switch_io_flag_t,
        stream_id: ::std::os::raw::c_int,
        type_: switch_media_type_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_check_nat(
        smh: *mut switch_media_handle_t,
        network_ip: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_core_media_choose_port(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
        force: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_choose_ports(
        session: *mut switch_core_session_t,
        audio: switch_bool_t,
        video: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_check_dtmf_type(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_media_absorb_sdp(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_media_proxy_remote_addr(
        session: *mut switch_core_session_t,
        sdp_str: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_parse_media_flags(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_media_deactivate_rtp(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_media_activate_rtp(session: *mut switch_core_session_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_ext_address_lookup(
        session: *mut switch_core_session_t,
        ip: *mut *mut ::std::os::raw::c_char,
        port: *mut switch_port_t,
        sourceip: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_process_t38_passthru(
        session: *mut switch_core_session_t,
        other_session: *mut switch_core_session_t,
        t38_options: *mut switch_t38_options_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_gen_local_sdp(
        session: *mut switch_core_session_t,
        sdp_type: switch_sdp_type_t,
        ip: *const ::std::os::raw::c_char,
        port: switch_port_t,
        sr: *const ::std::os::raw::c_char,
        force: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn switch_core_media_set_local_sdp(
        session: *mut switch_core_session_t,
        sdp_str: *const ::std::os::raw::c_char,
        dup: switch_bool_t,
    );
}
extern "C" {
    pub fn switch_core_media_patch_sdp(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_media_set_udptl_image_sdp(
        session: *mut switch_core_session_t,
        t38_options: *mut switch_t38_options_t,
        insist: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn switch_core_media_get_mparams(
        smh: *mut switch_media_handle_t,
    ) -> *mut switch_core_media_params_t;
}
extern "C" {
    pub fn switch_core_media_prepare_codecs(
        session: *mut switch_core_session_t,
        force: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_start_udptl(
        session: *mut switch_core_session_t,
        t38_options: *mut switch_t38_options_t,
    );
}
extern "C" {
    pub fn switch_core_media_hard_mute(session: *mut switch_core_session_t, on: switch_bool_t);
}
extern "C" {
    pub fn switch_core_media_gen_json_constraint(min: f32, ideal: f32, max: f32) -> *mut cJSON;
}
extern "C" {
    pub fn switch_core_media_media_params(
        session: *mut switch_core_session_t,
        json: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_receive_message(
        session: *mut switch_core_session_t,
        msg: *mut switch_core_session_message_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_break(session: *mut switch_core_session_t, type_: switch_media_type_t);
}
extern "C" {
    pub fn switch_core_media_kill_socket(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
    );
}
extern "C" {
    pub fn switch_core_media_queue_rfc2833(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
        dtmf: *const switch_dtmf_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_queue_rfc2833_in(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
        dtmf: *const switch_dtmf_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_ready(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
    ) -> u8;
}
extern "C" {
    pub fn switch_core_media_set_telephony_event(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
        te: switch_payload_t,
    );
}
extern "C" {
    pub fn switch_core_media_set_telephony_recv_event(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
        te: switch_payload_t,
    );
}
extern "C" {
    pub fn switch_core_media_stats(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
        pool: *mut switch_memory_pool_t,
    ) -> *mut switch_rtp_stats_t;
}
extern "C" {
    pub fn switch_core_media_udptl_mode(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_check_udptl_mode(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
    ) -> switch_bool_t;
}
extern "C" {
    pub fn switch_core_media_set_rtp_flag(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
        flag: switch_rtp_flag_t,
    );
}
extern "C" {
    pub fn switch_core_media_clear_rtp_flag(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
        flag: switch_rtp_flag_t,
    );
}
extern "C" {
    pub fn switch_core_media_get_jb(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
    ) -> *mut switch_jb_t;
}
extern "C" {
    pub fn switch_core_media_get_stats(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
        pool: *mut switch_memory_pool_t,
    ) -> *mut switch_rtp_stats_t;
}
extern "C" {
    pub fn switch_core_media_set_sdp_codec_string(
        session: *mut switch_core_session_t,
        r_sdp: *const ::std::os::raw::c_char,
        sdp_type: switch_sdp_type_t,
    );
}
extern "C" {
    pub fn switch_core_media_merge_sdp_codec_string(
        session: *mut switch_core_session_t,
        r_sdp: *const ::std::os::raw::c_char,
        sdp_type: switch_sdp_type_t,
        codec_string: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn switch_core_media_reset_autofix(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
    );
}
extern "C" {
    pub fn switch_core_media_check_outgoing_proxy(
        session: *mut switch_core_session_t,
        o_session: *mut switch_core_session_t,
    );
}
extern "C" {
    pub fn switch_core_media_codec_chosen(
        session: *mut switch_core_session_t,
        media: switch_media_type_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_recover_session(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_media_add_ice_acl(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
        acl_name: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_set_ice(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_media_clear_ice(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_media_pause(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_media_resume(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_media_init();
}
extern "C" {
    pub fn switch_core_media_deinit();
}
extern "C" {
    pub fn switch_core_media_set_stats(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_media_sync_stats(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_session_wake_video_thread(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_session_clear_crypto(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_session_get_payload_code(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
        iananame: *const ::std::os::raw::c_char,
        rate: u32,
        fmtp_in: *const ::std::os::raw::c_char,
        ptP: *mut switch_payload_t,
        recv_ptP: *mut switch_payload_t,
        fmtpP: *mut *mut ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_add_payload_map(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
        name: *const ::std::os::raw::c_char,
        modname: *const ::std::os::raw::c_char,
        fmtp: *const ::std::os::raw::c_char,
        sdp_type: switch_sdp_type_t,
        pt: u32,
        rate: u32,
        ptime: u32,
        channels: u32,
        negotiated: u8,
    ) -> *mut payload_map_t;
}
extern "C" {
    pub fn switch_core_media_check_autoadj(session: *mut switch_core_session_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_crypto_str2type(
        str_: *const ::std::os::raw::c_char,
    ) -> switch_rtp_crypto_key_type_t;
}
extern "C" {
    pub fn switch_core_media_crypto_type2str(
        type_: switch_rtp_crypto_key_type_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_core_media_crypto_keysalt_len(
        type_: switch_rtp_crypto_key_type_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_core_media_crypto_salt_len(
        type_: switch_rtp_crypto_key_type_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_core_media_filter_sdp(
        sdp: *const ::std::os::raw::c_char,
        cmd: *const ::std::os::raw::c_char,
        arg: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_core_media_process_sdp_filter(
        sdp: *const ::std::os::raw::c_char,
        cmd_buf: *const ::std::os::raw::c_char,
        session: *mut switch_core_session_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn switch_core_media_codec_control(
        session: *mut switch_core_session_t,
        mtype: switch_media_type_t,
        iotype: switch_io_type_t,
        cmd: switch_codec_control_command_t,
        ctype: switch_codec_control_type_t,
        cmd_data: *mut ::std::os::raw::c_void,
        atype: switch_codec_control_type_t,
        cmd_arg: *mut ::std::os::raw::c_void,
        rtype: *mut switch_codec_control_type_t,
        ret_data: *mut *mut ::std::os::raw::c_void,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_codec_get_cap(
        session: *mut switch_core_session_t,
        mtype: switch_media_type_t,
        flag: switch_codec_flag_t,
    ) -> switch_bool_t;
}
extern "C" {
    pub fn switch_core_media_get_timer(
        session: *mut switch_core_session_t,
        mtype: switch_media_type_t,
    ) -> *mut switch_timer_t;
}
extern "C" {
    pub fn switch_core_media_start_engine_function(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
        engine_function: switch_engine_function_t,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn switch_core_media_end_engine_function(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
    );
}
extern "C" {
    pub fn switch_core_session_start_video_thread(
        session: *mut switch_core_session_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_check_engine_function(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_core_session_video_reinit(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_media_read_lock_unlock(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
        lock: switch_bool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_stop_media(session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_core_session_media_flow(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
    ) -> switch_media_flow_t;
}
extern "C" {
    pub fn switch_core_media_get_vid_params(
        session: *mut switch_core_session_t,
        vid_params: *mut switch_vid_params_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_write_blank_video(session: *mut switch_core_session_t, ms: u32);
}
extern "C" {
    pub fn switch_core_media_lock_video_file(
        session: *mut switch_core_session_t,
        rw: switch_rw_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_unlock_video_file(
        session: *mut switch_core_session_t,
        rw: switch_rw_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_set_video_file(
        session: *mut switch_core_session_t,
        fh: *mut switch_file_handle_t,
        rw: switch_rw_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_get_video_file(
        session: *mut switch_core_session_t,
        rw: switch_rw_t,
    ) -> *mut switch_file_handle_t;
}
extern "C" {
    pub fn switch_core_session_in_video_thread(
        session: *mut switch_core_session_t,
    ) -> switch_bool_t;
}
extern "C" {
    pub fn switch_core_media_check_dtls(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
    ) -> switch_bool_t;
}
extern "C" {
    pub fn switch_core_media_set_outgoing_bitrate(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
        bitrate: u32,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_get_orig_bitrate(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
    ) -> u32;
}
extern "C" {
    pub fn switch_core_media_set_media_bw_mult(session: *mut switch_core_session_t, mult: f32);
}
extern "C" {
    pub fn switch_core_media_get_media_bw_mult(session: *mut switch_core_session_t) -> f32;
}
extern "C" {
    pub fn switch_core_media_reset_jb(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_wait_for_video_input_params(
        session: *mut switch_core_session_t,
        timeout_ms: u32,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_set_text_read_callback(
        session: *mut switch_core_session_t,
        func: switch_core_text_thread_callback_func_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_text_read_callback(
        session: *mut switch_core_session_t,
        frame: *mut switch_frame_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_read_text_frame(
        session: *mut switch_core_session_t,
        frame: *mut *mut switch_frame_t,
        flags: switch_io_flag_t,
        stream_id: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_write_text_frame(
        session: *mut switch_core_session_t,
        frame: *mut switch_frame_t,
        flags: switch_io_flag_t,
        stream_id: ::std::os::raw::c_int,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_rtp_text_factory_create(
        tfP: *mut *mut switch_rtp_text_factory_t,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_rtp_text_factory_destroy(
        tfP: *mut *mut switch_rtp_text_factory_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_print(
        session: *mut switch_core_session_t,
        data: *const ::std::os::raw::c_char,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_session_printf(
        session: *mut switch_core_session_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_core_media_get_msrp_session(
        session: *mut switch_core_session_t,
    ) -> *mut switch_msrp_session_t;
}
extern "C" {
    pub fn switch_core_media_set_smode(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
        smode: switch_media_flow_t,
        sdp_type: switch_sdp_type_t,
    );
}
extern "C" {
    pub fn switch_core_media_set_resolveice(resolve_ice: switch_bool_t);
}
extern "C" {
    pub fn switch_core_media_has_resolveice() -> switch_bool_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switch_rtp_engine_s {
    _unused: [u8; 0],
}
pub type switch_rtp_engine_t = switch_rtp_engine_s;
extern "C" {
    pub fn switch_core_media_get_engine(
        session: *mut switch_core_session_t,
        media_type: ::std::os::raw::c_int,
    ) -> *mut switch_rtp_engine_t;
}
extern "C" {
    pub fn switch_core_media_get_codec(
        session: *mut switch_core_session_t,
        type_: switch_media_type_t,
    ) -> *mut switch_codec_t;
}
pub const switch_jb_flag_t_SJB_QUEUE_ONLY: switch_jb_flag_t = 1;
pub type switch_jb_flag_t = ::std::os::raw::c_uint;
pub const switch_jb_type_t_SJB_VIDEO: switch_jb_type_t = 0;
pub const switch_jb_type_t_SJB_AUDIO: switch_jb_type_t = 1;
pub const switch_jb_type_t_SJB_TEXT: switch_jb_type_t = 2;
pub type switch_jb_type_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn switch_jb_create(
        jbp: *mut *mut switch_jb_t,
        type_: switch_jb_type_t,
        min_frame_len: u32,
        max_frame_len: u32,
        pool: *mut switch_memory_pool_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_jb_set_frames(
        jb: *mut switch_jb_t,
        min_frame_len: u32,
        max_frame_len: u32,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_jb_peek_frame(
        jb: *mut switch_jb_t,
        ts: u32,
        seq: u16,
        peek: ::std::os::raw::c_int,
        frame: *mut switch_frame_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_jb_get_frames(
        jb: *mut switch_jb_t,
        min_frame_len: *mut u32,
        max_frame_len: *mut u32,
        cur_frame_len: *mut u32,
        highest_frame_len: *mut u32,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_jb_destroy(jbp: *mut *mut switch_jb_t) -> switch_status_t;
}
extern "C" {
    pub fn switch_jb_reset(jb: *mut switch_jb_t);
}
extern "C" {
    pub fn switch_jb_debug_level(jb: *mut switch_jb_t, level: u8);
}
extern "C" {
    pub fn switch_jb_frame_count(jb: *mut switch_jb_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_jb_poll(jb: *mut switch_jb_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_jb_put_packet(
        jb: *mut switch_jb_t,
        packet: *mut switch_rtp_packet_t,
        len: switch_size_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_jb_get_last_read_len(jb: *mut switch_jb_t) -> switch_size_t;
}
extern "C" {
    pub fn switch_jb_get_packet(
        jb: *mut switch_jb_t,
        packet: *mut switch_rtp_packet_t,
        len: *mut switch_size_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_jb_pop_nack(jb: *mut switch_jb_t) -> u32;
}
extern "C" {
    pub fn switch_jb_get_packet_by_seq(
        jb: *mut switch_jb_t,
        seq: u16,
        packet: *mut switch_rtp_packet_t,
        len: *mut switch_size_t,
    ) -> switch_status_t;
}
extern "C" {
    pub fn switch_jb_set_session(jb: *mut switch_jb_t, session: *mut switch_core_session_t);
}
extern "C" {
    pub fn switch_jb_set_jitter_estimator(
        jb: *mut switch_jb_t,
        jitter: *mut f64,
        samples_per_frame: u32,
        samples_per_second: u32,
    );
}
extern "C" {
    pub fn switch_jb_ts_mode(jb: *mut switch_jb_t, samples_per_frame: u32, samples_per_second: u32);
}
extern "C" {
    pub fn switch_jb_set_flag(jb: *mut switch_jb_t, flag: switch_jb_flag_t);
}
extern "C" {
    pub fn switch_jb_clear_flag(jb: *mut switch_jb_t, flag: switch_jb_flag_t);
}
extern "C" {
    pub fn switch_jb_get_nack_success(jb: *mut switch_jb_t) -> u32;
}
extern "C" {
    pub fn switch_jb_get_packets_per_frame(jb: *mut switch_jb_t) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kalman_estimator_s {
    pub val_estimate_last: f32,
    pub P_last: f32,
    pub Q: f32,
    pub R: f32,
    pub K: f32,
    pub P: f32,
    pub val_estimate: f32,
    pub val_measured: f32,
}
#[test]
fn bindgen_test_layout_kalman_estimator_s() {
    const UNINIT: ::std::mem::MaybeUninit<kalman_estimator_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kalman_estimator_s>(),
        32usize,
        concat!("Size of: ", stringify!(kalman_estimator_s))
    );
    assert_eq!(
        ::std::mem::align_of::<kalman_estimator_s>(),
        4usize,
        concat!("Alignment of ", stringify!(kalman_estimator_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val_estimate_last) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kalman_estimator_s),
            "::",
            stringify!(val_estimate_last)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).P_last) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kalman_estimator_s),
            "::",
            stringify!(P_last)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Q) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kalman_estimator_s),
            "::",
            stringify!(Q)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).R) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(kalman_estimator_s),
            "::",
            stringify!(R)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).K) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kalman_estimator_s),
            "::",
            stringify!(K)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).P) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(kalman_estimator_s),
            "::",
            stringify!(P)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val_estimate) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kalman_estimator_s),
            "::",
            stringify!(val_estimate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val_measured) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(kalman_estimator_s),
            "::",
            stringify!(val_measured)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cusum_kalman_detector_s {
    pub val_estimate_last: f32,
    pub val_desired_last: f32,
    pub P_last: f32,
    pub K_last: f32,
    pub delta: f32,
    pub measurement_noise_e: f32,
    pub variance_Re: f32,
    pub measurement_noise_v: f32,
    pub variance_Rv: f32,
    pub g_last: f32,
    pub epsilon: f32,
    pub h: f32,
    pub last_average: f32,
    pub last_q: f32,
    pub N: f32,
}
#[test]
fn bindgen_test_layout_cusum_kalman_detector_s() {
    const UNINIT: ::std::mem::MaybeUninit<cusum_kalman_detector_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cusum_kalman_detector_s>(),
        60usize,
        concat!("Size of: ", stringify!(cusum_kalman_detector_s))
    );
    assert_eq!(
        ::std::mem::align_of::<cusum_kalman_detector_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cusum_kalman_detector_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val_estimate_last) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cusum_kalman_detector_s),
            "::",
            stringify!(val_estimate_last)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val_desired_last) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cusum_kalman_detector_s),
            "::",
            stringify!(val_desired_last)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).P_last) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cusum_kalman_detector_s),
            "::",
            stringify!(P_last)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).K_last) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cusum_kalman_detector_s),
            "::",
            stringify!(K_last)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delta) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cusum_kalman_detector_s),
            "::",
            stringify!(delta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).measurement_noise_e) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cusum_kalman_detector_s),
            "::",
            stringify!(measurement_noise_e)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).variance_Re) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cusum_kalman_detector_s),
            "::",
            stringify!(variance_Re)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).measurement_noise_v) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cusum_kalman_detector_s),
            "::",
            stringify!(measurement_noise_v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).variance_Rv) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cusum_kalman_detector_s),
            "::",
            stringify!(variance_Rv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_last) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cusum_kalman_detector_s),
            "::",
            stringify!(g_last)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).epsilon) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cusum_kalman_detector_s),
            "::",
            stringify!(epsilon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cusum_kalman_detector_s),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_average) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cusum_kalman_detector_s),
            "::",
            stringify!(last_average)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_q) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cusum_kalman_detector_s),
            "::",
            stringify!(last_q)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).N) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cusum_kalman_detector_s),
            "::",
            stringify!(N)
        )
    );
}
pub type kalman_estimator_t = kalman_estimator_s;
pub type cusum_kalman_detector_t = cusum_kalman_detector_s;
extern "C" {
    pub fn switch_kalman_init(est: *mut kalman_estimator_t, Q: f32, R: f32);
}
extern "C" {
    pub fn switch_kalman_cusum_init(
        detect_change: *mut cusum_kalman_detector_t,
        epsilon: f32,
        h: f32,
    ) -> switch_bool_t;
}
extern "C" {
    pub fn switch_kalman_estimate(
        est: *mut kalman_estimator_t,
        measurement: f32,
        system_model: ::std::os::raw::c_int,
    ) -> switch_bool_t;
}
extern "C" {
    pub fn switch_kalman_cusum_detect_change(
        detector: *mut cusum_kalman_detector_t,
        measurement: f32,
        rtt_avg: f32,
    ) -> switch_bool_t;
}
extern "C" {
    pub fn switch_kalman_is_slow_link(
        est_loss: *mut kalman_estimator_t,
        est_rtt: *mut kalman_estimator_t,
    ) -> switch_bool_t;
}
extern "C" {
    pub fn switch_vad_init(
        sample_rate: ::std::os::raw::c_int,
        channels: ::std::os::raw::c_int,
    ) -> *mut switch_vad_t;
}
extern "C" {
    pub fn switch_vad_set_mode(
        vad: *mut switch_vad_t,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn switch_vad_set_param(
        vad: *mut switch_vad_t,
        key: *const ::std::os::raw::c_char,
        val: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn switch_vad_process(
        vad: *mut switch_vad_t,
        data: *mut i16,
        samples: ::std::os::raw::c_uint,
    ) -> switch_vad_state_t;
}
extern "C" {
    pub fn switch_vad_get_state(vad: *mut switch_vad_t) -> switch_vad_state_t;
}
extern "C" {
    pub fn switch_vad_reset(vad: *mut switch_vad_t);
}
extern "C" {
    pub fn switch_vad_destroy(vad: *mut *mut switch_vad_t);
}
extern "C" {
    pub fn switch_vad_state2str(state: switch_vad_state_t) -> *const ::std::os::raw::c_char;
}
pub type teletone_process_t = f64;
#[doc = " \\brief An abstraction to store a tone mapping"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct teletone_tone_map_t {
    #[doc = " An array of tone frequencies"]
    pub freqs: [teletone_process_t; 18usize],
}
#[test]
fn bindgen_test_layout_teletone_tone_map_t() {
    const UNINIT: ::std::mem::MaybeUninit<teletone_tone_map_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<teletone_tone_map_t>(),
        144usize,
        concat!("Size of: ", stringify!(teletone_tone_map_t))
    );
    assert_eq!(
        ::std::mem::align_of::<teletone_tone_map_t>(),
        8usize,
        concat!("Alignment of ", stringify!(teletone_tone_map_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freqs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_tone_map_t),
            "::",
            stringify!(freqs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct teletone_dds_state {
    pub phase_rate: [u32; 4usize],
    pub scale_factor: u32,
    pub phase_accumulator: u32,
    pub tx_level: teletone_process_t,
}
#[test]
fn bindgen_test_layout_teletone_dds_state() {
    const UNINIT: ::std::mem::MaybeUninit<teletone_dds_state> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<teletone_dds_state>(),
        32usize,
        concat!("Size of: ", stringify!(teletone_dds_state))
    );
    assert_eq!(
        ::std::mem::align_of::<teletone_dds_state>(),
        8usize,
        concat!("Alignment of ", stringify!(teletone_dds_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).phase_rate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_dds_state),
            "::",
            stringify!(phase_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale_factor) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_dds_state),
            "::",
            stringify!(scale_factor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).phase_accumulator) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_dds_state),
            "::",
            stringify!(phase_accumulator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_level) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_dds_state),
            "::",
            stringify!(tx_level)
        )
    );
}
pub type teletone_dds_state_t = teletone_dds_state;
extern "C" {
    pub static mut TELETONE_SINES: [i16; 128usize];
}
#[doc = " \\file libteletone_generate.h\n\\brief Tone Generation Routines\n\nThis module is responsible for tone generation specifics"]
pub type teletone_audio_t = i16;
pub type tone_handler = ::std::option::Option<
    unsafe extern "C" fn(
        ts: *mut teletone_generation_session,
        map: *mut teletone_tone_map_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " \\brief An abstraction to store a tone generation session"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct teletone_generation_session {
    #[doc = " An array of tone mappings to character mappings"]
    pub TONES: [teletone_tone_map_t; 127usize],
    #[doc = " The number of channels the output audio should be in"]
    pub channels: ::std::os::raw::c_int,
    #[doc = " The Rate in hz of the output audio"]
    pub rate: ::std::os::raw::c_int,
    #[doc = " The duration (in samples) of the output audio"]
    pub duration: ::std::os::raw::c_int,
    #[doc = " The duration of silence to append after the initial audio is generated"]
    pub wait: ::std::os::raw::c_int,
    #[doc = " The duration (in samples) of the output audio (takes prescedence over actual duration value)"]
    pub tmp_duration: ::std::os::raw::c_int,
    #[doc = " The duration of silence to append after the initial audio is generated (takes prescedence over actual wait value)"]
    pub tmp_wait: ::std::os::raw::c_int,
    #[doc = " Number of loops to repeat a single instruction"]
    pub loops: ::std::os::raw::c_int,
    #[doc = " Number of loops to repeat the entire set of instructions"]
    pub LOOPS: ::std::os::raw::c_int,
    #[doc = " Number to mutiply total samples by to determine when to begin ascent or decent e.g. 0=beginning 4=(last 25%)"]
    pub decay_factor: f32,
    #[doc = " Direction to perform volume increase/decrease 1/-1"]
    pub decay_direction: ::std::os::raw::c_int,
    #[doc = " Number of samples between increase/decrease of volume"]
    pub decay_step: ::std::os::raw::c_int,
    #[doc = " Volume factor of the tone"]
    pub volume: f32,
    #[doc = " Debug on/off"]
    pub debug: ::std::os::raw::c_int,
    #[doc = " FILE stream to write debug data to"]
    pub debug_stream: *mut FILE,
    #[doc = " Extra user data to attach to the session"]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " Buffer for storing sample data (dynamic)"]
    pub buffer: *mut teletone_audio_t,
    #[doc = " Size of the buffer"]
    pub datalen: ::std::os::raw::c_int,
    #[doc = " In-Use size of the buffer"]
    pub samples: ::std::os::raw::c_int,
    #[doc = " Callback function called during generation"]
    pub dynamic: ::std::os::raw::c_int,
    pub handler: tone_handler,
}
#[test]
fn bindgen_test_layout_teletone_generation_session() {
    const UNINIT: ::std::mem::MaybeUninit<teletone_generation_session> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<teletone_generation_session>(),
        18392usize,
        concat!("Size of: ", stringify!(teletone_generation_session))
    );
    assert_eq!(
        ::std::mem::align_of::<teletone_generation_session>(),
        8usize,
        concat!("Alignment of ", stringify!(teletone_generation_session))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TONES) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_generation_session),
            "::",
            stringify!(TONES)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        18288usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_generation_session),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate) as usize - ptr as usize },
        18292usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_generation_session),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duration) as usize - ptr as usize },
        18296usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_generation_session),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wait) as usize - ptr as usize },
        18300usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_generation_session),
            "::",
            stringify!(wait)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tmp_duration) as usize - ptr as usize },
        18304usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_generation_session),
            "::",
            stringify!(tmp_duration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tmp_wait) as usize - ptr as usize },
        18308usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_generation_session),
            "::",
            stringify!(tmp_wait)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loops) as usize - ptr as usize },
        18312usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_generation_session),
            "::",
            stringify!(loops)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LOOPS) as usize - ptr as usize },
        18316usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_generation_session),
            "::",
            stringify!(LOOPS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decay_factor) as usize - ptr as usize },
        18320usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_generation_session),
            "::",
            stringify!(decay_factor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decay_direction) as usize - ptr as usize },
        18324usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_generation_session),
            "::",
            stringify!(decay_direction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decay_step) as usize - ptr as usize },
        18328usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_generation_session),
            "::",
            stringify!(decay_step)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).volume) as usize - ptr as usize },
        18332usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_generation_session),
            "::",
            stringify!(volume)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).debug) as usize - ptr as usize },
        18336usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_generation_session),
            "::",
            stringify!(debug)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).debug_stream) as usize - ptr as usize },
        18344usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_generation_session),
            "::",
            stringify!(debug_stream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        18352usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_generation_session),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        18360usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_generation_session),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).datalen) as usize - ptr as usize },
        18368usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_generation_session),
            "::",
            stringify!(datalen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samples) as usize - ptr as usize },
        18372usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_generation_session),
            "::",
            stringify!(samples)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic) as usize - ptr as usize },
        18376usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_generation_session),
            "::",
            stringify!(dynamic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handler) as usize - ptr as usize },
        18384usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_generation_session),
            "::",
            stringify!(handler)
        )
    );
}
#[doc = " \\brief An abstraction to store a tone generation session"]
pub type teletone_generation_session_t = teletone_generation_session;
extern "C" {
    #[doc = "\\brief Assign a set of tones to a tone_session indexed by a paticular index/character\n\\param ts the tone generation session\n\\param index the index to map the tone to\n\\param ... up to TELETONE_MAX_TONES frequencies terminated by 0.0\n\\return 0"]
    pub fn teletone_set_tone(
        ts: *mut teletone_generation_session_t,
        index: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Assign a set of tones to a single tone map\n\\param map the map to assign the tones to\n\\param ... up to TELETONE_MAX_TONES frequencies terminated by 0.0\n\\return 0"]
    pub fn teletone_set_map(map: *mut teletone_tone_map_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Initilize a tone generation session\n\\param ts the tone generation session to initilize\n\\param buflen the size of the buffer(in samples) to dynamically allocate\n\\param handler a callback function to execute when a tone generation instruction is complete\n\\param user_data optional user data to send\n\\return 0"]
    pub fn teletone_init_session(
        ts: *mut teletone_generation_session_t,
        buflen: ::std::os::raw::c_int,
        handler: tone_handler,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Free the buffer allocated by a tone generation session\n\\param ts the tone generation session to destroy\n\\return 0"]
    pub fn teletone_destroy_session(
        ts: *mut teletone_generation_session_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Execute a single tone generation instruction\n\\param ts the tone generation session to consult for parameters\n\\param map the tone mapping to use for the frequencies\n\\return 0"]
    pub fn teletone_mux_tones(
        ts: *mut teletone_generation_session_t,
        map: *mut teletone_tone_map_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Execute a tone generation script and call callbacks after each instruction\n\\param ts the tone generation session to execute on\n\\param cmd the script to execute\n\\return 0"]
    pub fn teletone_run(
        ts: *mut teletone_generation_session_t,
        cmd: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub const teletone_hit_type_t_TT_HIT_NONE: teletone_hit_type_t = 0;
pub const teletone_hit_type_t_TT_HIT_BEGIN: teletone_hit_type_t = 1;
pub const teletone_hit_type_t_TT_HIT_MIDDLE: teletone_hit_type_t = 2;
pub const teletone_hit_type_t_TT_HIT_END: teletone_hit_type_t = 3;
pub type teletone_hit_type_t = ::std::os::raw::c_uint;
#[doc = " \\brief A continer for the elements of a Goertzel Algorithm (The names are from his formula)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct teletone_goertzel_state_t {
    pub v2: f32,
    pub v3: f32,
    pub fac: f64,
}
#[test]
fn bindgen_test_layout_teletone_goertzel_state_t() {
    const UNINIT: ::std::mem::MaybeUninit<teletone_goertzel_state_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<teletone_goertzel_state_t>(),
        16usize,
        concat!("Size of: ", stringify!(teletone_goertzel_state_t))
    );
    assert_eq!(
        ::std::mem::align_of::<teletone_goertzel_state_t>(),
        8usize,
        concat!("Alignment of ", stringify!(teletone_goertzel_state_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v2) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_goertzel_state_t),
            "::",
            stringify!(v2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v3) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_goertzel_state_t),
            "::",
            stringify!(v3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fac) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_goertzel_state_t),
            "::",
            stringify!(fac)
        )
    );
}
#[doc = " \\brief A container for a DTMF detection state."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct teletone_dtmf_detect_state_t {
    pub hit1: ::std::os::raw::c_int,
    pub hit2: ::std::os::raw::c_int,
    pub hit3: ::std::os::raw::c_int,
    pub hit4: ::std::os::raw::c_int,
    pub dur: ::std::os::raw::c_int,
    pub zc: ::std::os::raw::c_int,
    pub row_out: [teletone_goertzel_state_t; 4usize],
    pub col_out: [teletone_goertzel_state_t; 4usize],
    pub row_out2nd: [teletone_goertzel_state_t; 4usize],
    pub col_out2nd: [teletone_goertzel_state_t; 4usize],
    pub energy: f32,
    pub lenergy: f32,
    pub current_sample: ::std::os::raw::c_int,
    pub digit: ::std::os::raw::c_char,
    pub current_digits: ::std::os::raw::c_int,
    pub detected_digits: ::std::os::raw::c_int,
    pub lost_digits: ::std::os::raw::c_int,
    pub digit_hits: [::std::os::raw::c_int; 16usize],
}
#[test]
fn bindgen_test_layout_teletone_dtmf_detect_state_t() {
    const UNINIT: ::std::mem::MaybeUninit<teletone_dtmf_detect_state_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<teletone_dtmf_detect_state_t>(),
        376usize,
        concat!("Size of: ", stringify!(teletone_dtmf_detect_state_t))
    );
    assert_eq!(
        ::std::mem::align_of::<teletone_dtmf_detect_state_t>(),
        8usize,
        concat!("Alignment of ", stringify!(teletone_dtmf_detect_state_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hit1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_dtmf_detect_state_t),
            "::",
            stringify!(hit1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hit2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_dtmf_detect_state_t),
            "::",
            stringify!(hit2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hit3) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_dtmf_detect_state_t),
            "::",
            stringify!(hit3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hit4) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_dtmf_detect_state_t),
            "::",
            stringify!(hit4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dur) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_dtmf_detect_state_t),
            "::",
            stringify!(dur)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zc) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_dtmf_detect_state_t),
            "::",
            stringify!(zc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).row_out) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_dtmf_detect_state_t),
            "::",
            stringify!(row_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).col_out) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_dtmf_detect_state_t),
            "::",
            stringify!(col_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).row_out2nd) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_dtmf_detect_state_t),
            "::",
            stringify!(row_out2nd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).col_out2nd) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_dtmf_detect_state_t),
            "::",
            stringify!(col_out2nd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).energy) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_dtmf_detect_state_t),
            "::",
            stringify!(energy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lenergy) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_dtmf_detect_state_t),
            "::",
            stringify!(lenergy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_sample) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_dtmf_detect_state_t),
            "::",
            stringify!(current_sample)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digit) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_dtmf_detect_state_t),
            "::",
            stringify!(digit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_digits) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_dtmf_detect_state_t),
            "::",
            stringify!(current_digits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).detected_digits) as usize - ptr as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_dtmf_detect_state_t),
            "::",
            stringify!(detected_digits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lost_digits) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_dtmf_detect_state_t),
            "::",
            stringify!(lost_digits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digit_hits) as usize - ptr as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_dtmf_detect_state_t),
            "::",
            stringify!(digit_hits)
        )
    );
}
#[doc = " \\brief An abstraction to store the coefficient of a tone frequency"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct teletone_detection_descriptor_t {
    pub fac: f32,
}
#[test]
fn bindgen_test_layout_teletone_detection_descriptor_t() {
    const UNINIT: ::std::mem::MaybeUninit<teletone_detection_descriptor_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<teletone_detection_descriptor_t>(),
        4usize,
        concat!("Size of: ", stringify!(teletone_detection_descriptor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<teletone_detection_descriptor_t>(),
        4usize,
        concat!("Alignment of ", stringify!(teletone_detection_descriptor_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_detection_descriptor_t),
            "::",
            stringify!(fac)
        )
    );
}
#[doc = " \\brief A container for a single multi-tone detection\nTELETONE_MAX_TONES dictates the maximum simultaneous tones that can be present\nin a multi-tone representation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct teletone_multi_tone_t {
    pub sample_rate: ::std::os::raw::c_int,
    pub tdd: [teletone_detection_descriptor_t; 18usize],
    pub gs: [teletone_goertzel_state_t; 18usize],
    pub gs2: [teletone_goertzel_state_t; 18usize],
    pub tone_count: ::std::os::raw::c_int,
    pub energy: f32,
    pub current_sample: ::std::os::raw::c_int,
    pub min_samples: ::std::os::raw::c_int,
    pub total_samples: ::std::os::raw::c_int,
    pub positives: ::std::os::raw::c_int,
    pub negatives: ::std::os::raw::c_int,
    pub hits: ::std::os::raw::c_int,
    pub positive_factor: ::std::os::raw::c_int,
    pub negative_factor: ::std::os::raw::c_int,
    pub hit_factor: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_teletone_multi_tone_t() {
    const UNINIT: ::std::mem::MaybeUninit<teletone_multi_tone_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<teletone_multi_tone_t>(),
        704usize,
        concat!("Size of: ", stringify!(teletone_multi_tone_t))
    );
    assert_eq!(
        ::std::mem::align_of::<teletone_multi_tone_t>(),
        8usize,
        concat!("Alignment of ", stringify!(teletone_multi_tone_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sample_rate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_multi_tone_t),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tdd) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_multi_tone_t),
            "::",
            stringify!(tdd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gs) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_multi_tone_t),
            "::",
            stringify!(gs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gs2) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_multi_tone_t),
            "::",
            stringify!(gs2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tone_count) as usize - ptr as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_multi_tone_t),
            "::",
            stringify!(tone_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).energy) as usize - ptr as usize },
        660usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_multi_tone_t),
            "::",
            stringify!(energy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_sample) as usize - ptr as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_multi_tone_t),
            "::",
            stringify!(current_sample)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_samples) as usize - ptr as usize },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_multi_tone_t),
            "::",
            stringify!(min_samples)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_samples) as usize - ptr as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_multi_tone_t),
            "::",
            stringify!(total_samples)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).positives) as usize - ptr as usize },
        676usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_multi_tone_t),
            "::",
            stringify!(positives)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).negatives) as usize - ptr as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_multi_tone_t),
            "::",
            stringify!(negatives)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hits) as usize - ptr as usize },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_multi_tone_t),
            "::",
            stringify!(hits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).positive_factor) as usize - ptr as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_multi_tone_t),
            "::",
            stringify!(positive_factor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).negative_factor) as usize - ptr as usize },
        692usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_multi_tone_t),
            "::",
            stringify!(negative_factor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hit_factor) as usize - ptr as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(teletone_multi_tone_t),
            "::",
            stringify!(hit_factor)
        )
    );
}
extern "C" {
    #[doc = "\\brief Initilize a multi-frequency tone detector\n\\param mt the multi-frequency tone descriptor\n\\param map a representation of the multi-frequency tone"]
    pub fn teletone_multi_tone_init(mt: *mut teletone_multi_tone_t, map: *mut teletone_tone_map_t);
}
extern "C" {
    #[doc = "\\brief Check a sample buffer for the presence of the mulit-frequency tone described by mt\n\\param mt the multi-frequency tone descriptor\n\\param sample_buffer an array aof 16 bit signed linear samples\n\\param samples the number of samples present in sample_buffer\n\\return true when the tone was detected or false when it is not"]
    pub fn teletone_multi_tone_detect(
        mt: *mut teletone_multi_tone_t,
        sample_buffer: *mut i16,
        samples: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Initilize a DTMF detection state object\n\\param dtmf_detect_state the DTMF detection state to initilize\n\\param sample_rate the desired sample rate"]
    pub fn teletone_dtmf_detect_init(
        dtmf_detect_state: *mut teletone_dtmf_detect_state_t,
        sample_rate: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "\\brief Check a sample buffer for the presence of DTMF digits\n\\param dtmf_detect_state the detection state object to check\n\\param sample_buffer an array aof 16 bit signed linear samples\n\\param samples the number of samples present in sample_buffer\n\\return true when DTMF was detected or false when it is not"]
    pub fn teletone_dtmf_detect(
        dtmf_detect_state: *mut teletone_dtmf_detect_state_t,
        sample_buffer: *mut i16,
        samples: ::std::os::raw::c_int,
    ) -> teletone_hit_type_t;
}
extern "C" {
    #[doc = "\\brief retrieve any collected digits into a string buffer\n\\param dtmf_detect_state the detection state object to check\n\\param buf the string buffer to write to\n\\param max the maximum length of buf\n\\return the number of characters written to buf"]
    pub fn teletone_dtmf_get(
        dtmf_detect_state: *mut teletone_dtmf_detect_state_t,
        buf: *mut ::std::os::raw::c_char,
        dur: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Step through the Goertzel Algorithm for each sample in a buffer\n\\param goertzel_state the goertzel state to step the samples through\n\\param sample_buffer an array aof 16 bit signed linear samples\n\\param samples the number of samples present in sample_buffer"]
    pub fn teletone_goertzel_update(
        goertzel_state: *mut teletone_goertzel_state_t,
        sample_buffer: *mut i16,
        samples: ::std::os::raw::c_int,
    );
}
pub type __uint128_t = u128;
